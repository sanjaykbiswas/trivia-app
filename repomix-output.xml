This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
backend/
  src/
    api/
      routes/
        __init__.py
        difficulty.py
        game.py
        pack.py
        question.py
        topic.py
        user.py
      schemas/
        __init__.py
        difficulty.py
        game.py
        pack.py
        question.py
        topic.py
        user.py
      __init__.py
      dependencies.py
    config/
      config.py
      supabase_client.py
    models/
      __init__.py
      base_schema.py
      game_participant.py
      game_question.py
      game_session.py
      incorrect_answers.py
      pack_group.py
      pack.py
      question.py
      topic.py
      user_pack_history.py
      user_question_history.py
      user.py
    repositories/
      __init__.py
      base_repository_impl.py
      base_repository.py
      game_participant_repository.py
      game_question_repository.py
      game_session_repository.py
      incorrect_answers_repository.py
      pack_group_repository.py
      pack_repository.py
      question_repository.py
      topic_repository.py
      user_pack_history_repository.py
      user_question_history_repository.py
      user_repository.py
    services/
      __init__.py
      difficulty_service.py
      game_service.py
      incorrect_answer_service.py
      pack_service.py
      question_service.py
      seed_question_service.py
      topic_service.py
      user_service.py
    utils/
      document_processing/
        __init__.py
        processors.py
      llm/
        __init__.py
        llm_json_repair.py
        llm_parsing_utils.py
        llm_service.py
      question_generation/
        __init__.py
        custom_instructions_creator.py
        incorrect_answer_generator.py
        pack_difficulty_creation.py
        pack_topic_creation.py
        question_generator.py
        seed_question_processor.py
        text_utils.py
      __init__.py
    main.py
    websocket_manager.py
  tests/
    test_api.py
    test_batch_generator.py
    test_game.py
    test_generator.py
    test_incorrect_answers.py
    test_supabase_integration.py
    test_users.py
  .gitignore
  conftest.py
  custom_instructions.txt
  pytest.ini
  requirements.txt
  run_api_server.py
website/
  .vite/
    deps/
      _metadata.json
      package.json
  public/
    placeholder.svg
    robots.txt
  src/
    components/
      ui/
        accordion.tsx
        alert-dialog.tsx
        alert.tsx
        aspect-ratio.tsx
        avatar.tsx
        badge.tsx
        breadcrumb.tsx
        button.tsx
        calendar.tsx
        card.tsx
        carousel.tsx
        chart.tsx
        checkbox.tsx
        collapsible.tsx
        command.tsx
        context-menu.tsx
        dialog.tsx
        drawer.tsx
        dropdown-menu.tsx
        form.tsx
        hover-card.tsx
        input-otp.tsx
        input.tsx
        label.tsx
        menubar.tsx
        navigation-menu.tsx
        pagination.tsx
        popover.tsx
        progress.tsx
        radio-group.tsx
        resizable.tsx
        scroll-area.tsx
        select.tsx
        separator.tsx
        sheet.tsx
        sidebar.tsx
        skeleton.tsx
        slider.tsx
        sonner.tsx
        switch.tsx
        table.tsx
        tabs.tsx
        textarea.tsx
        toast.tsx
        toaster.tsx
        toggle-group.tsx
        toggle.tsx
        tooltip.tsx
      AnswerButton.tsx
      AnswerItem.tsx
      GameHeader.tsx
      GameSettings.tsx
      Header.tsx
      PirateButton.tsx
      PlayerAvatar.tsx
      QuestionCard.tsx
      QuestionTimer.tsx
    hooks/
      use-mobile.tsx
      use-toast.ts
      useGameTimer.ts
      useQuestionManager.ts
      useWebSocket.ts
    lib/
      utils.ts
    pages/
      AuthScreen.tsx
      CountdownScreen.tsx
      GameplayScreen.tsx
      GameSelect.tsx
      Index.tsx
      NotFound.tsx
      ResultsScreen.tsx
      RoleSelect.tsx
      WaitingRoom.tsx
    services/
      gameApi.ts
      packApi.ts
      userApi.ts
    types/
      apiTypes.ts
      gameTypes.ts
      websocketTypes.ts
    utils/
      gamePlayUtils.ts
    App.css
    App.tsx
    config.ts
    index.css
    main.tsx
    vite-env.d.ts
  .env.development
  .gitignore
  components.json
  eslint.config.js
  index.html
  package.json
  postcss.config.js
  README.md
  tailwind.config.ts
  tsconfig.app.json
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/api/routes/__init__.py">
from fastapi import APIRouter

from .pack import router as pack_router
from .topic import router as topic_router
from .difficulty import router as difficulty_router
from .question import router as question_router
from .game import router as game_router
from .user import router as user_router  # Add this line

# Create main router
router = APIRouter()

# Include all route modules
router.include_router(pack_router, prefix="/packs", tags=["packs"])
router.include_router(topic_router, prefix="/packs/{pack_id}/topics", tags=["topics"])
router.include_router(difficulty_router, prefix="/packs/{pack_id}/difficulties", tags=["difficulties"])
router.include_router(question_router, prefix="/packs/{pack_id}/questions", tags=["questions"])
router.include_router(game_router, prefix="/games", tags=["games"])
router.include_router(user_router, prefix="/users", tags=["users"])
</file>

<file path="backend/src/api/routes/difficulty.py">
# backend/src/api/routes/difficulty.py
from fastapi import APIRouter, Depends, HTTPException, Path, Body
import logging
# --- MODIFIED LINE: Added Optional ---
from typing import Dict, Optional # Import Optional for type hint

# --- UPDATED IMPORTS ---
from ..dependencies import get_difficulty_service, get_pack_service # Removed get_topic_service as it's indirectly used by DifficultyService now
from ..schemas import (
    DifficultyGenerateRequest, DifficultyUpdateRequest, DifficultyResponse,
    DifficultyDescription # Import DifficultyDescription for response construction if needed
)
from ...services.difficulty_service import DifficultyService
from ...services.pack_service import PackService # Keep PackService for validation
# --- END UPDATED IMPORTS ---
from ...utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

router = APIRouter()

@router.post("/", response_model=DifficultyResponse)
async def generate_difficulties(
    pack_id: str = Path(..., description="ID of the pack"),
    # Use Optional[Body(None)] to handle cases where the request body is empty or omitted
    # --- THIS LINE CAUSED THE ERROR - FIX IS THE IMPORT ABOVE ---
    difficulty_request: Optional[DifficultyGenerateRequest] = Body(None),
    difficulty_service: DifficultyService = Depends(get_difficulty_service),
    pack_service: PackService = Depends(get_pack_service)
):
    """
    Generate difficulty descriptions for a pack. Fetches pack name internally.
    """
    pack_id = ensure_uuid(pack_id)

    # Set defaults if not provided or request body is missing
    force_regenerate = difficulty_request.force_regenerate if difficulty_request else False

    # Verify the pack exists first (no need to extract creation_name here)
    try:
        pack = await pack_service.pack_repository.get_by_id(pack_id)
        if not pack:
            raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")
    except Exception as e:
        logger.error(f"Error verifying pack existence: {str(e)}")
        raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")

    try:
        # Call the service method - it no longer needs creation_name or pack_topics
        difficulty_dict: Dict[str, DifficultyDescription] = await difficulty_service.generate_and_handle_existing_difficulty_descriptions(
            pack_id=pack_id,
            force_regenerate=force_regenerate
        )

        return DifficultyResponse(descriptions=difficulty_dict) # Ensure the response matches the schema

    except Exception as e:
        logger.error(f"Error generating difficulty descriptions: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Error generating difficulty descriptions: {str(e)}"
        )

@router.get("/", response_model=DifficultyResponse)
async def get_difficulties(
    pack_id: str = Path(..., description="ID of the pack"),
    difficulty_service: DifficultyService = Depends(get_difficulty_service),
    pack_service: PackService = Depends(get_pack_service) # Keep for validation
):
    """
    Get existing difficulty descriptions for a pack.
    """
    pack_id = ensure_uuid(pack_id)

    # Verify the pack exists
    try:
        pack = await pack_service.pack_repository.get_by_id(pack_id)
        if not pack:
            raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")
    except Exception as e:
        logger.error(f"Error verifying pack existence: {str(e)}")
        raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")

    try:
        # Get existing difficulty descriptions directly from the service
        difficulties = await difficulty_service.get_existing_difficulty_descriptions(pack_id)

        return DifficultyResponse(descriptions=difficulties)

    except Exception as e:
        logger.error(f"Error retrieving difficulty descriptions: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving difficulty descriptions: {str(e)}"
        )

@router.patch("/", response_model=DifficultyResponse)
async def update_difficulties(
    pack_id: str = Path(..., description="ID of the pack"),
    difficulty_request: DifficultyUpdateRequest = Body(...), # Request body is required
    difficulty_service: DifficultyService = Depends(get_difficulty_service),
    pack_service: PackService = Depends(get_pack_service) # Keep for validation
):
    """
    Update specific difficulty descriptions. Fetches pack name internally if needed by service.
    """
    pack_id = ensure_uuid(pack_id)

    # Verify the pack exists
    try:
        pack = await pack_service.pack_repository.get_by_id(pack_id)
        if not pack:
            raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")
    except Exception as e:
        logger.error(f"Error verifying pack existence: {str(e)}")
        raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")

    try:
        # Call service to update specific descriptions (no longer needs creation_name)
        updated_difficulties = await difficulty_service.update_specific_difficulty_descriptions(
            pack_id=pack_id,
            difficulty_updates=difficulty_request.custom_descriptions
        )

        return DifficultyResponse(descriptions=updated_difficulties)

    except Exception as e:
        logger.error(f"Error updating difficulty descriptions: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Error updating difficulty descriptions: {str(e)}"
        )
</file>

<file path="backend/src/api/routes/game.py">
# backend/src/api/routes/game.py
from fastapi import APIRouter, Depends, HTTPException, Path, Query, Body
from typing import Dict, List, Any, Optional
import logging
import random # Import random
import asyncio # Ensure asyncio is imported

from ..dependencies import get_game_service, get_pack_service
from ..schemas.game import (
    GameSessionCreateRequest, GameSessionJoinRequest, GameSessionSubmitAnswerRequest,
    GameSessionResponse, GameSessionListResponse, QuestionResultResponse, GameResultsResponse,
    GameStartResponse, # <<< Import the new schema
    # --- ADDED IMPORT ---
    GamePlayQuestionListResponse
)
from ...services.game_service import GameService
from ...services.pack_service import PackService
from ...utils import ensure_uuid
from ...models.game_session import GameStatus # Import if needed for direct status comparison

# Configure logger
logger = logging.getLogger(__name__)

router = APIRouter()

# --- CREATE GAME ---
@router.post("/create", response_model=GameSessionResponse)
async def create_game(
    game_data: GameSessionCreateRequest = Body(...),
    user_id: str = Query(..., description="ID of the host user"),
    game_service: GameService = Depends(get_game_service),
    pack_service: PackService = Depends(get_pack_service)
):
    """Create a new multiplayer game session."""
    try:
        user_id = ensure_uuid(user_id)
        pack = await pack_service.pack_repository.get_by_id(game_data.pack_id)
        if not pack:
            raise HTTPException(status_code=404, detail=f"Pack with ID {game_data.pack_id} not found")
        game_session = await game_service.create_game_session(
            host_user_id=user_id, pack_id=game_data.pack_id,
            max_participants=game_data.max_participants,
            question_count=game_data.question_count,
            time_limit_seconds=game_data.time_limit_seconds
        )
        participants = await game_service.game_participant_repo.get_by_game_session_id(game_session.id)
        return GameSessionResponse(
            id=game_session.id, code=game_session.code, status=game_session.status,
            pack_id=game_session.pack_id, max_participants=game_session.max_participants,
            question_count=game_session.question_count, time_limit_seconds=game_session.time_limit_seconds,
            current_question_index=game_session.current_question_index,
            participant_count=len(participants), is_host=True, created_at=game_session.created_at
        )
    except ValueError as e:
        logger.error(f"Error creating game: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error creating game: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to create game: {str(e)}")

# --- JOIN GAME ---
@router.post("/join", response_model=GameSessionResponse)
async def join_game(
    join_data: GameSessionJoinRequest = Body(...),
    user_id: str = Query(..., description="ID of the user joining"),
    game_service: GameService = Depends(get_game_service)
):
    """Join an existing game session."""
    try:
        user_id = ensure_uuid(user_id)
        game_session, participant = await game_service.join_game(
            game_code=join_data.game_code, user_id=user_id, display_name=join_data.display_name
        )
        participants = await game_service.game_participant_repo.get_by_game_session_id(game_session.id)
        return GameSessionResponse(
             id=game_session.id, code=game_session.code, status=game_session.status,
             pack_id=game_session.pack_id, max_participants=game_session.max_participants,
             question_count=game_session.question_count, time_limit_seconds=game_session.time_limit_seconds,
             current_question_index=game_session.current_question_index,
             participant_count=len(participants), is_host=participant.is_host, created_at=game_session.created_at
         )
    except ValueError as e:
        logger.warning(f"Error joining game {join_data.game_code}: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error joining game {join_data.game_code}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to join game: An internal error occurred.")

# --- LIST GAMES ---
@router.get("/list", response_model=GameSessionListResponse)
async def list_games(
    user_id: str = Query(..., description="ID of the user"),
    include_completed: bool = Query(False, description="Whether to include completed games"),
    game_service: GameService = Depends(get_game_service)
):
    """List all games for a user."""
    try:
        user_id = ensure_uuid(user_id)
        games = await game_service.get_user_games(user_id=user_id, include_completed=include_completed)
        return GameSessionListResponse(total=len(games), games=games)
    except Exception as e:
        logger.error(f"Error listing games for user {user_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to list games: {str(e)}")

# --- START GAME ---
@router.post("/{game_id}/start", response_model=GameStartResponse)
async def start_game_endpoint(
    game_id: str = Path(..., description="ID of the game session"),
    user_id: str = Query(..., description="ID of the host user"),
    game_service: GameService = Depends(get_game_service)
):
    """Start a game session. Returns the status and first question."""
    try:
        game_id = ensure_uuid(game_id); user_id = ensure_uuid(user_id)
        game_session = await game_service.start_game(game_session_id=game_id, host_user_id=user_id)
        game_question = await game_service.game_question_repo.get_by_game_session_and_index(game_id, 0)
        if not game_question: raise HTTPException(status_code=500, detail="Failed to retrieve first question")
        original_question = await game_service.question_repo.get_by_id(game_question.question_id)
        if not original_question: raise HTTPException(status_code=500, detail="Failed to retrieve original question data")
        incorrect_answers = await game_service.incorrect_answers_repo.get_by_question_id(game_question.question_id)
        incorrect_options = incorrect_answers.incorrect_answers if incorrect_answers else []
        all_options = [original_question.answer] + incorrect_options; random.shuffle(all_options)
        response_data = {"status": game_session.status, "current_question": {"index": 0, "question_text": original_question.question, "options": all_options, "time_limit": game_session.time_limit_seconds}}
        return response_data
    except ValueError as e:
        logger.warning(f"Validation error starting game {game_id}: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error starting game {game_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to start game: An internal error occurred.")

# --- GET PLAY QUESTIONS (NEW ENDPOINT) ---
@router.get("/{game_id}/play-questions", response_model=GamePlayQuestionListResponse)
async def get_gameplay_questions(
    game_id: str = Path(..., description="ID of the game session"),
    game_service: GameService = Depends(get_game_service)
):
    """Get the list of questions (with shuffled options) for an active game."""
    try:
        game_id_str = ensure_uuid(game_id)
        play_questions = await game_service.get_questions_for_play(game_id_str)
        return GamePlayQuestionListResponse(
            game_id=game_id_str,
            questions=play_questions,
            total_questions=len(play_questions)
        )
    except ValueError as e:
        logger.warning(f"Error getting gameplay questions for game {game_id}: {str(e)}")
        # Distinguish between not found and other value errors
        status_code = 404 if "not found" in str(e).lower() else 400
        raise HTTPException(status_code=status_code, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error getting gameplay questions for game {game_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to retrieve game questions.")
# --- END GET PLAY QUESTIONS ---

# --- SUBMIT ANSWER ---
@router.post("/{game_id}/submit", response_model=QuestionResultResponse)
async def submit_answer(
    game_id: str = Path(..., description="ID of the game session"),
    participant_id: str = Query(..., description="ID of the participant"),
    answer_data: GameSessionSubmitAnswerRequest = Body(...),
    game_service: GameService = Depends(get_game_service)
):
    """Submit an answer for a question."""
    try:
        game_id = ensure_uuid(game_id); participant_id = ensure_uuid(participant_id)
        result = await game_service.submit_answer(
            game_session_id=game_id, participant_id=participant_id,
            question_index=answer_data.question_index, answer=answer_data.answer
        )
        if not result.get("success", True): raise ValueError(result.get("error", "Failed to submit answer."))
        return QuestionResultResponse(
            is_correct=result.get("is_correct", False), correct_answer=result.get("correct_answer", ""),
            score=result.get("score", 0), total_score=result.get("total_score", 0)
        )
    except ValueError as e:
        logger.warning(f"Error submitting answer for game {game_id}, participant {participant_id}: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error submitting answer for game {game_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to submit answer: {str(e)}")

# --- NEXT QUESTION ---
@router.post("/{game_id}/next", response_model=Dict[str, Any])
async def next_question(
    game_id: str = Path(..., description="ID of the game session"),
    user_id: str = Query(..., description="ID of the host user"),
    game_service: GameService = Depends(get_game_service)
):
    """Advance to the next question or end the game."""
    try:
        game_id = ensure_uuid(game_id); user_id = ensure_uuid(user_id)
        result = await game_service.end_current_question(game_session_id=game_id, host_user_id=user_id)
        return result
    except ValueError as e:
        logger.warning(f"Error advancing question for game {game_id}: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error advancing question for game {game_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to advance question: {str(e)}")

# --- CANCEL GAME ---
@router.post("/{game_id}/cancel")
async def cancel_game(
    game_id: str = Path(..., description="ID of the game session"),
    user_id: str = Query(..., description="ID of the host user"),
    game_service: GameService = Depends(get_game_service)
):
    """Cancel an active or pending game."""
    try:
        game_id = ensure_uuid(game_id); user_id = ensure_uuid(user_id)
        game_session = await game_service.cancel_game(game_session_id=game_id, host_user_id=user_id)
        return {"id": game_session.id, "status": game_session.status.value, "message": "Game successfully cancelled"}
    except ValueError as e:
        logger.warning(f"Error cancelling game {game_id}: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error cancelling game {game_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to cancel game: {str(e)}")

# --- GET RESULTS ---
@router.get("/{game_id}/results", response_model=GameResultsResponse)
async def get_results(
    game_id: str = Path(..., description="ID of the game session"),
    game_service: GameService = Depends(get_game_service)
):
    """Get results for a completed game."""
    try:
        game_id = ensure_uuid(game_id)
        results = await game_service.get_game_results(game_id)
        return results
    except ValueError as e:
        logger.warning(f"Error getting results for game {game_id}: {str(e)}")
        raise HTTPException(status_code=404 if "not found" in str(e).lower() else 400, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error getting results for game {game_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to get game results: {str(e)}")

# --- GET PARTICIPANTS ---
@router.get("/{game_id}/participants")
async def get_participants_endpoint(
    game_id: str = Path(..., description="ID of the game session"),
    game_service: GameService = Depends(get_game_service)
):
    """Get participants for a game session."""
    try:
        game_id_str = ensure_uuid(game_id)
        participants_data = await game_service.get_game_participants(game_id_str)
        return {"total": len(participants_data), "participants": participants_data}
    except Exception as e:
        logger.error(f"Error getting game participants for {game_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to get game participants: {str(e)}")
</file>

<file path="backend/src/api/routes/pack.py">
from fastapi import APIRouter, Depends, HTTPException, Query, status
from typing import List, Optional
import logging
import traceback

from ..dependencies import get_pack_service
from ..schemas import PackCreateRequest, PackResponse, PackListResponse
from ...services.pack_service import PackService
from ...models.pack import CreatorType
from ...utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

router = APIRouter()

@router.post("/", response_model=PackResponse, status_code=status.HTTP_201_CREATED)
async def create_pack(
    pack_data: PackCreateRequest,
    pack_service: PackService = Depends(get_pack_service)
):
    """
    Create a new trivia pack.
    
    Args:
        pack_data: Data for creating the pack
        pack_service: Pack service dependency
        
    Returns:
        Newly created pack
    """
    try:
        logger.info(f"Attempting to create pack with name: {pack_data.name}")
        
        # Check if a pack with this name already exists
        exists, existing_id = await pack_service.validate_creation_name(pack_data.name)
        
        if exists:
            logger.warning(f"Pack with name '{pack_data.name}' already exists")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"A pack with the name '{pack_data.name}' already exists"
            )
        
        # Create the pack
        logger.info(f"Creating new pack: {pack_data.name}")
        pack, _ = await pack_service.get_or_create_pack(
            pack_name=pack_data.name,
            pack_description=pack_data.description,
            price=pack_data.price,
            creator_type=pack_data.creator_type
        )
        
        logger.info(f"Successfully created pack: {pack.name} with ID: {pack.id}")
        return pack
        
    except HTTPException:
        # Re-raise HTTP exceptions
        logger.exception("HTTP exception while creating pack")
        raise
    except Exception as e:
        # Log the full exception with traceback
        logger.error(f"Unexpected error creating pack: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create pack: {str(e)}"
        )

@router.get("/", response_model=PackListResponse)
async def list_packs(
    skip: int = Query(0, ge=0, description="Number of packs to skip"),
    limit: int = Query(50, ge=1, le=100, description="Number of packs to return"),
    creator_type: Optional[CreatorType] = Query(None, description="Filter by creator type"),
    pack_service: PackService = Depends(get_pack_service)
):
    """
    Get a list of trivia packs with optional filtering.
    
    Args:
        skip: Number of packs to skip for pagination
        limit: Maximum number of packs to return
        creator_type: Optional filter by creator type
        pack_service: Pack service dependency
        
    Returns:
        List of packs matching the criteria
    """
    try:
        logger.info(f"Retrieving packs with skip={skip}, limit={limit}, creator_type={creator_type}")
        
        # Get packs from repository
        packs = await pack_service.pack_repository.get_all()
        
        # Filter by creator_type if provided
        if creator_type:
            packs = [p for p in packs if p.creator_type == creator_type]
        
        # Apply pagination
        total = len(packs)
        paginated_packs = packs[skip:skip + limit]
        
        logger.info(f"Retrieved {total} packs, returning {len(paginated_packs)}")
        
        return PackListResponse(
            total=total,
            packs=paginated_packs
        )
        
    except Exception as e:
        # Log the error
        logger.error(f"Error retrieving packs: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to retrieve packs: {str(e)}"
        )

@router.get("/{pack_id}", response_model=PackResponse)
async def get_pack(
    pack_id: str,
    pack_service: PackService = Depends(get_pack_service)
):
    """
    Get a specific trivia pack by ID.
    
    Args:
        pack_id: ID of the pack to retrieve
        pack_service: Pack service dependency
        
    Returns:
        The requested pack
    """
    try:
        # Ensure pack_id is a valid UUID string
        pack_id = ensure_uuid(pack_id)
        
        logger.info(f"Retrieving pack with ID: {pack_id}")
        
        # Get the pack from repository
        pack = await pack_service.pack_repository.get_by_id(pack_id)
        
        if not pack:
            logger.warning(f"Pack with ID {pack_id} not found")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Pack with ID {pack_id} not found"
            )
        
        logger.info(f"Successfully retrieved pack: {pack.name}")
        return pack
        
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        # Log the error
        logger.error(f"Error retrieving pack with ID {pack_id}: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to retrieve pack: {str(e)}"
        )
</file>

<file path="backend/src/api/routes/question.py">
# backend/src/api/routes/question.py
from fastapi import APIRouter, Depends, HTTPException, Path, Query, Body
from typing import Optional, List, Any, Dict # Added Dict
import logging
import traceback

from ..dependencies import (
    get_question_service,
    get_seed_question_service,
    get_difficulty_service,
    get_pack_service,
    get_incorrect_answer_service
)
from ..schemas import (
    QuestionGenerateRequest, SeedQuestionRequest, SeedQuestionTextRequest,
    QuestionResponse, QuestionsResponse, SeedQuestionsResponse,
    CustomInstructionsGenerateRequest, CustomInstructionsResponse, # Removed CustomInstructionsInputRequest
    # --- Use the updated schemas ---
    BatchQuestionGenerateRequest, BatchQuestionGenerateResponse
)
from ...services.question_service import QuestionService
from ...services.seed_question_service import SeedQuestionService
from ...services.difficulty_service import DifficultyService
from ...services.pack_service import PackService
from ...services.incorrect_answer_service import IncorrectAnswerService, IncorrectAnswerGenerationError
from ...models.question import DifficultyLevel, Question
from ...utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

router = APIRouter()

# --- Single Topic Question Generation Endpoint ---
@router.post("/", response_model=QuestionsResponse)
async def generate_questions(
    pack_id: str = Path(..., description="ID of the pack"),
    question_request: QuestionGenerateRequest = Body(...),
    question_service: QuestionService = Depends(get_question_service),
    pack_service: PackService = Depends(get_pack_service),
    incorrect_answer_service: IncorrectAnswerService = Depends(get_incorrect_answer_service)
):
    """
    Generate trivia questions for a SINGLE pack topic/difficulty and generate incorrect answers.
    Topic-specific custom instructions are fetched automatically if they exist.
    """
    pack_id_uuid = ensure_uuid(pack_id)

    # 1. Verify Pack Exists
    pack = await pack_service.pack_repository.get_by_id(pack_id_uuid)
    if not pack:
        raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")

    try:
        # 2. Generate Questions for the single topic/difficulty
        # Custom instructions are handled internally by the service now
        created_questions: List[Question] = await question_service.generate_and_store_questions(
            pack_id=pack_id_uuid,
            pack_name=pack.name, # Pass pack name
            pack_topic=question_request.pack_topic,
            difficulty=question_request.difficulty,
            num_questions=question_request.num_questions,
            debug_mode=question_request.debug_mode
            # custom_instructions=question_request.custom_instructions # Removed - Service fetches this
        )

        # 3. Generate Incorrect Answers for the newly created questions
        if created_questions:
            logger.info(f"Generated {len(created_questions)} questions for topic '{question_request.pack_topic}'. Now generating incorrect answers...")
            try:
                await incorrect_answer_service.generate_and_store_incorrect_answers(
                     questions=created_questions,
                     num_incorrect_answers=3, # Default or get from config
                     batch_size=5, # Default or get from config
                     debug_mode=question_request.debug_mode
                 )
                logger.info(f"Incorrect answer generation complete for topic '{question_request.pack_topic}'.")
            except IncorrectAnswerGenerationError as ia_error:
                 logger.error(f"Failed to generate some incorrect answers for topic '{question_request.pack_topic}': {ia_error.message}")
            except Exception as e_ia:
                 logger.error(f"Unexpected error during incorrect answer generation for topic '{question_request.pack_topic}': {e_ia}", exc_info=True)
        else:
             logger.warning(f"No questions were generated for topic '{question_request.pack_topic}', skipping incorrect answer generation.")

        # 4. Format response
        response_questions = [ QuestionResponse.model_validate(q) for q in created_questions ]
        return QuestionsResponse( total=len(response_questions), questions=response_questions )

    except Exception as e:
        logger.error(f"Error generating single topic questions: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Error generating questions: {str(e)}")


# --- Batch Question Generation Endpoint ---
@router.post("/batch-generate", response_model=BatchQuestionGenerateResponse)
async def batch_generate_questions(
    pack_id: str = Path(..., description="ID of the pack"),
    request: BatchQuestionGenerateRequest = Body(...), # Uses updated schema
    question_service: QuestionService = Depends(get_question_service),
    pack_service: PackService = Depends(get_pack_service),
    incorrect_answer_service: IncorrectAnswerService = Depends(get_incorrect_answer_service)
):
    """
    Generate questions for multiple topics *and* difficulties within a pack concurrently,
    followed by batch incorrect answer generation for all newly created questions.
    Topic-specific custom instructions are fetched automatically if they exist,
    but can be overridden per topic in the request.
    """
    pack_id_uuid = ensure_uuid(pack_id)

    # 1. Verify Pack Exists
    pack = await pack_service.pack_repository.get_by_id(pack_id_uuid)
    if not pack:
        raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")

    batch_results: Dict[str, Any] = {}
    final_status = "completed" # Default status
    error_list: List[str] = []

    try:
        # 2. Call the batch question generation service method
        # Service now handles fetching default instructions per topic if not overridden in request
        batch_results = await question_service.batch_generate_and_store_questions(
            pack_id=pack_id_uuid,
            pack_name=pack.name, # Pass pack name
            topic_configs=request.topic_configs, # Pass the structure including overrides
            debug_mode=request.debug_mode
        )
        error_list.extend(batch_results.get("failed_topics", []))

    except Exception as e_qg:
        logger.error(f"Core batch question generation failed for pack {pack_id}: {str(e_qg)}", exc_info=True)
        final_status = "failed"
        error_list = list(set([tc.topic for tc in request.topic_configs]))
        return BatchQuestionGenerateResponse(
            pack_id=pack_id, topics_processed=[], total_questions_generated=0,
            status=final_status, errors=error_list
        )

    # 3. Trigger Incorrect Answer Generation
    newly_generated_questions: List[Question] = batch_results.get("generated_questions", [])
    if newly_generated_questions:
         logger.info(f"Batch question step complete. Triggering incorrect answers for {len(newly_generated_questions)} new questions...")
         try:
             await incorrect_answer_service.generate_and_store_incorrect_answers(
                 questions=newly_generated_questions, num_incorrect_answers=3, batch_size=5, debug_mode=request.debug_mode
             )
             logger.info("Incorrect answer generation for batch completed.")
         except IncorrectAnswerGenerationError as ia_error:
             logger.error(f"Partial failure during incorrect answer generation for batch in pack {pack_id}: {ia_error.message}")
             final_status = "partial_failure"
             failed_q_ids_set = set(ia_error.failed_question_ids)
             # Find topics related to failed incorrect answer generations
             failed_ia_topics = set()
             for q in newly_generated_questions:
                 if str(q.id) in failed_q_ids_set and q.pack_topics_item:
                     failed_ia_topics.add(q.pack_topics_item)
             error_list.extend(list(failed_ia_topics))
         except Exception as e_ia:
             logger.error(f"Unexpected error during batch incorrect answer generation for pack {pack_id}: {e_ia}", exc_info=True)
             final_status = "partial_failure"
             # Potentially add all topics associated with the batch as errors if IA fails catastrophically
             error_list.extend(list(set([q.pack_topics_item for q in newly_generated_questions if q.pack_topics_item])))
    else:
         logger.warning("No new questions generated in the batch, skipping incorrect answer generation.")


    # 4. Determine final status and return summary
    successful_topics = batch_results.get("topics_processed", [])
    failed_topics_qg = batch_results.get("failed_topics", [])
    if final_status != "partial_failure": # Avoid overwriting IA failure status
        if not successful_topics and failed_topics_qg: final_status = "failed"
        elif failed_topics_qg: final_status = "partial_failure"

    unique_error_topics = list(set(error_list))
    return BatchQuestionGenerateResponse(
        pack_id=pack_id, topics_processed=successful_topics,
        total_questions_generated=batch_results.get("total_generated", 0),
        status=final_status, errors=unique_error_topics if unique_error_topics else None
    )
# --- END Batch Endpoint ---


# --- Other existing endpoints ---

@router.get("/", response_model=QuestionsResponse)
async def get_questions(
    pack_id: str = Path(..., description="ID of the pack"),
    topic: Optional[str] = Query(None, description="Filter by topic"),
    difficulty: Optional[DifficultyLevel] = Query(None, description="Filter by difficulty"),
    skip: int = Query(0, ge=0, description="Number of questions to skip"),
    limit: int = Query(50, ge=1, le=100, description="Number of questions to return"),
    question_service: QuestionService = Depends(get_question_service),
    pack_service: PackService = Depends(get_pack_service)
):
    """
    Get questions for a pack with optional filtering.
    """
    pack_id_uuid = ensure_uuid(pack_id)
    pack = await pack_service.pack_repository.get_by_id(pack_id_uuid)
    if not pack:
        raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")

    try:
        # Get questions based on filters
        if topic:
            questions = await question_service.get_questions_by_topic(pack_id_uuid, topic)
        else:
            questions = await question_service.get_questions_by_pack_id(pack_id_uuid)

        # Filter by difficulty if provided
        if difficulty:
            questions = [q for q in questions if q.difficulty_current == difficulty]

        # Apply pagination
        total = len(questions)
        paginated_questions_data = questions[skip:skip + limit]

        response_questions = [
             QuestionResponse.model_validate(q) for q in paginated_questions_data
        ]

        return QuestionsResponse(
            total=total,
            questions=response_questions
        )

    except Exception as e:
        logger.error(f"Error retrieving questions for pack {pack_id}: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving questions: {str(e)}"
        )


@router.post("/seed", response_model=SeedQuestionsResponse)
async def store_seed_questions(
    pack_id: str = Path(..., description="ID of the pack"),
    seed_request: SeedQuestionRequest = Body(...),
    seed_question_service: SeedQuestionService = Depends(get_seed_question_service),
    pack_service: PackService = Depends(get_pack_service)
):
    """
    Store seed questions for a pack.
    """
    pack_id_uuid = ensure_uuid(pack_id)
    pack = await pack_service.pack_repository.get_by_id(pack_id_uuid)
    if not pack:
        raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")

    try:
        # --- REMOVED OBSOLETE PackCreationData CHECK ---
        # No need to check or create PackCreationData here anymore
        # --- END REMOVED BLOCK ---

        success = await seed_question_service.store_seed_questions(
            pack_id=pack_id_uuid,
            seed_questions=seed_request.seed_questions
        )

        if not success:
            raise HTTPException(status_code=500, detail="Failed to store seed questions")

        return SeedQuestionsResponse(
            count=len(seed_request.seed_questions),
            seed_questions=seed_request.seed_questions
        )

    except Exception as e:
        logger.error(f"Error storing seed questions for pack {pack_id}: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Error storing seed questions: {str(e)}"
        )


@router.post("/seed/extract", response_model=SeedQuestionsResponse)
async def extract_seed_questions(
    pack_id: str = Path(..., description="ID of the pack"),
    text_request: SeedQuestionTextRequest = Body(...),
    seed_question_service: SeedQuestionService = Depends(get_seed_question_service),
    pack_service: PackService = Depends(get_pack_service)
):
    """
    Extract and store seed questions from text.
    """
    pack_id_uuid = ensure_uuid(pack_id)
    pack = await pack_service.pack_repository.get_by_id(pack_id_uuid)
    if not pack:
        raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")

    try:
        extracted_questions = await seed_question_service.seed_processor.detect_and_process_input(
            text_request.text_content
        )

        if not extracted_questions:
            raise HTTPException(status_code=400, detail="No questions could be extracted")

        # --- REMOVED OBSOLETE PackCreationData CHECK ---
        # No need to check or create PackCreationData here anymore
        # --- END REMOVED BLOCK ---

        success = await seed_question_service.store_seed_questions(
            pack_id=pack_id_uuid,
            seed_questions=extracted_questions
        )

        if not success:
            raise HTTPException(status_code=500, detail="Failed to store extracted seed questions")

        return SeedQuestionsResponse(
            count=len(extracted_questions),
            seed_questions=extracted_questions
        )

    except Exception as e:
        logger.error(f"Error extracting seed questions for pack {pack_id}: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Error extracting seed questions: {str(e)}"
        )


@router.get("/seed", response_model=SeedQuestionsResponse)
async def get_seed_questions(
    pack_id: str = Path(..., description="ID of the pack"),
    seed_question_service: SeedQuestionService = Depends(get_seed_question_service),
    pack_service: PackService = Depends(get_pack_service)
):
    """
    Get seed questions for a pack.
    """
    pack_id_uuid = ensure_uuid(pack_id)
    pack = await pack_service.pack_repository.get_by_id(pack_id_uuid)
    if not pack:
        raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")

    try:
        seed_questions = await seed_question_service.get_seed_questions(pack_id_uuid)
        return SeedQuestionsResponse(
            count=len(seed_questions),
            seed_questions=seed_questions
        )
    except Exception as e:
        logger.error(f"Error retrieving seed questions for pack {pack_id}: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving seed questions: {str(e)}"
        )

# --- Custom Instructions Endpoints (Modified) ---
@router.post("/custom-instructions/generate", response_model=CustomInstructionsResponse)
async def generate_custom_instructions(
    pack_id: str = Path(..., description="ID of the pack"),
    request: CustomInstructionsGenerateRequest = Body(...), # Requires pack_topic
    seed_question_service: SeedQuestionService = Depends(get_seed_question_service),
    pack_service: PackService = Depends(get_pack_service)
):
    """
    Generate and store custom instructions for a specific topic within the pack.
    """
    pack_id_uuid = ensure_uuid(pack_id)
    pack = await pack_service.pack_repository.get_by_id(pack_id_uuid)
    if not pack: raise HTTPException(status_code=404, detail=f"Pack {pack_id} not found")

    # Ensure the topic exists within the pack
    topic = await seed_question_service.topic_repository.get_by_name_and_pack_id(request.pack_topic, pack_id_uuid)
    if not topic:
        raise HTTPException(status_code=404, detail=f"Topic '{request.pack_topic}' not found in pack {pack_id}")

    try:
        # Call the service method which now handles storing per-topic
        custom_instructions = await seed_question_service.generate_custom_instructions(
            pack_id_uuid,
            request.pack_topic
        )
        if custom_instructions is None: raise HTTPException(status_code=500, detail="Failed to generate instructions")
        return CustomInstructionsResponse(custom_instructions=custom_instructions)
    except Exception as e:
        logger.error(f"Error generating custom instructions: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Error: {e}")

# --- REMOVED /custom-instructions/input endpoint ---
# @router.post("/custom-instructions/input", ...)

# --- MODIFIED GET /custom-instructions endpoint ---
@router.get("/custom-instructions", response_model=CustomInstructionsResponse)
async def get_topic_custom_instructions(
    pack_id: str = Path(..., description="ID of the pack"),
    topic_name: str = Query(..., description="Name of the topic to get instructions for"), # Added required query param
    seed_question_service: SeedQuestionService = Depends(get_seed_question_service),
    pack_service: PackService = Depends(get_pack_service)
):
    """
    Get the stored custom instructions for a specific topic within the pack.
    """
    pack_id_uuid = ensure_uuid(pack_id)
    pack = await pack_service.pack_repository.get_by_id(pack_id_uuid)
    if not pack: raise HTTPException(status_code=404, detail=f"Pack {pack_id} not found")

    try:
        # Use the new service method to get instruction for a specific topic
        custom_instructions = await seed_question_service.get_topic_custom_instruction(
            pack_id=pack_id_uuid,
            topic_name=topic_name
        )
        # If topic exists but has no instruction, service returns None
        if custom_instructions is None:
            logger.info(f"No custom instructions found for topic '{topic_name}' in pack {pack_id}")
            # Optionally raise 404 or return None/empty based on desired behavior
            # Let's return None as per the schema
            return CustomInstructionsResponse(custom_instructions=None)

        return CustomInstructionsResponse(custom_instructions=custom_instructions)
    except Exception as e:
        logger.error(f"Error retrieving custom instructions for topic '{topic_name}': {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Error: {e}")

# --- Incorrect Answers Endpoints (remain unchanged) ---
@router.post("/{question_id}/incorrect-answers")
async def generate_single_question_incorrect_answers(
    pack_id: str = Path(..., description="ID of the pack"),
    question_id: str = Path(..., description="ID of the question"),
    num_answers: int = Query(3, ge=1, le=10), debug_mode: bool = Query(False),
    incorrect_answer_service: IncorrectAnswerService = Depends(get_incorrect_answer_service),
    question_service: QuestionService = Depends(get_question_service)
):
    question_id_uuid = ensure_uuid(question_id)
    pack_id_uuid = ensure_uuid(pack_id)
    question = await question_service.question_repository.get_by_id(question_id_uuid)
    if not question: raise HTTPException(status_code=404, detail=f"Question {question_id} not found")
    # Ensure pack_id is compared as strings
    if str(question.pack_id) != str(pack_id_uuid): raise HTTPException(status_code=400, detail=f"Question {question_id} not in pack {pack_id}")
    try:
        result_map = await incorrect_answer_service.generate_and_store_incorrect_answers(
            questions=[question], num_incorrect_answers=num_answers, debug_mode=debug_mode
        )
        # Key should be string representation of UUID
        result_key = str(question_id_uuid)
        if result_key in result_map:
             return {"question_id": result_key, "incorrect_answers": result_map[result_key]}
        else:
             # Check if generation itself failed or just storage
             if hasattr(result_map, 'get') and result_map.get('failed_ids') and result_key in result_map['failed_ids']:
                 raise HTTPException(status_code=500, detail="Failed to generate incorrect answers for this question.")
             else:
                 raise HTTPException(status_code=500, detail="Failed to generate or store incorrect answers for this question.")

    except IncorrectAnswerGenerationError as e:
        raise HTTPException(status_code=500, detail=f"Failed to generate incorrect answers: {e.message}")
    except Exception as e:
        logger.error(f"Error generating incorrect answers for Q {question_id}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed: {e}")


@router.post("/incorrect-answers/batch")
async def generate_pack_incorrect_answers(
    pack_id: str = Path(..., description="ID of the pack"),
    num_answers: int = Query(3, ge=1, le=10), batch_size: int = Query(5, ge=1, le=20), debug_mode: bool = Query(False),
    incorrect_answer_service: IncorrectAnswerService = Depends(get_incorrect_answer_service),
    pack_service: PackService = Depends(get_pack_service)
):
    pack_id_uuid = ensure_uuid(pack_id)
    pack = await pack_service.pack_repository.get_by_id(pack_id_uuid)
    if not pack: raise HTTPException(status_code=404, detail=f"Pack {pack_id} not found")
    try:
        results_map = await incorrect_answer_service.generate_for_pack(
            pack_id=pack_id_uuid, num_incorrect_answers=num_answers, batch_size=batch_size, debug_mode=debug_mode
        )
        # Success means no exception was raised by the service
        return {"pack_id": pack_id, "questions_processed": len(results_map), "status": "completed"}
    except IncorrectAnswerGenerationError as e:
         # Service layer indicates partial/total failure
         return {
            "pack_id": pack_id, "questions_processed": -1, "status": "partial_failure",
            "error": e.message, "failed_ids": e.failed_question_ids
         }
    except Exception as e:
        logger.error(f"Error generating incorrect answers for pack {pack_id}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed: {e}")
</file>

<file path="backend/src/api/routes/topic.py">
# backend/src/api/routes/topic.py
from fastapi import APIRouter, Depends, HTTPException, Path, Body # Import Body
import logging
from typing import Optional # Import Optional

# --- UPDATED IMPORTS ---
from ..dependencies import get_topic_service, get_pack_service
from ..schemas import TopicGenerateRequest, TopicAddRequest, TopicResponse
from ...services.topic_service import TopicService
from ...services.pack_service import PackService
# --- END UPDATED IMPORTS ---
from ...utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

router = APIRouter()

@router.post("/", response_model=TopicResponse)
async def generate_topics(
    pack_id: str = Path(..., description="ID of the pack"),
    # Use Optional[Body(None)] to handle cases where the request body is empty or omitted
    topic_request: Optional[TopicGenerateRequest] = Body(None),
    topic_service: TopicService = Depends(get_topic_service),
    pack_service: PackService = Depends(get_pack_service)
):
    """
    Generate topics for a pack. Fetches pack name internally.
    """
    pack_id = ensure_uuid(pack_id)

    # Set defaults if request body is missing
    num_topics = topic_request.num_topics if topic_request else 5
    predefined_topic = topic_request.predefined_topic if topic_request else None

    # Verify pack exists to get its name for the service layer
    try:
        pack = await pack_service.pack_repository.get_by_id(pack_id)
        if not pack:
            raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")
        pack_name = pack.name # Get pack name for service
    except Exception as e:
        logger.error(f"Error verifying pack existence: {str(e)}")
        raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")

    try:
        # Call service method - requires pack_name from the fetched pack
        topics = await topic_service.generate_or_use_topics(
            pack_id=pack_id,
            pack_name=pack_name, # <<< CHANGED: Pass pack_name instead of creation_name
            num_topics=num_topics,
            predefined_topic=predefined_topic
        )

        return TopicResponse(topics=topics)

    except Exception as e:
        logger.error(f"Error generating topics: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Error generating topics: {str(e)}"
        )

@router.get("/", response_model=TopicResponse)
async def get_topics(
    pack_id: str = Path(..., description="ID of the pack"),
    topic_service: TopicService = Depends(get_topic_service),
    pack_service: PackService = Depends(get_pack_service) # Keep for validation
):
    """
    Get existing topics for a pack.
    """
    pack_id = ensure_uuid(pack_id)

    # Verify pack exists (optional, but good practice)
    try:
        pack = await pack_service.pack_repository.get_by_id(pack_id)
        if not pack:
            raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")
    except Exception as e:
        logger.error(f"Error verifying pack existence: {str(e)}")
        raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")

    try:
        topics = await topic_service.get_existing_pack_topics(pack_id)
        return TopicResponse(topics=topics) # Returns empty list if none found

    except Exception as e:
        logger.error(f"Error retrieving topics: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving topics: {str(e)}"
        )

@router.post("/additional", response_model=TopicResponse)
async def add_topics(
    pack_id: str = Path(..., description="ID of the pack"),
    # Use Optional[Body(None)] to handle cases where the request body is empty or omitted
    topic_request: Optional[TopicAddRequest] = Body(None),
    topic_service: TopicService = Depends(get_topic_service),
    pack_service: PackService = Depends(get_pack_service)
):
    """
    Add additional topics to a pack. Fetches pack name internally.
    """
    pack_id = ensure_uuid(pack_id)

    # Set defaults if request body is missing
    num_additional_topics = topic_request.num_additional_topics if topic_request else 3
    predefined_topic = topic_request.predefined_topic if topic_request else None

    # Verify pack exists to get its name for the service layer
    try:
        pack = await pack_service.pack_repository.get_by_id(pack_id)
        if not pack:
            raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")
        pack_name = pack.name # Get pack name for service
    except Exception as e:
        logger.error(f"Error verifying pack existence: {str(e)}")
        raise HTTPException(status_code=404, detail=f"Pack with ID {pack_id} not found")

    try:
        # Call service method - requires pack_name
        all_topics = await topic_service.add_additional_topics(
            pack_id=pack_id,
            pack_name=pack_name, # <<< CHANGED: Pass pack_name instead of creation_name
            num_additional_topics=num_additional_topics,
            predefined_topic=predefined_topic
        )

        return TopicResponse(topics=all_topics)

    except Exception as e:
        logger.error(f"Error adding topics: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Error adding topics: {str(e)}"
        )
</file>

<file path="backend/src/api/routes/user.py">
from fastapi import APIRouter, Depends, HTTPException, Path, Query, Body, status
from typing import Optional
import logging
import traceback

from ..dependencies import get_user_service
from ..schemas.user import (
    UserCreateRequest, UserResponse, UserUpdateRequest,
    UserLoginRequest, UserAuthRequest, UserConvertRequest
)
from ...services.user_service import UserService
from ...utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

router = APIRouter()

@router.post("/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(
    user_data: UserCreateRequest = Body(...),
    user_service: UserService = Depends(get_user_service)
):
    """
    Create a new user.
    
    Args:
        user_data: Data for creating the user
        user_service: User service dependency
        
    Returns:
        Newly created user
    """
    try:
        user = await user_service.create_user(
            displayname=user_data.displayname,
            email=user_data.email,
            is_temporary=user_data.is_temporary,
            auth_provider=user_data.auth_provider,
            auth_id=user_data.auth_id
        )
        
        return user
        
    except ValueError as e:
        logger.warning(f"Validation error creating user: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Error creating user: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create user: {str(e)}"
        )

@router.get("/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: str = Path(..., description="ID of the user"),
    user_service: UserService = Depends(get_user_service)
):
    """
    Get a user by ID.
    
    Args:
        user_id: ID of the user to retrieve
        user_service: User service dependency
        
    Returns:
        User data
    """
    try:
        user = await user_service.get_user(user_id)
        
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"User with ID {user_id} not found"
            )
        
        return user
        
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        logger.error(f"Error retrieving user {user_id}: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to retrieve user: {str(e)}"
        )

@router.put("/{user_id}", response_model=UserResponse)
async def update_user(
    user_id: str = Path(..., description="ID of the user"),
    user_data: UserUpdateRequest = Body(...),
    user_service: UserService = Depends(get_user_service)
):
    """
    Update a user.
    
    Args:
        user_id: ID of the user to update
        user_data: Data for updating the user
        user_service: User service dependency
        
    Returns:
        Updated user data
    """
    try:
        updated_user = await user_service.update_user(
            user_id=user_id,
            displayname=user_data.displayname,
            email=user_data.email,
            is_temporary=user_data.is_temporary,
            auth_provider=user_data.auth_provider,
            auth_id=user_data.auth_id
        )
        
        if not updated_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"User with ID {user_id} not found"
            )
        
        return updated_user
        
    except ValueError as e:
        logger.warning(f"Validation error updating user: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        logger.error(f"Error updating user {user_id}: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to update user: {str(e)}"
        )

@router.delete("/{user_id}", response_model=UserResponse)
async def delete_user(
    user_id: str = Path(..., description="ID of the user"),
    user_service: UserService = Depends(get_user_service)
):
    """
    Delete a user.
    
    Args:
        user_id: ID of the user to delete
        user_service: User service dependency
        
    Returns:
        Deleted user data
    """
    try:
        deleted_user = await user_service.delete_user(user_id)
        
        if not deleted_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"User with ID {user_id} not found"
            )
        
        return deleted_user
        
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        logger.error(f"Error deleting user {user_id}: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to delete user: {str(e)}"
        )

@router.post("/auth", response_model=UserResponse)
async def authenticate_user(
    auth_data: UserAuthRequest = Body(...),
    user_service: UserService = Depends(get_user_service)
):
    """
    Authenticate a user via third-party provider or create if not exists.
    
    Args:
        auth_data: Authentication data
        user_service: User service dependency
        
    Returns:
        User data
    """
    try:
        user, created = await user_service.get_or_create_user_by_auth(
            auth_provider=auth_data.auth_provider,
            auth_id=auth_data.auth_id,
            email=auth_data.email,
            displayname=auth_data.displayname,
            is_temporary=False
        )
        
        return user
        
    except ValueError as e:
        logger.warning(f"Validation error in authentication: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Error in authentication: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Authentication failed: {str(e)}"
        )

@router.post("/convert/{user_id}", response_model=UserResponse)
async def convert_temporary_user(
    user_id: str = Path(..., description="ID of the temporary user"),
    convert_data: UserConvertRequest = Body(...),
    user_service: UserService = Depends(get_user_service)
):
    """
    Convert a temporary user to a permanent one.
    
    Args:
        user_id: ID of the temporary user
        convert_data: Data for converting the user
        user_service: User service dependency
        
    Returns:
        Updated user data
    """
    try:
        updated_user = await user_service.convert_temporary_user(
            user_id=user_id,
            displayname=convert_data.displayname,
            email=convert_data.email,
            auth_provider=convert_data.auth_provider,
            auth_id=convert_data.auth_id
        )
        
        if not updated_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"User with ID {user_id} not found"
            )
        
        return updated_user
        
    except ValueError as e:
        logger.warning(f"Validation error converting user: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        logger.error(f"Error converting user {user_id}: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to convert user: {str(e)}"
        )

@router.get("/email/{email}", response_model=UserResponse)
async def get_user_by_email(
    email: str = Path(..., description="Email address to search for"),
    user_service: UserService = Depends(get_user_service)
):
    """
    Get a user by email address.
    
    Args:
        email: Email address to search for
        user_service: User service dependency
        
    Returns:
        User data
    """
    try:
        user = await user_service.get_user_by_email(email)
        
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"User with email {email} not found"
            )
        
        return user
        
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        logger.error(f"Error retrieving user by email {email}: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to retrieve user: {str(e)}"
        )
</file>

<file path="backend/src/api/schemas/__init__.py">
# backend/src/api/schemas/__init__.py
"""
API schemas for request and response models.
"""

# Import schemas from individual files
from .pack import PackCreateRequest, PackResponse, PackListResponse
from .topic import TopicGenerateRequest, TopicAddRequest, TopicResponse
from .difficulty import DifficultyDescription, DifficultyGenerateRequest, DifficultyUpdateRequest, DifficultyResponse
from .question import (
    QuestionGenerateRequest, SeedQuestionRequest, SeedQuestionTextRequest,
    QuestionResponse, QuestionsResponse, SeedQuestionsResponse,
    CustomInstructionsGenerateRequest,
    CustomInstructionsResponse,
    # --- ADDED/MODIFIED IMPORTS for batch generation ---
    DifficultyConfig,
    TopicQuestionConfig,
    BatchQuestionGenerateRequest,
    BatchQuestionGenerateResponse
)
from .game import (
    GameSessionCreateRequest, GameSessionJoinRequest, GameSessionSubmitAnswerRequest,
    ParticipantResponse, GameSessionResponse, GameSessionListResponse,
    # GameQuestionResponse, <-- Removed, replaced by GamePlayQuestionResponse
    QuestionResultResponse, GameResultsResponse, GameStartResponse,
    # --- ADDED NEW SCHEMAS ---
    GamePlayQuestionResponse,
    GamePlayQuestionListResponse
)
from .user import (
    UserCreateRequest, UserResponse, UserUpdateRequest,
    UserLoginRequest, UserAuthRequest, UserConvertRequest
)

# Define what gets imported when using 'from .schemas import *'
# Also makes these schemas available directly under 'schemas' namespace
__all__ = [
    # Pack schemas
    "PackCreateRequest",
    "PackResponse",
    "PackListResponse",

    # Topic schemas
    "TopicGenerateRequest",
    "TopicAddRequest",
    "TopicResponse",

    # Difficulty schemas
    "DifficultyDescription",
    "DifficultyGenerateRequest",
    "DifficultyUpdateRequest",
    "DifficultyResponse",

    # Question schemas
    "QuestionGenerateRequest",
    "SeedQuestionRequest",
    "SeedQuestionTextRequest",
    "QuestionResponse",
    "QuestionsResponse",
    "SeedQuestionsResponse",
    "CustomInstructionsGenerateRequest",
    "CustomInstructionsResponse",
    # --- ADDED/MODIFIED SCHEMAS for batch generation ---
    "DifficultyConfig",
    "TopicQuestionConfig",
    "BatchQuestionGenerateRequest",
    "BatchQuestionGenerateResponse",

    # Game schemas
    "GameSessionCreateRequest",
    "GameSessionJoinRequest",
    "GameSessionSubmitAnswerRequest",
    "ParticipantResponse",
    "GameSessionResponse",
    "GameSessionListResponse",
    # "GameQuestionResponse", <-- Removed
    "QuestionResultResponse",
    "GameResultsResponse",
    "GameStartResponse",
    # --- ADDED NEW SCHEMAS ---
    "GamePlayQuestionResponse",
    "GamePlayQuestionListResponse",

    # User schemas
    "UserCreateRequest",
    "UserResponse",
    "UserUpdateRequest",
    "UserLoginRequest",
    "UserAuthRequest",
    "UserConvertRequest",
]
</file>

<file path="backend/src/api/schemas/difficulty.py">
# backend/src/api/schemas/difficulty.py
from typing import Dict, List, Optional
from pydantic import BaseModel, Field

class DifficultyDescription(BaseModel):
    """Schema for a single difficulty description."""
    base: str = Field(..., description="Base description for this difficulty level")
    custom: str = Field(..., description="Custom description for this difficulty level")

class DifficultyGenerateRequest(BaseModel):
    """Request schema for generating difficulty descriptions."""
    # creation_name: Optional[str] = Field(None, description="Optional pack name to use for generation (defaults to pack's name)") # REMOVED
    force_regenerate: bool = Field(False, description="Whether to regenerate descriptions even if they already exist")

class DifficultyUpdateRequest(BaseModel):
    """Request schema for updating specific difficulty descriptions."""
    custom_descriptions: Dict[str, str] = Field(..., description="Mapping of difficulty levels to their custom descriptions")
    # creation_name: Optional[str] = Field(None, description="Optional pack name to use for generation (defaults to pack's name)") # REMOVED

class DifficultyResponse(BaseModel):
    """Response schema for difficulty descriptions."""
    descriptions: Dict[str, DifficultyDescription] = Field(..., description="Mapping of difficulty levels to their descriptions")
</file>

<file path="backend/src/api/schemas/game.py">
# backend/src/api/schemas/game.py
# --- START OF FULL MODIFIED FILE ---
from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field
from datetime import datetime

# Import the enum from the correct location
from ...models.game_session import GameStatus

class GameSessionCreateRequest(BaseModel):
    """Request schema for creating a new game session."""
    pack_id: str = Field(..., description="ID of the pack to use for the game")
    max_participants: int = Field(10, description="Maximum number of participants allowed", ge=1, le=50) # Allow 1 for solo
    question_count: int = Field(10, description="Number of questions to include in the game", ge=1, le=75)
    time_limit_seconds: int = Field(0, description="Time limit per question in seconds (0 for no limit)", ge=0)

class GameSessionJoinRequest(BaseModel):
    """Request schema for joining a game session."""
    game_code: str = Field(..., description="Code for the game to join")
    display_name: str = Field(..., description="Display name to use in the game")

class GameSessionSubmitAnswerRequest(BaseModel):
    """Request schema for submitting an answer."""
    question_index: int = Field(..., description="Index of the question being answered", ge=0)
    answer: str = Field(..., description="Answer submitted by the participant")

class ParticipantResponse(BaseModel):
    """Response schema for a game participant."""
    id: str
    display_name: str
    score: int
    is_host: bool

class GameSessionResponse(BaseModel):
    """Response schema for a game session."""
    id: str
    code: str
    status: GameStatus # Use enum
    pack_id: str
    max_participants: int
    question_count: int
    time_limit_seconds: int
    current_question_index: int
    participant_count: int = Field(..., description="Current number of participants")
    is_host: bool = Field(..., description="Whether the current user is the host")
    created_at: datetime # Keep as datetime, Pydantic handles serialization

    class Config:
        from_attributes = True
        use_enum_values = True # Serialize enums to values

class GameSessionListResponse(BaseModel):
    """Response schema for listing game sessions."""
    total: int
    games: List[Dict[str, Any]] # Keep as Dict for flexibility from service

# --- MODIFIED / ADDED Schemas ---

# Renamed GameQuestionInfo -> ApiGameQuestionInfo to avoid frontend naming conflicts potentially
class ApiGameQuestionInfo(BaseModel):
    """Schema for the current question info returned on game start or next question."""
    index: int
    question_text: str
    options: List[str]
    time_limit: int

class GameStartResponse(BaseModel):
    """Response schema for the start_game endpoint."""
    status: GameStatus # Use the enum type
    current_question: ApiGameQuestionInfo

    class Config:
        from_attributes = True # Needed if status comes from an object attribute
        use_enum_values = True # Ensure enums are serialized to their values

class QuestionResultResponse(BaseModel):
    """Response schema for question result."""
    is_correct: bool
    correct_answer: str
    score: int
    total_score: int

class GameResultsResponse(BaseModel):
    """Response schema for game results."""
    game_id: str
    game_code: str
    status: GameStatus # Use enum
    participants: List[Dict[str, Any]] # Keep Dict for flexibility
    questions: List[Dict[str, Any]] # Keep Dict for flexibility
    total_questions: int
    completed_at: datetime # Keep datetime

    class Config:
        from_attributes = True
        use_enum_values = True

# --- NEW SCHEMAS FOR /play-questions Endpoint ---
class GamePlayQuestionResponse(BaseModel):
    """Schema for a single question served during gameplay."""
    index: int = Field(..., description="0-based index of the question in the game sequence")
    question_id: str = Field(..., description="Original ID of the question")
    question_text: str = Field(..., description="The text of the question")
    options: List[str] = Field(..., description="Shuffled list of answer options (correct + incorrect)")
    # --- ADDED FIELD ---
    correct_answer_id: str = Field(..., description="The ID (e.g., 'qID-optionIndex') of the correct option within the shuffled list")
    # --- END ADDED FIELD ---
    time_limit: int = Field(..., description="Time limit for this question in seconds (from game settings)")

    class Config:
        from_attributes = True # Allow creation from ORM models or dicts

class GamePlayQuestionListResponse(BaseModel):
    """Response schema for the list of questions for gameplay."""
    game_id: str
    questions: List[GamePlayQuestionResponse]
    total_questions: int # Actual number of questions in this game
# --- END NEW SCHEMAS ---
# --- END OF FULL MODIFIED FILE ---
</file>

<file path="backend/src/api/schemas/pack.py">
# backend/src/api/schemas/pack.py
from typing import Optional, List
from pydantic import BaseModel, Field
from datetime import datetime

from ...models.pack import CreatorType

class PackCreateRequest(BaseModel):
    """Request schema for creating a new pack."""
    name: str = Field(..., description="Name of the pack")
    description: Optional[str] = Field(None, description="Optional description of the pack")
    price: float = Field(0.0, description="Price of the pack (default: 0.0 for free packs)")
    creator_type: CreatorType = Field(CreatorType.SYSTEM, description="Type of creator")
    pack_group_id: Optional[List[str]] = Field(None, description="Optional list of pack group IDs")

class PackResponse(BaseModel):
    """Response schema for pack data."""
    id: str
    name: str
    description: Optional[str] = None
    price: float
    pack_group_id: Optional[List[str]] = None
    creator_type: CreatorType
    correct_answer_rate: Optional[float] = None
    created_at: datetime

    class Config:
        from_attributes = True

class PackListResponse(BaseModel):
    """Response schema for list of packs."""
    total: int
    packs: List[PackResponse]
</file>

<file path="backend/src/api/schemas/question.py">
# backend/src/api/schemas/question.py
from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field
from datetime import datetime

# Make sure the path to DifficultyLevel is correct for your structure
from ...models.question import DifficultyLevel

# --- NEW Schema for Difficulty Configuration ---
class DifficultyConfig(BaseModel):
    """Configuration for generating questions for a specific difficulty level."""
    difficulty: DifficultyLevel = Field(..., description="The specific difficulty level for this batch")
    num_questions: int = Field(5, description="Number of questions for this difficulty", ge=1, le=75)

# --- MODIFIED Schema for Topic Configuration ---
class TopicQuestionConfig(BaseModel):
    """Configuration for generating questions for a single topic across multiple difficulties."""
    topic: str = Field(..., description="The topic name")
    # Changed from single difficulty/num_questions to a list of configurations
    difficulty_configs: List[DifficultyConfig] = Field(..., description="List of difficulty configurations for this topic")
    custom_instructions: Optional[str] = Field(None, description="Optional custom instructions override for this specific topic")

# --- Batch Generation Request (uses updated TopicQuestionConfig) ---
class BatchQuestionGenerateRequest(BaseModel):
    """Request schema for batch question generation across multiple topics and difficulties."""
    topic_configs: List[TopicQuestionConfig] = Field(..., description="List of topic configurations, each specifying difficulties and counts")
    # --- ADDED regenerate_instructions flag ---
    regenerate_instructions: bool = Field(False, description="Whether to force regeneration of topic custom instructions even if they exist.")
    # --- END ADDED flag ---
    debug_mode: bool = Field(False, description="Enable verbose debug output globally for this batch")
    # Example: global_custom_instructions: Optional[str] = Field(None, description="Global custom instructions for all topics")

# --- Batch Generation Response (can be enhanced later) ---
class BatchQuestionGenerateResponse(BaseModel):
    """Response schema for batch question generation."""
    pack_id: str
    topics_processed: List[str] # Topics with at least one successful generation
    total_questions_generated: int
    status: str # e.g., "completed", "partial_failure", "failed"
    errors: Optional[List[str]] = None # List of topic names where at least one difficulty failed

# --- Other Schemas (remain largely the same) ---

class QuestionGenerateRequest(BaseModel):
    """Request schema for generating questions for a single topic/difficulty."""
    pack_topic: str = Field(..., description="Topic to generate questions for")
    difficulty: DifficultyLevel = Field(DifficultyLevel.MIXED, description="Difficulty level for the questions")
    num_questions: int = Field(5, description="Number of questions to generate", ge=1, le=75)
    custom_instructions: Optional[str] = Field(None, description="Optional custom instructions for question generation")
    debug_mode: bool = Field(False, description="Enable verbose debug output")

class SeedQuestionRequest(BaseModel):
    """Request schema for storing seed questions."""
    seed_questions: Dict[str, str] = Field(..., description="Dictionary of question-answer pairs")

class SeedQuestionTextRequest(BaseModel):
    """Request schema for processing text to extract seed questions."""
    text_content: str = Field(..., description="Text content containing questions and answers")

class QuestionResponse(BaseModel):
    """Response schema for a question."""
    id: str
    question: str
    answer: str
    pack_id: str
    pack_topics_item: Optional[str] = None
    difficulty_initial: Optional[DifficultyLevel] = None
    difficulty_current: Optional[DifficultyLevel] = None
    correct_answer_rate: float
    created_at: datetime

    class Config:
        from_attributes = True
        use_enum_values = True # Ensure enums serialize to values in response

class QuestionsResponse(BaseModel):
    """Response schema for a list of questions."""
    total: int
    questions: List[QuestionResponse]

class SeedQuestionsResponse(BaseModel):
    """Response schema for seed questions."""
    count: int
    seed_questions: Dict[str, str]

# Schemas for custom instructions
class CustomInstructionsGenerateRequest(BaseModel):
    """Request schema for generating custom instructions."""
    pack_topic: str = Field(..., description="Topic to base custom instructions on")

# --- REMOVED CustomInstructionsInputRequest ---
# class CustomInstructionsInputRequest(BaseModel):
#     """Request schema for manually inputting custom instructions."""
#     instructions: str = Field(..., description="Manually provided custom instructions")

class CustomInstructionsResponse(BaseModel):
    """Response schema for custom instructions."""
    custom_instructions: Optional[str] = Field(None, description="Custom instructions for question generation")
</file>

<file path="backend/src/api/schemas/topic.py">
# backend/src/api/schemas/topic.py
from typing import List, Optional
from pydantic import BaseModel, Field

class TopicGenerateRequest(BaseModel):
    """Request schema for generating topics."""
    num_topics: int = Field(5, description="Number of topics to generate", ge=1, le=20)
    # creation_name: Optional[str] = Field(None, description="Optional pack name to use for generation (defaults to pack's name)") # REMOVED
    predefined_topic: Optional[str] = Field(None, description="Optional predefined topic to use instead of generating")

class TopicAddRequest(BaseModel):
    """Request schema for adding additional topics."""
    num_additional_topics: int = Field(3, description="Number of additional topics to generate", ge=1, le=10)
    # creation_name: Optional[str] = Field(None, description="Optional pack name to use for generation (defaults to pack's name)") # REMOVED
    predefined_topic: Optional[str] = Field(None, description="Optional predefined topic to add directly")

class TopicResponse(BaseModel):
    """Response schema for topics."""
    topics: List[str] = Field(..., description="List of generated topics")
</file>

<file path="backend/src/api/schemas/user.py">
# backend/src/api/schemas/user.py
from typing import Optional
from pydantic import BaseModel, EmailStr, Field # Remove field_serializer import
from datetime import datetime # Import datetime

class UserCreateRequest(BaseModel):
    """Request schema for creating a new user."""
    displayname: Optional[str] = Field(None, description="Display name for the user")
    email: Optional[EmailStr] = Field(None, description="Email address")
    is_temporary: bool = Field(False, description="Whether this is a temporary user account")
    auth_provider: Optional[str] = Field(None, description="Authentication provider (e.g., 'google', 'facebook')")
    auth_id: Optional[str] = Field(None, description="Identifier from the authentication provider")

class UserResponse(BaseModel):
    """Response schema for user data."""
    id: str
    displayname: Optional[str] = None
    email: Optional[str] = None
    is_temporary: bool
    auth_provider: Optional[str] = None
    created_at: datetime # <<< CHANGE THIS LINE back to datetime

    # Remove the custom serializer
    # @field_serializer('created_at', when_used='json')
    # def serialize_dt(self, dt: datetime):
    #     ... (removed) ...

    class Config:
        from_attributes = True # Use from_attributes for Pydantic v2

class UserUpdateRequest(BaseModel):
    """Request schema for updating an existing user."""
    displayname: Optional[str] = Field(None, description="New display name")
    email: Optional[EmailStr] = Field(None, description="New email address")
    is_temporary: Optional[bool] = Field(None, description="New temporary status")
    auth_provider: Optional[str] = Field(None, description="New authentication provider")
    auth_id: Optional[str] = Field(None, description="New authentication ID")

class UserLoginRequest(BaseModel):
    """Request schema for user login by email."""
    email: EmailStr = Field(..., description="Email address for login")
    password: str = Field(..., description="Password for login")

class UserAuthRequest(BaseModel):
    """Request schema for third-party authentication."""
    auth_provider: str = Field(..., description="Authentication provider (e.g., 'google', 'facebook')")
    auth_id: str = Field(..., description="Identifier from the authentication provider")
    email: Optional[EmailStr] = Field(None, description="Email address from the authentication provider")
    displayname: Optional[str] = Field(None, description="Display name from the authentication provider")

class UserConvertRequest(BaseModel):
    """Request schema for converting a temporary user to a permanent one."""
    displayname: str = Field(..., description="Display name for the user")
    email: Optional[EmailStr] = Field(None, description="Email address")
    auth_provider: Optional[str] = Field(None, description="Authentication provider")
    auth_id: Optional[str] = Field(None, description="Authentication ID")
</file>

<file path="backend/src/api/__init__.py">
# backend/src/api/__init__.py
"""
API module for Trivia application.

This package contains the API routes, schemas, and dependencies
for the Trivia application.
"""

__all__ = []
</file>

<file path="backend/src/api/dependencies.py">
# backend/src/api/dependencies.py
from fastapi import Depends, Request
from supabase import AsyncClient

# --- WebSocket Manager Import ---
from ..websocket_manager import ConnectionManager # <<< ADDED
# --- End WebSocket Manager Import ---


# Ensure repositories are imported FIRST
from ..repositories.pack_repository import PackRepository
from ..repositories.question_repository import QuestionRepository
from ..repositories.incorrect_answers_repository import IncorrectAnswersRepository
from ..repositories.game_session_repository import GameSessionRepository
from ..repositories.game_participant_repository import GameParticipantRepository
from ..repositories.game_question_repository import GameQuestionRepository
from ..repositories.user_repository import UserRepository
from ..repositories.topic_repository import TopicRepository
from ..repositories.user_question_history_repository import UserQuestionHistoryRepository
from ..repositories.user_pack_history_repository import UserPackHistoryRepository


# Services
from ..services.pack_service import PackService
from ..services.topic_service import TopicService
from ..services.difficulty_service import DifficultyService
from ..services.question_service import QuestionService
from ..services.seed_question_service import SeedQuestionService
from ..services.incorrect_answer_service import IncorrectAnswerService
from ..services.game_service import GameService
from ..services.user_service import UserService


async def get_supabase_client(request: Request) -> AsyncClient:
    """Get Supabase client from request state."""
    # Ensure the client exists in state (initialized during lifespan)
    if not hasattr(request.app.state, 'supabase') or not request.app.state.supabase:
        raise RuntimeError("Supabase client not initialized or found in app state.")
    return request.app.state.supabase

# --- ADD Dependency for ConnectionManager ---
async def get_connection_manager(request: Request) -> ConnectionManager:
    """Get the shared ConnectionManager instance from request state."""
    if not hasattr(request.app.state, 'connection_manager') or not request.app.state.connection_manager:
        # This should theoretically not happen if lifespan runs correctly
        raise RuntimeError("ConnectionManager not initialized or found in app state.")
    return request.app.state.connection_manager
# --- END ADD ---

# --- Repository dependencies (Unchanged) ---
async def get_pack_repository(
    supabase: AsyncClient = Depends(get_supabase_client)
) -> PackRepository:
    return PackRepository(supabase)

async def get_question_repository(
    supabase: AsyncClient = Depends(get_supabase_client)
) -> QuestionRepository:
    return QuestionRepository(supabase)

async def get_incorrect_answers_repository(
    supabase: AsyncClient = Depends(get_supabase_client)
) -> IncorrectAnswersRepository:
    return IncorrectAnswersRepository(supabase)

async def get_game_session_repository(
    supabase: AsyncClient = Depends(get_supabase_client)
) -> GameSessionRepository:
    return GameSessionRepository(supabase)

async def get_game_participant_repository(
    supabase: AsyncClient = Depends(get_supabase_client)
) -> GameParticipantRepository:
    return GameParticipantRepository(supabase)

async def get_game_question_repository(
    supabase: AsyncClient = Depends(get_supabase_client)
) -> GameQuestionRepository:
    return GameQuestionRepository(supabase)

async def get_user_repository(
    supabase: AsyncClient = Depends(get_supabase_client)
) -> UserRepository:
    return UserRepository(supabase)

async def get_topic_repository(
    supabase: AsyncClient = Depends(get_supabase_client)
) -> TopicRepository:
    return TopicRepository(supabase)

async def get_user_question_history_repository(
    supabase: AsyncClient = Depends(get_supabase_client)
) -> UserQuestionHistoryRepository:
    return UserQuestionHistoryRepository(supabase)

async def get_user_pack_history_repository(
    supabase: AsyncClient = Depends(get_supabase_client)
) -> UserPackHistoryRepository:
    return UserPackHistoryRepository(supabase)


# --- Service dependencies (Modified to inject ConnectionManager) ---

# Pack, Topic, Difficulty, Seed, Question, IncorrectAnswer services remain unchanged
# as they don't directly interact with WebSockets in this design.

async def get_pack_service(
    pack_repository: PackRepository = Depends(get_pack_repository)
) -> PackService:
    return PackService(pack_repository=pack_repository)

async def get_topic_service(
    topic_repository: TopicRepository = Depends(get_topic_repository)
) -> TopicService:
    return TopicService(topic_repository=topic_repository)

async def get_difficulty_service(
    topic_service: TopicService = Depends(get_topic_service),
    pack_repository: PackRepository = Depends(get_pack_repository)
) -> DifficultyService:
    return DifficultyService(
        topic_service=topic_service,
        pack_repository=pack_repository
    )

async def get_seed_question_service(
    pack_repository: PackRepository = Depends(get_pack_repository),
    topic_repository: TopicRepository = Depends(get_topic_repository)
) -> SeedQuestionService:
    return SeedQuestionService(
        pack_repository=pack_repository,
        topic_repository=topic_repository
        )

async def get_question_service(
    question_repository: QuestionRepository = Depends(get_question_repository),
    pack_repository: PackRepository = Depends(get_pack_repository),
    topic_repository: TopicRepository = Depends(get_topic_repository),
    seed_question_service: SeedQuestionService = Depends(get_seed_question_service)
) -> QuestionService:
    return QuestionService(
        question_repository=question_repository,
        topic_repository=topic_repository,
        pack_repository=pack_repository,
        seed_question_service=seed_question_service
    )

async def get_incorrect_answer_service(
    question_repository: QuestionRepository = Depends(get_question_repository),
    incorrect_answers_repository: IncorrectAnswersRepository = Depends(get_incorrect_answers_repository)
) -> IncorrectAnswerService:
    return IncorrectAnswerService(
        question_repository=question_repository,
        incorrect_answers_repository=incorrect_answers_repository
    )

# --- MODIFIED get_user_service ---
async def get_user_service(
    user_repository: UserRepository = Depends(get_user_repository),
    game_participant_repository: GameParticipantRepository = Depends(get_game_participant_repository),
    game_session_repository: GameSessionRepository = Depends(get_game_session_repository),
    connection_manager: ConnectionManager = Depends(get_connection_manager) # <<< ADDED
) -> UserService:
    return UserService(
        user_repository=user_repository,
        game_participant_repository=game_participant_repository,
        game_session_repository=game_session_repository,
        connection_manager=connection_manager # <<< ADDED
    )
# --- END MODIFIED get_user_service ---

# --- MODIFIED get_game_service ---
async def get_game_service(
    game_session_repository: GameSessionRepository = Depends(get_game_session_repository),
    game_participant_repository: GameParticipantRepository = Depends(get_game_participant_repository),
    game_question_repository: GameQuestionRepository = Depends(get_game_question_repository),
    question_repository: QuestionRepository = Depends(get_question_repository),
    incorrect_answers_repository: IncorrectAnswersRepository = Depends(get_incorrect_answers_repository),
    user_repository: UserRepository = Depends(get_user_repository),
    user_question_history_repository: UserQuestionHistoryRepository = Depends(get_user_question_history_repository),
    user_pack_history_repository: UserPackHistoryRepository = Depends(get_user_pack_history_repository),
    connection_manager: ConnectionManager = Depends(get_connection_manager) # <<< ADDED
) -> GameService:
    """Get GameService instance."""
    return GameService(
        game_session_repository=game_session_repository,
        game_participant_repository=game_participant_repository,
        game_question_repository=game_question_repository,
        question_repository=question_repository,
        incorrect_answers_repository=incorrect_answers_repository,
        user_repository=user_repository,
        user_question_history_repository=user_question_history_repository,
        user_pack_history_repository=user_pack_history_repository,
        connection_manager=connection_manager # <<< ADDED
    )
# --- END MODIFIED get_game_service ---
</file>

<file path="backend/src/config/config.py">
import os
from dotenv import load_dotenv
from anthropic import Anthropic
from openai import OpenAI
import google.generativeai as genai

class LLMConfig:
    """
    Configuration for LLM clients (OpenAI, Anthropic, Gemini).
    """

    def __init__(self, provider=None, model=None):
        load_dotenv()
        self.provider = (provider or os.getenv("LLM_PROVIDER", "openai")).lower()
        self.openai_api_key = os.getenv("OPENAI_API_KEY")
        self.anthropic_api_key = os.getenv("ANTHROPIC_API_KEY")
        self.gemini_api_key = os.getenv("GEMINI_API_KEY")
        self._initialize_client(model)

    def _initialize_client(self, model=None):
        if self.provider == "openai":
            if not self.openai_api_key:
                raise ValueError("OPENAI_API_KEY not found.")
            self.client = OpenAI(api_key=self.openai_api_key)
            self.model = model or "gpt-4o"
        elif self.provider == "anthropic":
            if not self.anthropic_api_key:
                raise ValueError("ANTHROPIC_API_KEY not found.")
            self.client = Anthropic(api_key=self.anthropic_api_key)
            self.model = model or "claude-3-7-sonnet-20250219"
        elif self.provider == "gemini":
            if not self.gemini_api_key:
                raise ValueError("GEMINI_API_KEY not found.")
            genai.configure(api_key=self.gemini_api_key)
            self.client = genai
            self.model = model or "gemini-1.5-pro-latest"
        else:
            raise ValueError(f"Invalid LLM provider: {self.provider}")

    def get_client(self):
        return self.client

    def get_model(self):
        return self.model

    def get_provider(self):
        return self.provider

    def get_api_key(self):
        if self.provider == "openai":
            return self.openai_api_key
        elif self.provider == "anthropic":
            return self.anthropic_api_key
        elif self.provider == "gemini":
            return self.gemini_api_key
        else:
            return None

    @staticmethod
    def create(provider=None, model=None):
        return LLMConfig(provider, model)


class SupabaseConfig:
    """
    Configuration for Supabase.
    """
    def __init__(self):
        load_dotenv()
        self.supabase_url = os.getenv("SUPABASE_URL")
        self.supabase_key = os.getenv("SUPABASE_KEY")
        self.supabase_jwt_secret = os.getenv("SUPABASE_JWT_SECRET")

        if not self.supabase_url or not self.supabase_key or not self.supabase_jwt_secret:
             print("Warning: Some Supabase configuration values are missing from environment variables.") # Don't raise an error, as supabase may not always be needed

    def get_supabase_url(self):
        return self.supabase_url

    def get_supabase_key(self):
        return self.supabase_key

    def get_supabase_jwt_secret(self):
        return self.supabase_jwt_secret


# Example Usage
if __name__ == "__main__":
    # LLM Configurations
    default_config = LLMConfig()
    print(f"Default Provider: {default_config.get_provider()}")
    print(f"Default Model: {default_config.get_model()}")

    anthropic_config = LLMConfig(provider="anthropic", model="claude-3-opus-20240229")
    print(f"Anthropic Provider: {anthropic_config.get_provider()}")
    print(f"Anthropic Model: {anthropic_config.get_model()}")

    gemini_config = LLMConfig(provider="gemini", model="gemini-1.5-pro-latest")
    print(f"Gemini Provider: {gemini_config.get_provider()}")
    print(f"Gemini Model: {gemini_config.get_model()}")

    openai_config = LLMConfig.create(provider="openai", model="gpt-4o")
    print(f"OpenAI factory Provider: {openai_config.get_provider()}")
    print(f"OpenAI factory Model: {openai_config.get_model()}")


    # Supabase Configuration
    supabase_config = SupabaseConfig()
    print(f"Supabase URL: {supabase_config.get_supabase_url()}")  # These might print None if not set
    print(f"Supabase Key: {supabase_config.get_supabase_key()}")
    #print(f"Supabase JWT Secret: {supabase_config.get_supabase_jwt_secret()}") # Avoid printing secrets directly.
</file>

<file path="backend/src/config/supabase_client.py">
# backend/src/config/supabase_client.py
import logging
import traceback
from supabase import AsyncClient, acreate_client
from .config import SupabaseConfig

# Configure logger
logger = logging.getLogger(__name__)

async def init_supabase_client() -> AsyncClient:
    """
    Initialize an async Supabase client.
    
    Returns:
        An initialized asynchronous Supabase client
    """
    try:
        config = SupabaseConfig()
        logger.info(f"Initializing Supabase client with URL: {config.get_supabase_url()}")
        
        if not config.get_supabase_url() or not config.get_supabase_key():
            logger.error("Missing Supabase credentials in environment variables")
            raise ValueError("Supabase URL and key must be provided in environment variables")
        
        # Create the async Supabase client
        supabase = await acreate_client(
            config.get_supabase_url(),
            config.get_supabase_key()
        )
        
        logger.info("Supabase client initialized successfully")
        return supabase
    except Exception as e:
        logger.error(f"Error initializing Supabase client: {str(e)}")
        logger.error(traceback.format_exc())
        raise

async def close_supabase_client(client: AsyncClient):
    """
    Close the async Supabase client when done.
    
    Args:
        client: The AsyncClient to close
    """
    try:
        if client and hasattr(client, 'session') and client.session:
            logger.info("Closing Supabase client session")
            await client.session.aclose()
            logger.info("Supabase client session closed")
    except Exception as e:
        logger.error(f"Error closing Supabase client: {str(e)}")
        logger.error(traceback.format_exc())
</file>

<file path="backend/src/models/__init__.py">
# Update to backend/src/models/__init__.py
"""
Models module containing all data models for the Trivia application.

This package contains all Pydantic models used for data validation,
serialization, and representing database entities.
"""

from .base_schema import BaseCreateSchema, BaseUpdateSchema
from .question import Question, DifficultyLevel, QuestionCreate, QuestionUpdate
from .incorrect_answers import IncorrectAnswers, IncorrectAnswersCreate, IncorrectAnswersUpdate
from .pack_group import PackGroup, PackGroupCreate, PackGroupUpdate
from .pack import Pack, CreatorType, PackCreate, PackUpdate
from .user import User, UserCreate, UserUpdate
from .user_question_history import UserQuestionHistory, UserQuestionHistoryCreate, UserQuestionHistoryUpdate
from .user_pack_history import UserPackHistory, UserPackHistoryCreate, UserPackHistoryUpdate
# REMOVED: PackCreationData import
from .game_session import GameSession, GameSessionCreate, GameSessionUpdate, GameStatus
from .game_participant import GameParticipant, GameParticipantCreate, GameParticipantUpdate
from .game_question import GameQuestion, GameQuestionCreate, GameQuestionUpdate
from .topic import Topic, TopicCreate, TopicUpdate

__all__ = [
    # Base schemas
    'BaseCreateSchema',
    'BaseUpdateSchema',

    # Question models
    'Question',
    'DifficultyLevel',
    'QuestionCreate',
    'QuestionUpdate',

    # Incorrect answers models
    'IncorrectAnswers',
    'IncorrectAnswersCreate',
    'IncorrectAnswersUpdate',

    # Pack group models
    'PackGroup',
    'PackGroupCreate',
    'PackGroupUpdate',

    # Pack models
    'Pack',
    'CreatorType',
    'PackCreate',
    'PackUpdate',

    # User models
    'User',
    'UserCreate',
    'UserUpdate',

    # User question history models
    'UserQuestionHistory',
    'UserQuestionHistoryCreate',
    'UserQuestionHistoryUpdate',

    # User pack history models
    'UserPackHistory',
    'UserPackHistoryCreate',
    'UserPackHistoryUpdate',

    # REMOVED: Pack creation data models exports

    # Game session models
    'GameSession',
    'GameSessionCreate',
    'GameSessionUpdate',
    'GameStatus',

    # Game participant models
    'GameParticipant',
    'GameParticipantCreate',
    'GameParticipantUpdate',

    # Game question models
    'GameQuestion',
    'GameQuestionCreate',
    'GameQuestionUpdate',

    # Topic models
    'Topic',
    'TopicCreate',
    'TopicUpdate',
]
</file>

<file path="backend/src/models/base_schema.py">
# backend/src/models/base_schema.py
from pydantic import BaseModel
from typing import TypeVar, Generic, Type

# Change the bound from uuid.UUID to str
ModelType = TypeVar('ModelType', bound=BaseModel)

class BaseCreateSchema(BaseModel):
    """Base schema for creating new models."""
    class Config:
        from_attributes = True  # Was orm_mode = True in V1

class BaseUpdateSchema(BaseModel):
    """Base schema for updating existing models."""
    class Config:
        from_attributes = True  # Was orm_mode = True in V1
        # Allow partial updates
        validate_assignment = True
        extra = "ignore"
</file>

<file path="backend/src/models/game_participant.py">
# backend/src/models/game_participant.py
import uuid
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field

from .base_schema import BaseCreateSchema, BaseUpdateSchema

class GameParticipant(BaseModel):
    """
    Model representing a participant in a game session.
    
    Attributes:
        id: Unique identifier for this participant entry
        game_session_id: ID of the game session
        user_id: ID of the user participating
        display_name: Display name for this participant
        score: Current score in the game
        is_host: Whether this participant is the host of the game
        joined_at: When the participant joined the game
        last_activity: Last activity timestamp
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    game_session_id: str
    user_id: str
    display_name: str
    score: int = 0
    is_host: bool = False
    joined_at: datetime = Field(default_factory=datetime.utcnow)
    last_activity: datetime = Field(default_factory=datetime.utcnow)
    
    class Config:
        from_attributes = True

class GameParticipantCreate(BaseCreateSchema):
    """Schema for creating a new game participant."""
    game_session_id: str
    user_id: str
    display_name: str
    is_host: Optional[bool] = False

class GameParticipantUpdate(BaseUpdateSchema):
    """Schema for updating an existing game participant."""
    score: Optional[int] = None
    last_activity: Optional[datetime] = Field(default_factory=datetime.utcnow)
</file>

<file path="backend/src/models/game_question.py">
# backend/src/models/game_question.py
import uuid
from datetime import datetime
from typing import Optional, Dict, List
from pydantic import BaseModel, Field

from .base_schema import BaseCreateSchema, BaseUpdateSchema

class GameQuestion(BaseModel):
    """
    Model representing a question in a game session.
    
    Attributes:
        id: Unique identifier for this game question
        game_session_id: ID of the game session
        question_id: ID of the original question
        question_index: Position of this question in the game sequence
        start_time: When this question was started
        end_time: When this question was completed
        participant_answers: Dictionary mapping participant IDs to their answer choices
        participant_scores: Dictionary mapping participant IDs to their scores for this question
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    game_session_id: str
    question_id: str
    question_index: int
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    participant_answers: Dict[str, str] = Field(default_factory=dict)
    participant_scores: Dict[str, int] = Field(default_factory=dict)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    class Config:
        from_attributes = True

class GameQuestionCreate(BaseCreateSchema):
    """Schema for creating a new game question."""
    game_session_id: str
    question_id: str
    question_index: int

class GameQuestionUpdate(BaseUpdateSchema):
    """Schema for updating an existing game question."""
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    participant_answers: Optional[Dict[str, str]] = None
    participant_scores: Optional[Dict[str, int]] = None
</file>

<file path="backend/src/models/game_session.py">
# backend/src/models/game_session.py
import uuid
from datetime import datetime
from enum import Enum
from typing import Optional, List
from pydantic import BaseModel, Field

from .base_schema import BaseCreateSchema, BaseUpdateSchema

class GameStatus(str, Enum):
    """Enum for the status of a game session"""
    PENDING = "pending"    # Game created but not started
    ACTIVE = "active"      # Game in progress
    COMPLETED = "completed"  # Game finished
    CANCELLED = "cancelled"  # Game cancelled

class GameSession(BaseModel):
    """
    Model representing a game session.
    
    Attributes:
        id: Unique identifier for the game session
        code: Unique code for joining the game
        host_user_id: ID of the user who created this game session
        pack_id: ID of the pack being used for this game
        status: Current status of the game
        max_participants: Maximum number of participants allowed
        question_count: Number of questions in the game
        time_limit_seconds: Time limit for answering each question (0 means no limit)
        current_question_index: Index of the current question being played
        created_at: When this game session was created
        updated_at: When this game session was last updated
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    code: str
    host_user_id: str
    pack_id: str
    status: GameStatus = GameStatus.PENDING
    max_participants: int = 10
    question_count: int = 10
    time_limit_seconds: int = 0
    current_question_index: int = 0
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    
    class Config:
        from_attributes = True

class GameSessionCreate(BaseCreateSchema):
    """Schema for creating a new game session."""
    code: str
    host_user_id: str
    pack_id: str
    max_participants: Optional[int] = 10
    question_count: Optional[int] = 10
    time_limit_seconds: Optional[int] = 0
    status: Optional[GameStatus] = GameStatus.PENDING

class GameSessionUpdate(BaseUpdateSchema):
    """Schema for updating an existing game session."""
    status: Optional[GameStatus] = None
    current_question_index: Optional[int] = None
    max_participants: Optional[int] = None
    updated_at: Optional[datetime] = Field(default_factory=datetime.utcnow)
</file>

<file path="backend/src/models/incorrect_answers.py">
# backend/src/models/incorrect_answers.py
import uuid
from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel, Field

from .base_schema import BaseCreateSchema, BaseUpdateSchema


class IncorrectAnswers(BaseModel):
    """
    Model representing incorrect answer options for a question.
    
    Attributes:
        id: Unique identifier for this set of incorrect answers
        incorrect_answers: List of incorrect answer options
        question_id: Reference to the question these answers belong to
        created_at: When this record was created
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    incorrect_answers: List[str]
    question_id: str
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    class Config:
        from_attributes = True  # Updated from orm_mode = True


class IncorrectAnswersCreate(BaseCreateSchema):
    """Schema for creating incorrect answers for a question."""
    incorrect_answers: List[str]
    question_id: str


class IncorrectAnswersUpdate(BaseUpdateSchema):
    """Schema for updating incorrect answers for a question."""
    incorrect_answers: Optional[List[str]] = None
</file>

<file path="backend/src/models/pack_group.py">
# backend/src/models/pack_group.py
import uuid
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field

from .base_schema import BaseCreateSchema, BaseUpdateSchema


class PackGroup(BaseModel):
    """
    Model representing a group of question packs.
    
    Attributes:
        id: Unique identifier for the pack group
        name: Name of the pack group
        created_at: When this pack group was created
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    class Config:
        from_attributes = True  # Updated from orm_mode = True


class PackGroupCreate(BaseCreateSchema):
    """Schema for creating a new pack group."""
    name: str


class PackGroupUpdate(BaseUpdateSchema):
    """Schema for updating an existing pack group."""
    name: Optional[str] = None
</file>

<file path="backend/src/models/pack.py">
# backend/src/models/pack.py
import uuid
from datetime import datetime
from enum import Enum
from typing import List, Optional, Dict, Any # Added Dict, Any
from pydantic import BaseModel, Field

from .base_schema import BaseCreateSchema, BaseUpdateSchema


class CreatorType(str, Enum):
    """Enum for types of pack creators"""
    SYSTEM = "system"
    USER = "user"


class Pack(BaseModel):
    """
    Model representing a pack of questions.

    Attributes:
        id: Unique identifier for the pack
        name: Name of the pack
        description: Optional description of the pack contents
        price: Price of the pack (could be 0 for free packs)
        pack_group_id: Optional list of PackGroup IDs this pack belongs to.
        creator_type: Whether this pack was created by the system or a user
        correct_answer_rate: Average rate of correct answers for this pack's questions
        created_at: When this pack was created
        seed_questions: Optional dictionary of seed questions and answers
        custom_difficulty_description: Optional dictionary of custom difficulty descriptions
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    description: Optional[str] = None
    price: float
    pack_group_id: Optional[List[str]] = None
    creator_type: CreatorType
    correct_answer_rate: Optional[float] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    # --- ADDED FIELDS ---
    seed_questions: Dict[str, str] = Field(default_factory=dict)
    custom_difficulty_description: Dict[str, Any] = Field(default_factory=dict)
    # --- END ADDED FIELDS ---

    class Config:
        from_attributes = True


class PackCreate(BaseCreateSchema):
    """Schema for creating a new pack."""
    name: str
    description: Optional[str] = None
    price: float
    pack_group_id: Optional[List[str]] = None
    creator_type: CreatorType
    correct_answer_rate: Optional[float] = None
    # --- ADDED FIELDS (Optional on create) ---
    seed_questions: Optional[Dict[str, str]] = None
    custom_difficulty_description: Optional[Dict[str, Any]] = None
    # --- END ADDED FIELDS ---


class PackUpdate(BaseUpdateSchema):
    """Schema for updating an existing pack."""
    name: Optional[str] = None
    description: Optional[str] = None
    price: Optional[float] = None
    pack_group_id: Optional[List[str]] = None
    creator_type: Optional[CreatorType] = None
    correct_answer_rate: Optional[float] = None
    # --- ADDED FIELDS (Optional on update) ---
    seed_questions: Optional[Dict[str, str]] = None
    custom_difficulty_description: Optional[Dict[str, Any]] = None
    # --- END ADDED FIELDS ---
</file>

<file path="backend/src/models/question.py">
# backend/src/models/question.py
import uuid
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any
from pydantic import BaseModel, Field, model_validator

from .base_schema import BaseCreateSchema, BaseUpdateSchema


class DifficultyLevel(str, Enum):
    """Enum for difficulty levels of questions"""
    EASY = "easy"
    MEDIUM = "medium"
    HARD = "hard"
    EXPERT = "expert"
    MIXED = "mixed"  # Added MIXED difficulty level


class Question(BaseModel):
    """
    Model representing a trivia question.
    
    Attributes:
        id: Unique identifier for the question
        question: The actual trivia question text
        answer: The correct answer to the question
        pack_id: Reference to the pack this question belongs to
        pack_topics_item: Topic or subject area of the question
        difficulty_initial: The original difficulty rating when created (now optional)
        difficulty_current: The current difficulty rating (optional)
        correct_answer_rate: Percentage of correct answers given by users
        created_at: When this question was created
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    question: str
    answer: str
    pack_id: str
    pack_topics_item: Optional[str] = None
    difficulty_initial: Optional[DifficultyLevel] = None
    difficulty_current: Optional[DifficultyLevel] = None
    correct_answer_rate: float = 0.0
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    # Updated from root_validator to model_validator for Pydantic v2
    @model_validator(mode='before')
    @classmethod
    def set_default_difficulty_current(cls, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Default difficulty_current to difficulty_initial if not provided,
        but only when difficulty_initial exists
        """
        if isinstance(data, dict):
            if 'difficulty_current' not in data or data['difficulty_current'] is None:
                if 'difficulty_initial' in data and data['difficulty_initial'] is not None:
                    data['difficulty_current'] = data['difficulty_initial']
        return data
    
    class Config:
        from_attributes = True  # Updated from orm_mode = True


class QuestionCreate(BaseCreateSchema):
    """Schema for creating a new question."""
    question: str
    answer: str
    pack_id: str
    pack_topics_item: Optional[str] = None
    difficulty_initial: Optional[DifficultyLevel] = None
    difficulty_current: Optional[DifficultyLevel] = None
    
    # Default values not required in creation schema
    correct_answer_rate: float = 0.0


class QuestionUpdate(BaseUpdateSchema):
    """Schema for updating an existing question."""
    question: Optional[str] = None
    answer: Optional[str] = None
    pack_topics_item: Optional[str] = None
    difficulty_initial: Optional[DifficultyLevel] = None
    difficulty_current: Optional[DifficultyLevel] = None
    correct_answer_rate: Optional[float] = None
</file>

<file path="backend/src/models/topic.py">
# backend/src/models/topic.py
import uuid
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field

from .base_schema import BaseCreateSchema, BaseUpdateSchema

class Topic(BaseModel):
    """
    Model representing a single topic within a pack.
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    pack_id: str # Foreign key to packs table
    name: str
    custom_instruction: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        from_attributes = True

class TopicCreate(BaseCreateSchema):
    """Schema for creating a new topic."""
    pack_id: str
    name: str
    custom_instruction: Optional[str] = None

class TopicUpdate(BaseUpdateSchema):
    """Schema for updating an existing topic."""
    name: Optional[str] = None # Usually you wouldn't change the name/pack_id
    custom_instruction: Optional[str] = None
</file>

<file path="backend/src/models/user_pack_history.py">
# backend/src/models/user_pack_history.py
import uuid
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field

from .base_schema import BaseCreateSchema, BaseUpdateSchema


class UserPackHistory(BaseModel):
    """
    Model representing a user's history with a specific pack.
    
    Attributes:
        id: Unique identifier for this history entry
        user_id: Reference to the user
        pack_id: Reference to the pack
        play_count: Number of times the user has played this pack
        last_played_at: When the user last played this pack
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    user_id: str
    pack_id: str
    play_count: int
    last_played_at: datetime = Field(default_factory=datetime.utcnow)
    
    class Config:
        from_attributes = True  # Updated from orm_mode = True


class UserPackHistoryCreate(BaseCreateSchema):
    """Schema for creating a new user pack history entry."""
    user_id: str
    pack_id: str
    play_count: int
    last_played_at: Optional[datetime] = None


class UserPackHistoryUpdate(BaseUpdateSchema):
    """Schema for updating an existing user pack history entry."""
    play_count: Optional[int] = None
    last_played_at: Optional[datetime] = None
</file>

<file path="backend/src/models/user_question_history.py">
# backend/src/models/user_question_history.py
import uuid
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field

from .base_schema import BaseCreateSchema, BaseUpdateSchema


class UserQuestionHistory(BaseModel):
    """
    Model representing a user's history with a specific question.
    
    Attributes:
        id: Unique identifier for this history entry
        user_id: Reference to the user
        question_id: Reference to the question
        correct: Whether the user answered correctly
        incorrect_answer_selected: Index of the incorrect answer selected (if any)
        created_at: When this record was created
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    user_id: str
    question_id: str
    correct: bool
    incorrect_answer_selected: Optional[int] = None  # None when answered correctly
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    class Config:
        from_attributes = True  # Updated from orm_mode = True


class UserQuestionHistoryCreate(BaseCreateSchema):
    """Schema for creating a new user question history entry."""
    user_id: str
    question_id: str
    correct: bool
    incorrect_answer_selected: Optional[int] = None


class UserQuestionHistoryUpdate(BaseUpdateSchema):
    """Schema for updating an existing user question history entry."""
    correct: Optional[bool] = None
    incorrect_answer_selected: Optional[int] = None
</file>

<file path="backend/src/models/user.py">
# backend/src/models/user.py
import uuid
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field, EmailStr

from .base_schema import BaseCreateSchema, BaseUpdateSchema


class User(BaseModel):
    """
    Model representing a user of the trivia application.
    
    Attributes:
        id: Unique identifier for the user
        displayname: Optional display name for the user
        email: Optional email address for the user
        is_temporary: Whether this is a temporary user account
        auth_provider: Optional authentication provider (e.g., 'google', 'facebook')
        auth_id: Optional identifier from the authentication provider
        created_at: When this user account was created
    """
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    displayname: Optional[str] = None
    email: Optional[EmailStr] = None
    is_temporary: bool
    auth_provider: Optional[str] = None
    auth_id: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    class Config:
        from_attributes = True  # Updated from orm_mode = True


class UserCreate(BaseCreateSchema):
    """Schema for creating a new user."""
    displayname: Optional[str] = None
    email: Optional[EmailStr] = None
    is_temporary: bool
    auth_provider: Optional[str] = None
    auth_id: Optional[str] = None


class UserUpdate(BaseUpdateSchema):
    """Schema for updating an existing user."""
    displayname: Optional[str] = None
    email: Optional[EmailStr] = None
    is_temporary: Optional[bool] = None
    auth_provider: Optional[str] = None
    auth_id: Optional[str] = None
</file>

<file path="backend/src/repositories/__init__.py">
# Update to backend/src/repositories/__init__.py
"""
Repositories module providing data access layer implementations.

Exports repository classes for interacting with the database via Supabase.
"""

from .base_repository import BaseRepository
from .user_repository import UserRepository
from .question_repository import QuestionRepository
from .incorrect_answers_repository import IncorrectAnswersRepository
from .pack_group_repository import PackGroupRepository
from .pack_repository import PackRepository
from .user_question_history_repository import UserQuestionHistoryRepository
from .user_pack_history_repository import UserPackHistoryRepository
# REMOVED: PackCreationDataRepository import
# Add new game repositories
from .game_session_repository import GameSessionRepository
from .game_participant_repository import GameParticipantRepository
from .game_question_repository import GameQuestionRepository
# Add new topic repository
from .topic_repository import TopicRepository

__all__ = [
    "BaseRepository", # Exporting the base abstract class for type hinting
    "UserRepository",
    "QuestionRepository",
    "IncorrectAnswersRepository",
    "PackGroupRepository",
    "PackRepository",
    "UserQuestionHistoryRepository",
    "UserPackHistoryRepository",
    # REMOVED: "PackCreationDataRepository",
    # Add new game repositories
    "GameSessionRepository",
    "GameParticipantRepository",
    "GameQuestionRepository",
    # Add new topic repository
    "TopicRepository",
]
</file>

<file path="backend/src/repositories/base_repository_impl.py">
# backend/src/repositories/base_repository_impl.py

import uuid
import logging
import traceback
from typing import List, Optional, Type, Dict, Any, Union, TypeVar
from pydantic import BaseModel
from supabase import AsyncClient
from postgrest import APIResponse
# --- Import datetime and timezone ---
from datetime import datetime, timezone

from .base_repository import BaseRepository, ModelType, CreateSchemaType, UpdateSchemaType, IdentifierType
from ..utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

class BaseRepositoryImpl(BaseRepository[ModelType, CreateSchemaType, UpdateSchemaType, IdentifierType]):
    """
    Generic implementation of the BaseRepository using Supabase.

    This class provides concrete implementations for the CRUD operations
    defined in BaseRepository, interacting with a Supabase table.
    """

    def __init__(self, *, model: Type[ModelType], db: AsyncClient, table_name: str):
        """
        Initialize the repository.

        Args:
            model: The Pydantic model type for this repository.
            db: An instance of the Supabase AsyncClient.
            table_name: The name of the Supabase table this repository manages.
        """
        self.model = model
        self.db = db
        self.table_name = table_name
        logger.info(f"Initialized repository for table: {table_name}")

    # --- MODIFIED: Serialize datetimes within this helper ---
    def _serialize_data_for_db(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Recursively serialize data for database storage, converting datetimes to ISO strings.

        Args:
            data: Dictionary containing data to serialize

        Returns:
            Serialized dictionary ready for database insertion/update
        """
        result = {}
        for key, value in data.items():
            if isinstance(value, datetime):
                # Ensure datetime is timezone-aware (use UTC if naive)
                # Supabase prefers timezone-aware timestamps ('timestamptz')
                if value.tzinfo is None:
                    value = value.replace(tzinfo=timezone.utc)
                # Convert to ISO 8601 string format
                result[key] = value.isoformat()
            elif isinstance(value, list):
                # Handle potential datetimes within lists
                result[key] = [
                    self._serialize_data_for_db(item) if isinstance(item, dict) else
                    (item.isoformat() if isinstance(item, datetime) else item)
                    for item in value
                ]
            elif isinstance(value, dict):
                result[key] = self._serialize_data_for_db(value) # Recurse for nested dicts
            # --- NEW: Handle Enums explicitly if needed (Pydantic v2 often handles this) ---
            # elif isinstance(value, Enum):
            #     result[key] = value.value
            # --- END NEW ---
            else:
                result[key] = value # Keep other types as is
        return result
    # --- END MODIFICATION ---

    async def _execute_query(self, query) -> APIResponse:
        """Helper to execute supabase query and handle potential errors."""
        try:
            logger.debug(f"Executing query on table {self.table_name}")
            response = await query.execute()
            # Basic check if Supabase returned data or an error structure
            if hasattr(response, 'error') and response.error:
                 logger.error(f"Supabase query failed: {response.error}")
                 raise ValueError(f"Supabase query failed: {response.error}")
            if not hasattr(response, 'data'):
                 # This case might happen for DELETE without returning data, allow it
                 if query.method == "DELETE":
                     logger.debug("DELETE query executed successfully, no data returned expectedly.")
                     # Create a dummy response object that mimics a successful no-data response
                     return APIResponse(data=[], count=None) # Return empty list for data
                 else:
                     logger.error(f"Supabase response format unexpected (no data attribute): {response}")
                     raise ValueError(f"Supabase response format unexpected: {response}")
            return response
        except Exception as e:
            logger.error(f"Error executing Supabase query on table {self.table_name}: {str(e)}")
            logger.error(traceback.format_exc())
            # Re-raise for proper error handling upstream
            raise

    async def get_by_id(self, id: IdentifierType) -> Optional[ModelType]:
        """Get a record by ID."""
        try:
            id_str = ensure_uuid(id)
            logger.debug(f"Getting record with ID: {id_str} from table {self.table_name}")

            query = self.db.table(self.table_name).select("*").eq("id", id_str).limit(1)
            response = await self._execute_query(query)

            if response.data:
                # Use model_validate for Pydantic V2
                return self.model.model_validate(response.data[0])
            logger.debug(f"No record found with ID: {id_str} in table {self.table_name}")
            return None
        except Exception as e:
            logger.error(f"Error getting record by ID {id} from table {self.table_name}: {str(e)}")
            raise

    async def get_all(self, *, skip: int = 0, limit: int = 100) -> List[ModelType]:
        """Get all records with pagination."""
        try:
            logger.debug(f"Getting records from table {self.table_name} (skip={skip}, limit={limit})")
            query = self.db.table(self.table_name).select("*").offset(skip).limit(limit)
            response = await self._execute_query(query)

             # Use model_validate for Pydantic V2
            return [self.model.model_validate(item) for item in response.data]
        except Exception as e:
            logger.error(f"Error getting all records from table {self.table_name}: {str(e)}")
            raise

    async def create(self, *, obj_in: CreateSchemaType) -> ModelType:
        """Create a new record from a creation schema."""
        try:
            # Convert model to dict using Pydantic v2's model_dump
            insert_data = obj_in.model_dump(exclude_unset=False, by_alias=False)
            logger.debug(f"Creating new record in table {self.table_name}")

            # ---> FIX: Serialize data (including datetimes) before sending <---
            insert_data = self._serialize_data_for_db(insert_data)

            # Step 1: Insert the data
            query = self.db.table(self.table_name).insert(insert_data) # Pass serialized data
            response = await self._execute_query(query)

            # Step 2: If successful and we have an id, fetch the newly created record
            if response.data and 'id' in response.data[0]:
                new_id = response.data[0]['id']
                logger.debug(f"Record created with ID: {new_id}, fetching complete record")
                # Use get_by_id which handles parsing correctly
                new_record = await self.get_by_id(new_id)
                if new_record:
                    return new_record

            # Fallback: If fetching failed or no ID returned, try parsing insert response
            if response.data:
                try:
                    logger.warning("Could not fetch created record by ID, parsing insert response.")
                    # Use model_validate for Pydantic V2
                    return self.model.model_validate(response.data[0])
                except Exception as e:
                    logger.error(f"Could not parse insert response data: {e}")
                    raise ValueError("Failed to create record and parse response.")

            logger.error("Failed to create record, no data returned from insert.")
            raise ValueError("Failed to create record, no data returned.")

        except Exception as e:
            logger.error(f"Error creating record in table {self.table_name}: {str(e)}")
            logger.error(traceback.format_exc())
            raise

    async def update(self, *, id: IdentifierType, obj_in: UpdateSchemaType) -> Optional[ModelType]:
        """Update a record with proper handling of optional fields."""
        try:
            id_str = ensure_uuid(id)
            logger.debug(f"Updating record with ID: {id_str} in table {self.table_name}")

            # Use Pydantic v2's model_dump for partial updates
            update_data = obj_in.model_dump(exclude_unset=True, exclude_none=True, by_alias=False)

            if not update_data:
                logger.debug(f"No fields to update for record {id_str}")
                return await self.get_by_id(id_str)

            # ---> FIX: Serialize data (including datetimes) before sending <---
            update_data = self._serialize_data_for_db(update_data)

            # Step 1: Update the record
            query = self.db.table(self.table_name).update(update_data).eq("id", id_str) # Pass serialized data
            await self._execute_query(query)

            # Step 2: Fetch the updated record
            logger.debug(f"Record updated, fetching updated record with ID: {id_str}")
            return await self.get_by_id(id_str)
        except Exception as e:
            logger.error(f"Error updating record with ID {id_str} in table {self.table_name}: {str(e)}") # Use id_str
            logger.error(traceback.format_exc())
            raise

    async def delete(self, *, id: IdentifierType) -> Optional[ModelType]:
        """Delete a record and return the deleted object if successful."""
        try:
            id_str = ensure_uuid(id)
            logger.debug(f"Deleting record with ID: {id_str} from table {self.table_name}")

            # Step 1: Get the object before deletion
            obj = await self.get_by_id(id_str)

            if not obj:
                logger.warning(f"Record with ID {id_str} not found for deletion")
                return None  # Object doesn't exist

            # Step 2: Delete the object
            query = self.db.table(self.table_name).delete().eq("id", id_str)
            await self._execute_query(query)

            # Step 3: Return the object that was deleted
            logger.debug(f"Successfully deleted record with ID: {id_str}")
            return obj
        except Exception as e:
            logger.error(f"Error deleting record with ID {id_str} in table {self.table_name}: {str(e)}") # Use id_str
            logger.error(traceback.format_exc())
            raise
</file>

<file path="backend/src/repositories/base_repository.py">
# backend/src/repositories/base_repository.py
from abc import ABC, abstractmethod
from typing import List, Optional, TypeVar, Generic, Type
from pydantic import BaseModel

# Define TypeVars for generic repository
ModelType = TypeVar('ModelType', bound=BaseModel)
CreateSchemaType = TypeVar('CreateSchemaType', bound=BaseModel)
UpdateSchemaType = TypeVar('UpdateSchemaType', bound=BaseModel)
# Change bound from uuid.UUID to str
IdentifierType = TypeVar('IdentifierType', bound=str)

class BaseRepository(Generic[ModelType, CreateSchemaType, UpdateSchemaType, IdentifierType], ABC):
    """
    Abstract base class for data repositories.

    Defines the standard interface for CRUD operations with separate
    schema types for creation and update operations.
    """

    @abstractmethod
    async def get_by_id(self, id: IdentifierType) -> Optional[ModelType]:
        """Retrieve a single item by its unique identifier."""
        pass

    @abstractmethod
    async def get_all(self, *, skip: int = 0, limit: int = 100) -> List[ModelType]:
        """Retrieve multiple items, with optional pagination."""
        pass

    @abstractmethod
    async def create(self, *, obj_in: CreateSchemaType) -> ModelType:
        """Create a new item using the creation schema."""
        pass

    @abstractmethod
    async def update(self, *, id: IdentifierType, obj_in: UpdateSchemaType) -> Optional[ModelType]:
        """Update an existing item by its unique identifier using the update schema."""
        pass

    @abstractmethod
    async def delete(self, *, id: IdentifierType) -> Optional[ModelType]:
        """Delete an item by its unique identifier and return the deleted item if successful."""
        pass
</file>

<file path="backend/src/repositories/game_participant_repository.py">
# backend/src/repositories/game_participant_repository.py
import uuid
import logging # Import logging
from typing import List, Optional
from supabase import AsyncClient
from datetime import datetime, timezone # Import datetime, timezone

from ..models.game_participant import GameParticipant, GameParticipantCreate, GameParticipantUpdate
from .base_repository_impl import BaseRepositoryImpl
from ..utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

class GameParticipantRepository(BaseRepositoryImpl[GameParticipant, GameParticipantCreate, GameParticipantUpdate, str]):
    """
    Repository for managing GameParticipant data in Supabase.
    """
    def __init__(self, db: AsyncClient):
        super().__init__(model=GameParticipant, db=db, table_name="game_participants") # Table name: "game_participants"

    # --- Custom GameParticipant-specific methods ---

    # --- MODIFIED get_by_game_session_id ---
    async def get_by_game_session_id(self, game_session_id: str) -> List[GameParticipant]:
        """
        Retrieve all participants for a specific game session, including the
        latest display name from the users table.
        """
        game_session_id_str = ensure_uuid(game_session_id)
        try:
            # Use select() to fetch participant columns and the related user's displayname
            # Assumes a foreign key relationship 'user_id' in 'game_participants' referencing 'id' in 'users'
            # and that the relationship is set up in Supabase for this syntax to work easily.
            # If the relationship isn't explicitly defined in Supabase, a manual join/lookup might be needed.
            # This syntax fetches all columns from game_participants and the displayname from users.
            query = (
                self.db.table(self.table_name)
                .select("*, users(displayname)") # Fetch all participant fields and user's displayname
                .eq("game_session_id", game_session_id_str)
            )
            response = await self._execute_query(query)

            participants = []
            for item in response.data:
                # Extract the user's displayname if available
                user_data = item.get('users')
                latest_display_name = user_data.get('displayname') if isinstance(user_data, dict) else None

                # Create the GameParticipant object
                # We prioritize the latest_display_name from the users table
                # If it's missing (e.g., user deleted?), fall back to the stored participant name
                participant_data = item.copy()
                if 'users' in participant_data: # Remove the nested user data before validation
                    del participant_data['users']

                # Use the fetched user display name if available, otherwise keep the one stored in the participant record
                if latest_display_name is not None:
                    participant_data['display_name'] = latest_display_name
                elif 'display_name' not in participant_data: # Ensure display_name exists
                    participant_data['display_name'] = "Unknown Player" # Fallback

                try:
                     # Use model_validate for Pydantic V2
                     participant_obj = self.model.model_validate(participant_data)
                     participants.append(participant_obj)
                except Exception as validation_error:
                     logger.error(f"Validation error parsing participant data: {validation_error}. Data: {participant_data}", exc_info=True)
                     # Optionally skip this participant or create a default representation

            return participants

        except Exception as e:
            logger.error(f"Error retrieving participants for game session {game_session_id_str}: {e}", exc_info=True)
            raise # Re-raise the exception after logging

    # --- END MODIFIED get_by_game_session_id ---

    async def get_by_user_and_game(self, user_id: str, game_session_id: str) -> Optional[GameParticipant]:
        """Retrieve a participant by user ID and game session ID."""
        user_id_str = ensure_uuid(user_id)
        game_session_id_str = ensure_uuid(game_session_id)
        query = (
            self.db.table(self.table_name)
            .select("*") # No need to join here, as we usually need the participant record itself
            .eq("user_id", user_id_str)
            .eq("game_session_id", game_session_id_str)
            .limit(1)
        )
        response = await self._execute_query(query)
        if response.data:
            # Use model_validate for Pydantic V2
            return self.model.model_validate(response.data[0])
        return None

    async def update_score(self, participant_id: str, new_score: int) -> Optional[GameParticipant]:
        """Update a participant's score and last activity time."""
        participant_id_str = ensure_uuid(participant_id)

        # --- CORRECTED FIX: Use standard ISO format ---
        # Get the current time in UTC and format it as ISO 8601 string
        # The isoformat() method correctly includes the UTC offset (+00:00)
        now_iso = datetime.now(timezone.utc).isoformat() # REMOVED + "Z"
        update_data = {
            "score": new_score,
            "last_activity": now_iso # Use the ISO string directly
        }
        # --- END CORRECTED FIX ---

        query = self.db.table(self.table_name).update(update_data).eq("id", participant_id_str)
        await self._execute_query(query) # This should now work

        # Fetch and return the updated object using the correct ID
        return await self.get_by_id(participant_id_str) # Ensure correct ID type

    async def get_user_active_games(self, user_id: str) -> List[GameParticipant]:
        """Retrieve all game participations for a user."""
        # Note: This currently returns *all* participations. Filtering by active game
        # status would typically happen in the service layer by joining/checking game status.
        user_id_str = ensure_uuid(user_id)
        query = (
            self.db.table(self.table_name)
            .select("*") # Keep simple select here, join is not needed for this specific use case
            .eq("user_id", user_id_str)
        )
        response = await self._execute_query(query)
        # Use model_validate for Pydantic V2
        return [self.model.model_validate(item) for item in response.data]
</file>

<file path="backend/src/repositories/game_question_repository.py">
# backend/src/repositories/game_question_repository.py
import uuid
from typing import List, Optional, Dict
from datetime import datetime
from supabase import AsyncClient

from ..models.game_question import GameQuestion, GameQuestionCreate, GameQuestionUpdate
from .base_repository_impl import BaseRepositoryImpl
from ..utils import ensure_uuid

class GameQuestionRepository(BaseRepositoryImpl[GameQuestion, GameQuestionCreate, GameQuestionUpdate, str]):
    """
    Repository for managing GameQuestion data in Supabase.
    """
    def __init__(self, db: AsyncClient):
        super().__init__(model=GameQuestion, db=db, table_name="game_questions") # Table name: "game_questions"

    # --- Custom GameQuestion-specific methods ---

    async def get_by_game_session_id(self, game_session_id: str) -> List[GameQuestion]:
        """Retrieve all questions for a specific game session."""
        # Ensure game_session_id is a valid UUID string
        game_session_id_str = ensure_uuid(game_session_id)
        
        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("game_session_id", game_session_id_str)
            .order("question_index")
        )
        response = await self._execute_query(query)
        return [self.model.parse_obj(item) for item in response.data]

    async def get_by_game_session_and_index(self, game_session_id: str, question_index: int) -> Optional[GameQuestion]:
        """Retrieve a specific question by game session ID and question index."""
        # Ensure game_session_id is a valid UUID string
        game_session_id_str = ensure_uuid(game_session_id)
        
        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("game_session_id", game_session_id_str)
            .eq("question_index", question_index)
            .limit(1)
        )
        response = await self._execute_query(query)
        if response.data:
            return self.model.parse_obj(response.data[0])
        return None

    async def start_question(self, question_id: str) -> Optional[GameQuestion]:
        """Mark a question as started (set start_time)."""
        # Ensure question_id is a valid UUID string
        question_id_str = ensure_uuid(question_id)
        
        now = datetime.utcnow()
        update_data = {"start_time": now.isoformat()}
        
        query = self.db.table(self.table_name).update(update_data).eq("id", question_id_str)
        await self._execute_query(query)
        
        # Fetch and return the updated object
        return await self.get_by_id(question_id)

    async def end_question(self, question_id: str) -> Optional[GameQuestion]:
        """Mark a question as ended (set end_time)."""
        # Ensure question_id is a valid UUID string
        question_id_str = ensure_uuid(question_id)
        
        now = datetime.utcnow()
        update_data = {"end_time": now.isoformat()}
        
        query = self.db.table(self.table_name).update(update_data).eq("id", question_id_str)
        await self._execute_query(query)
        
        # Fetch and return the updated object
        return await self.get_by_id(question_id)

    async def record_participant_answer(
        self, 
        question_id: str, 
        participant_id: str, 
        answer: str
    ) -> Optional[GameQuestion]:
        """Record a participant's answer for a question."""
        # Ensure question_id is a valid UUID string
        question_id_str = ensure_uuid(question_id)
        
        # First, get the current question to access existing participant_answers
        current_question = await self.get_by_id(question_id_str)
        if not current_question:
            return None
            
        # Update the participant_answers dictionary
        participant_answers = dict(current_question.participant_answers)
        participant_answers[participant_id] = answer
        
        # Update in database
        update_data = {"participant_answers": participant_answers}
        query = self.db.table(self.table_name).update(update_data).eq("id", question_id_str)
        await self._execute_query(query)
        
        # Fetch and return the updated object
        return await self.get_by_id(question_id)

    async def record_participant_score(
        self, 
        question_id: str, 
        participant_id: str, 
        score: int
    ) -> Optional[GameQuestion]:
        """Record a participant's score for a question."""
        # Ensure question_id is a valid UUID string
        question_id_str = ensure_uuid(question_id)
        
        # First, get the current question to access existing participant_scores
        current_question = await self.get_by_id(question_id_str)
        if not current_question:
            return None
            
        # Update the participant_scores dictionary
        participant_scores = dict(current_question.participant_scores)
        participant_scores[participant_id] = score
        
        # Update in database
        update_data = {"participant_scores": participant_scores}
        query = self.db.table(self.table_name).update(update_data).eq("id", question_id_str)
        await self._execute_query(query)
        
        # Fetch and return the updated object
        return await self.get_by_id(question_id)
</file>

<file path="backend/src/repositories/game_session_repository.py">
# backend/src/repositories/game_session_repository.py
import uuid
from typing import List, Optional
from supabase import AsyncClient
from datetime import datetime, timezone # Import timezone

from ..models.game_session import GameSession, GameSessionCreate, GameSessionUpdate, GameStatus
from .base_repository_impl import BaseRepositoryImpl
from ..utils import ensure_uuid

class GameSessionRepository(BaseRepositoryImpl[GameSession, GameSessionCreate, GameSessionUpdate, str]):
    """
    Repository for managing GameSession data in Supabase.
    """
    def __init__(self, db: AsyncClient):
        super().__init__(model=GameSession, db=db, table_name="game_sessions") # Table name: "game_sessions"

    # --- Custom GameSession-specific methods ---

    async def get_by_code(self, code: str) -> Optional[GameSession]:
        """Retrieve a game session by its join code."""
        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("code", code)
            .limit(1)
        )
        response = await self._execute_query(query)
        if response.data:
            return self.model.model_validate(response.data[0]) # Use model_validate
        return None

    async def get_by_host_user_id(self, host_user_id: str, *, active_only: bool = False) -> List[GameSession]:
        """Retrieve game sessions created by a specific user."""
        host_user_id_str = ensure_uuid(host_user_id)
        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("host_user_id", host_user_id_str)
        )
        if active_only:
            query = query.in_("status", [GameStatus.ACTIVE.value, GameStatus.PENDING.value])
        response = await self._execute_query(query)
        return [self.model.model_validate(item) for item in response.data] # Use model_validate

    async def get_active_games(self) -> List[GameSession]:
        """Retrieve all active game sessions."""
        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("status", GameStatus.ACTIVE.value)
        )
        response = await self._execute_query(query)
        return [self.model.model_validate(item) for item in response.data] # Use model_validate

    async def update_game_status(self, game_id: str, status: GameStatus) -> Optional[GameSession]:
        """Update the status of a game session."""
        game_id_str = ensure_uuid(game_id)

        # --- CORRECTED FIX: Use standard ISO format ---
        # Use now() with timezone for consistency
        now_iso = datetime.now(timezone.utc).isoformat() # REMOVED + "Z"
        update_data = {
            "status": status.value,
            "updated_at": now_iso # Use the ISO string directly
        }
        # --- END CORRECTED FIX ---

        query = self.db.table(self.table_name).update(update_data).eq("id", game_id_str)
        await self._execute_query(query) # This should now work

        # Fetch and return the updated object
        return await self.get_by_id(game_id_str) # Use string ID
</file>

<file path="backend/src/repositories/incorrect_answers_repository.py">
# backend/src/repositories/incorrect_answers_repository.py
import uuid
from typing import Optional, List
from supabase import AsyncClient

from ..models.incorrect_answers import IncorrectAnswers, IncorrectAnswersCreate, IncorrectAnswersUpdate
from .base_repository_impl import BaseRepositoryImpl
from ..utils import ensure_uuid

class IncorrectAnswersRepository(BaseRepositoryImpl[IncorrectAnswers, IncorrectAnswersCreate, IncorrectAnswersUpdate, str]):
    """
    Repository for managing IncorrectAnswers data in Supabase.
    """
    def __init__(self, db: AsyncClient):
        super().__init__(model=IncorrectAnswers, db=db, table_name="incorrect_answers") # Table name: "incorrect_answers"

    # --- Custom IncorrectAnswers-specific methods ---

    async def get_by_question_id(self, question_id: str) -> Optional[IncorrectAnswers]:
        """Retrieve incorrect answers for a specific question."""
        # Ensure question_id is a valid UUID string
        question_id_str = ensure_uuid(question_id)
        
        # Assuming only one set of incorrect answers per question_id
        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("question_id", question_id_str)
            .limit(1) # Expecting only one entry per question
        )
        response = await self._execute_query(query)
        if response.data:
            return self.model.parse_obj(response.data[0])
        return None

    async def delete_by_question_id(self, question_id: str) -> List[IncorrectAnswers]:
        """Deletes incorrect answers associated with a specific question_id."""
        # Ensure question_id is a valid UUID string
        question_id_str = ensure_uuid(question_id)
        
        # First, retrieve the records to be deleted
        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("question_id", question_id_str)
        )
        response = await self._execute_query(query)
        records = [self.model.parse_obj(item) for item in response.data]
        
        # Then delete them
        delete_query = (
            self.db.table(self.table_name)
            .delete()
            .eq("question_id", question_id_str)
        )
        await self._execute_query(delete_query)
        
        return records
</file>

<file path="backend/src/repositories/pack_group_repository.py">
# backend/src/repositories/pack_group_repository.py
import uuid
from typing import Optional
from supabase import AsyncClient

from ..models.pack_group import PackGroup, PackGroupCreate, PackGroupUpdate
from .base_repository_impl import BaseRepositoryImpl
from ..utils import ensure_uuid

class PackGroupRepository(BaseRepositoryImpl[PackGroup, PackGroupCreate, PackGroupUpdate, str]):
    """
    Repository for managing PackGroup data in Supabase.
    """
    def __init__(self, db: AsyncClient):
        super().__init__(model=PackGroup, db=db, table_name="pack_groups") # Table name: "pack_groups"

    # --- Custom PackGroup-specific methods (if any) ---
    async def get_by_name(self, name: str) -> Optional[PackGroup]:
        """Retrieve a pack group by its name."""
        query = self.db.table(self.table_name).select("*").eq("name", name).limit(1)
        response = await self._execute_query(query)
        if response.data:
            return self.model.parse_obj(response.data[0])
        return None
</file>

<file path="backend/src/repositories/pack_repository.py">
# backend/src/repositories/pack_repository.py
import uuid
from typing import List, Optional, Dict, Any
from supabase import AsyncClient
import logging # Added logging

from ..models.pack import Pack, PackCreate, PackUpdate, CreatorType
from .base_repository_impl import BaseRepositoryImpl
from ..utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

class PackRepository(BaseRepositoryImpl[Pack, PackCreate, PackUpdate, str]):
    """
    Repository for managing Pack data in Supabase.
    Includes fields previously in PackCreationData.
    """
    def __init__(self, db: AsyncClient):
        super().__init__(model=Pack, db=db, table_name="packs")

    # Helper method to ensure enum values are properly serialized
    def _serialize_enum_values(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Convert any enums to their string values for storage."""
        result = data.copy()
        if 'creator_type' in result and isinstance(result['creator_type'], CreatorType):
            result['creator_type'] = result['creator_type'].value
        return result

    async def get_by_pack_group_id(self, pack_group_id: str, *, skip: int = 0, limit: int = 100) -> List[Pack]:
        """Retrieve packs associated with a specific PackGroup ID (checks list)."""
        pack_group_id_str = ensure_uuid(pack_group_id)

        query = (
            self.db.table(self.table_name)
            .select("*")
            .cs("pack_group_id", [pack_group_id_str]) # Use contains operator for array
            .offset(skip)
            .limit(limit)
            .order("created_at", desc=True)
        )
        response = await self._execute_query(query)
        # Use model_validate for Pydantic V2
        return [self.model.model_validate(item) for item in response.data]

    async def get_by_creator_type(self, creator_type: CreatorType, *, skip: int = 0, limit: int = 100) -> List[Pack]:
        """Retrieve packs by their creator type."""
        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("creator_type", creator_type.value)
            .offset(skip)
            .limit(limit)
            .order("created_at", desc=True)
        )
        response = await self._execute_query(query)
        # Use model_validate for Pydantic V2
        return [self.model.model_validate(item) for item in response.data]

    async def search_by_name(self, name_query: str, *, skip: int = 0, limit: int = 100) -> List[Pack]:
        """Search for packs by name (case-insensitive partial match)."""
        query = (
            self.db.table(self.table_name)
            .select("*")
            .ilike("name", f"%{name_query}%")
            .offset(skip)
            .limit(limit)
        )
        response = await self._execute_query(query)
        # Use model_validate for Pydantic V2
        return [self.model.model_validate(item) for item in response.data]

    async def update_correct_answer_rate(self, pack_id: str, rate: float) -> Optional[Pack]:
        """Updates the correct answer rate for a given pack."""
        pack_id_str = ensure_uuid(pack_id)
        update_data = {"correct_answer_rate": rate}
        query = self.db.table(self.table_name).update(update_data).eq("id", pack_id_str)
        await self._execute_query(query)
        return await self.get_by_id(pack_id_str) # Fetch updated record

    # Override base methods to handle enum serialization and new fields if needed
    async def create(self, *, obj_in: PackCreate) -> Pack:
        """Create a new pack with proper enum handling and new fields."""
        # Use exclude_none=True to avoid inserting None for optional fields
        # Ensure defaults from the model are used if not provided in obj_in
        insert_data = obj_in.model_dump(exclude_unset=False, exclude_none=True, by_alias=False)
        insert_data = self._serialize_enum_values(insert_data) # Handle enums
        insert_data = self._serialize_data_for_db(insert_data) # Handle potential nested JSON

        # Set default values if not present
        if 'seed_questions' not in insert_data:
            insert_data['seed_questions'] = {}
        if 'custom_difficulty_description' not in insert_data:
            insert_data['custom_difficulty_description'] = {}

        # --- MODIFIED LINE: Reinstate await ---
        query_result = await self.db.table(self.table_name).insert(insert_data).execute()
        # --- END MODIFIED LINE ---

        # Fetch the newly created record to get all fields including defaults
        # --- MODIFIED LINE: Use query_result instead of query ---
        if query_result.data:
             # --- MODIFIED LINE: Use query_result instead of query ---
             new_id = query_result.data[0].get('id')
             if new_id:
                 # Fetch the complete record
                 logger.debug(f"Fetching newly created pack with ID: {new_id}")
                 new_pack = await self.get_by_id(new_id)
                 if new_pack:
                      return new_pack
                 else:
                      logger.warning(f"Failed to fetch pack {new_id} after creation, attempting to parse insert response.")
             # Fallback: parse insert response (might miss DB defaults)
             try:
                  # --- MODIFIED LINE: Use query_result instead of query ---
                  return self.model.model_validate(query_result.data[0])
             except Exception as e:
                  logger.error(f"Failed to parse insert response: {e}")
                  raise ValueError("Failed to create pack, could not retrieve or parse result.")

        else:
            # --- MODIFIED LINE: Use query_result instead of query ---
            logger.error(f"Failed to create pack, no data returned from insert operation. Error: {getattr(query_result, 'error', 'Unknown error')}")
            raise ValueError(f"Failed to create pack, no data returned. Error: {getattr(query_result, 'error', 'Unknown error')}")


    async def update(self, *, id: str, obj_in: PackUpdate) -> Optional[Pack]:
        """Update an existing pack with proper enum handling and new fields."""
        id_str = ensure_uuid(id)
        # Use exclude_unset=True for partial updates
        update_data = obj_in.model_dump(exclude_unset=True, exclude_none=True, by_alias=False)

        if not update_data:
            return await self.get_by_id(id_str) # Return current if no update data

        update_data = self._serialize_enum_values(update_data) # Handle enums
        update_data = self._serialize_data_for_db(update_data) # Handle potential nested JSON

        query = self.db.table(self.table_name).update(update_data).eq("id", id_str)
        await self._execute_query(query) # Base implementation handles await correctly

        return await self.get_by_id(id_str) # Fetch and return updated record
</file>

<file path="backend/src/repositories/question_repository.py">
# backend/src/repositories/question_repository.py
import uuid
from typing import List, Optional, Dict, Any
from supabase import AsyncClient

from ..models.question import Question, QuestionCreate, QuestionUpdate, DifficultyLevel
from .base_repository_impl import BaseRepositoryImpl
from ..utils import ensure_uuid


class QuestionRepository(BaseRepositoryImpl[Question, QuestionCreate, QuestionUpdate, str]):
    """
    Repository for managing Question data in Supabase.
    """
    def __init__(self, db: AsyncClient):
        super().__init__(model=Question, db=db, table_name="questions") # Table name: "questions"

    # Helper method to ensure enum values are properly serialized
    def _serialize_enum_values(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Convert any enums to their string values for storage."""
        result = data.copy()
        if 'difficulty_initial' in result and isinstance(result['difficulty_initial'], DifficultyLevel):
            result['difficulty_initial'] = result['difficulty_initial'].value
        if 'difficulty_current' in result and isinstance(result['difficulty_current'], DifficultyLevel):
            result['difficulty_current'] = result['difficulty_current'].value
        return result

    # --- Custom Question-specific methods ---

    async def get_by_pack_id(self, pack_id: str, *, skip: int = 0, limit: int = 100) -> List[Question]:
        """Retrieve questions belonging to a specific pack."""
        # Ensure pack_id is a valid UUID string
        pack_id_str = ensure_uuid(pack_id)
        
        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("pack_id", pack_id_str)
            .offset(skip)
            .limit(limit)
        )
        response = await self._execute_query(query)
        return [self.model.parse_obj(item) for item in response.data]

    async def get_by_difficulty(self, difficulty: DifficultyLevel, *, skip: int = 0, limit: int = 100) -> List[Question]:
        """Retrieve questions by their current difficulty level."""
        # Convert enum to string value for the query
        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("difficulty_current", difficulty.value)
            .offset(skip)
            .limit(limit)
        )
        response = await self._execute_query(query)
        return [self.model.parse_obj(item) for item in response.data]

    async def update_statistics(self, question_id: str, correct_rate: float, new_difficulty: Optional[DifficultyLevel] = None) -> Optional[Question]:
        """Updates the statistics for a given question."""
        # Ensure question_id is a valid UUID string
        question_id_str = ensure_uuid(question_id)
        
        update_data = {"correct_answer_rate": correct_rate}
        if new_difficulty:
            update_data["difficulty_current"] = new_difficulty.value

        query = self.db.table(self.table_name).update(update_data).eq("id", question_id_str)
        await self._execute_query(query)
        
        # Fetch and return the updated object
        return await self.get_by_id(question_id)

    # Override base methods to handle enum serialization
    async def create(self, *, obj_in: QuestionCreate) -> Question:
        """Create a new question with proper enum handling."""
        insert_data = obj_in.dict(exclude_unset=False, exclude_none=True, by_alias=False)
        insert_data = self._serialize_enum_values(insert_data)
        
        query = self.db.table(self.table_name).insert(insert_data)
        response = await self._execute_query(query)

        if response.data:
            # Get the ID of the newly created record
            new_id = response.data[0].get('id')
            if new_id:
                # Fetch the complete record
                return await self.get_by_id(new_id)
            return self.model.parse_obj(response.data[0])
        else:
            raise ValueError("Failed to create question, no data returned.")

    async def update(self, *, id: str, obj_in: QuestionUpdate) -> Optional[Question]:
        """Update an existing question with proper enum handling."""
        # Ensure id is a valid UUID string
        id_str = ensure_uuid(id)
        
        update_data = obj_in.dict(exclude_unset=True, exclude_none=True, by_alias=False)
        
        if not update_data:
            return await self.get_by_id(id)
            
        update_data = self._serialize_enum_values(update_data)
        
        query = self.db.table(self.table_name).update(update_data).eq("id", id_str)
        await self._execute_query(query)

        # Fetch and return the updated object
        return await self.get_by_id(id)
</file>

<file path="backend/src/repositories/topic_repository.py">
# backend/src/repositories/topic_repository.py
import uuid
from typing import List, Optional
from supabase import AsyncClient

from ..models.topic import Topic, TopicCreate, TopicUpdate
from .base_repository_impl import BaseRepositoryImpl
from ..utils import ensure_uuid

class TopicRepository(BaseRepositoryImpl[Topic, TopicCreate, TopicUpdate, str]):
    def __init__(self, db: AsyncClient):
        super().__init__(model=Topic, db=db, table_name="topics")

    async def get_by_pack_id(self, pack_id: str) -> List[Topic]:
        pack_id_str = ensure_uuid(pack_id)
        query = self.db.table(self.table_name).select("*").eq("pack_id", pack_id_str)
        response = await self._execute_query(query)
        return [self.model.model_validate(item) for item in response.data]

    async def get_by_name_and_pack_id(self, name: str, pack_id: str) -> Optional[Topic]:
        pack_id_str = ensure_uuid(pack_id)
        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("pack_id", pack_id_str)
            .eq("name", name)
            .limit(1)
        )
        response = await self._execute_query(query)
        if response.data:
            return self.model.model_validate(response.data[0])
        return None

    async def update_custom_instruction(self, topic_id: str, instruction: Optional[str]) -> Optional[Topic]:
        topic_id_str = ensure_uuid(topic_id)
        update_data = TopicUpdate(custom_instruction=instruction)
        return await self.update(id=topic_id_str, obj_in=update_data)

    async def create_topic(self, topic_create: TopicCreate) -> Optional[Topic]:
        # Optionally check for duplicates before creating if UNIQUE constraint isn't enough
        existing = await self.get_by_name_and_pack_id(topic_create.name, topic_create.pack_id)
        if existing:
            # Decide how to handle: return existing, raise error, or update?
            # For now, let's return existing to prevent duplicates
            return existing
        return await self.create(obj_in=topic_create)
</file>

<file path="backend/src/repositories/user_pack_history_repository.py">
# backend/src/repositories/user_pack_history_repository.py
import uuid
import logging # Import logging
from typing import List, Optional
from supabase import AsyncClient
from datetime import datetime, timezone # Import timezone

from ..models.user_pack_history import UserPackHistory, UserPackHistoryCreate, UserPackHistoryUpdate
from .base_repository_impl import BaseRepositoryImpl
from ..utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

class UserPackHistoryRepository(BaseRepositoryImpl[UserPackHistory, UserPackHistoryCreate, UserPackHistoryUpdate, str]):
    """
    Repository for managing UserPackHistory data in Supabase.
    """
    def __init__(self, db: AsyncClient):
        super().__init__(model=UserPackHistory, db=db, table_name="user_pack_history") # Table name: "user_pack_history"

    # --- Custom UserPackHistory-specific methods ---

    async def get_by_user_id(self, user_id: str, *, skip: int = 0, limit: int = 100) -> List[UserPackHistory]:
        """Retrieve history entries for a specific user."""
        user_id_str = ensure_uuid(user_id)

        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("user_id", user_id_str)
            .order("last_played_at", desc=True) # Order by most recently played
            .offset(skip)
            .limit(limit)
        )
        response = await self._execute_query(query)
        return [self.model.model_validate(item) for item in response.data] # Use model_validate

    async def get_by_pack_id(self, pack_id: str, *, skip: int = 0, limit: int = 100) -> List[UserPackHistory]:
        """Retrieve history entries for a specific pack."""
        pack_id_str = ensure_uuid(pack_id)

        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("pack_id", pack_id_str)
            .order("last_played_at", desc=True)
            .offset(skip)
            .limit(limit)
        )
        response = await self._execute_query(query)
        return [self.model.model_validate(item) for item in response.data] # Use model_validate

    async def get_by_user_and_pack(self, user_id: str, pack_id: str) -> Optional[UserPackHistory]:
        """Retrieve the specific history entry for a user and pack."""
        user_id_str = ensure_uuid(user_id)
        pack_id_str = ensure_uuid(pack_id)

        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("user_id", user_id_str)
            .eq("pack_id", pack_id_str)
            .limit(1) # Should be unique combination
        )
        response = await self._execute_query(query)
        if response.data:
            return self.model.model_validate(response.data[0]) # Use model_validate
        return None

    # --- MODIFIED: increment_play_count ---
    async def increment_play_count(self, user_id: str, pack_id: str) -> Optional[UserPackHistory]:
        """
        Finds existing history or creates one, increments play count and updates timestamp.
        Returns the updated/created history record.
        """
        user_id_str = ensure_uuid(user_id)
        pack_id_str = ensure_uuid(pack_id)

        try:
            existing = await self.get_by_user_and_pack(user_id_str, pack_id_str)
            now_utc = datetime.now(timezone.utc)

            if existing:
                # Update existing entry
                updated_play_count = existing.play_count + 1
                update_data = UserPackHistoryUpdate(
                    play_count=updated_play_count,
                    last_played_at=now_utc # Pass datetime object
                )
                # Ensure ID is passed as string
                updated_record = await self.update(id=str(existing.id), obj_in=update_data)
                if updated_record:
                    logger.debug(f"Incremented play count for user {user_id_str} on pack {pack_id_str}")
                else:
                    logger.error(f"Failed to update pack history for user {user_id_str}, pack {pack_id_str}")
                return updated_record
            else:
                # Create new entry with the proper create schema
                new_history_data = UserPackHistoryCreate(
                    user_id=user_id_str,
                    pack_id=pack_id_str,
                    play_count=1,
                    last_played_at=now_utc # Pass datetime object
                )
                created_record = await self.create(obj_in=new_history_data)
                if created_record:
                     logger.info(f"Created new pack history for user {user_id_str} on pack {pack_id_str}")
                else:
                     logger.error(f"Failed to create pack history for user {user_id_str}, pack {pack_id_str}")
                return created_record
        except Exception as e:
            logger.error(f"Error incrementing play count for user {user_id_str}, pack {pack_id_str}: {e}", exc_info=True)
            return None # Return None on error
    # --- END MODIFIED: increment_play_count ---
</file>

<file path="backend/src/repositories/user_question_history_repository.py">
# backend/src/repositories/user_question_history_repository.py
import uuid
import logging # Import logging
from typing import List, Optional, Set # Added Set
from supabase import AsyncClient

from ..models.user_question_history import UserQuestionHistory, UserQuestionHistoryCreate, UserQuestionHistoryUpdate
from .base_repository_impl import BaseRepositoryImpl
from ..utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

class UserQuestionHistoryRepository(BaseRepositoryImpl[UserQuestionHistory, UserQuestionHistoryCreate, UserQuestionHistoryUpdate, str]):
    """
    Repository for managing UserQuestionHistory data in Supabase.
    """
    def __init__(self, db: AsyncClient):
        super().__init__(model=UserQuestionHistory, db=db, table_name="user_question_history") # Table name: "user_question_history"

    # --- Custom UserQuestionHistory-specific methods ---

    async def get_by_user_id(self, user_id: str, *, skip: int = 0, limit: int = 100) -> List[UserQuestionHistory]:
        """Retrieve history entries for a specific user."""
        # Ensure user_id is a valid UUID string
        user_id_str = ensure_uuid(user_id)

        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("user_id", user_id_str)
            .order("created_at", desc=True) # Optional: order by date
            .offset(skip)
            .limit(limit)
        )
        response = await self._execute_query(query)
        return [self.model.model_validate(item) for item in response.data] # Use model_validate

    async def get_by_question_id(self, question_id: str, *, skip: int = 0, limit: int = 100) -> List[UserQuestionHistory]:
        """Retrieve history entries for a specific question."""
        # Ensure question_id is a valid UUID string
        question_id_str = ensure_uuid(question_id)

        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("question_id", question_id_str)
            .order("created_at", desc=True)
            .offset(skip)
            .limit(limit)
        )
        response = await self._execute_query(query)
        return [self.model.model_validate(item) for item in response.data] # Use model_validate

    async def get_by_user_and_question(self, user_id: str, question_id: str) -> List[UserQuestionHistory]:
        """Retrieve all history entries for a specific user and question."""
        # Ensure UUIDs are valid UUID strings
        user_id_str = ensure_uuid(user_id)
        question_id_str = ensure_uuid(question_id)

        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("user_id", user_id_str)
            .eq("question_id", question_id_str)
            .order("created_at", desc=True)
        )
        response = await self._execute_query(query)
        return [self.model.model_validate(item) for item in response.data] # Use model_validate

    # --- NEW METHOD for efficient checking ---
    async def get_seen_question_ids_for_users(
        self, user_ids: List[str], question_ids: List[str]
    ) -> Set[str]:
        """
        Retrieve the set of question IDs that have been seen by any of the specified users.
        Filters by the provided question_ids to limit the search scope.

        Args:
            user_ids: List of user IDs to check history for.
            question_ids: List of question IDs to consider.

        Returns:
            A set containing the string representations of question IDs seen by any user.
        """
        if not user_ids or not question_ids:
            return set() # No need to query if either list is empty

        # Ensure UUIDs are strings
        user_ids_str = [ensure_uuid(uid) for uid in user_ids]
        question_ids_str = [ensure_uuid(qid) for qid in question_ids]

        try:
            # Query for distinct question_ids seen by any of the users within the question pool
            query = (
                self.db.table(self.table_name)
                .select("question_id", count="exact") # Fetch only question_id, count for potential pagination (though not used here)
                .in_("user_id", user_ids_str)
                .in_("question_id", question_ids_str)
                # Supabase Python client might not directly support DISTINCT in select easily.
                # We fetch all matching question_ids and dedup in Python using a set.
            )
            response = await self._execute_query(query)

            # Extract unique question IDs from the response data
            seen_ids = {item["question_id"] for item in response.data if "question_id" in item}
            return seen_ids

        except Exception as e:
            logger.error(f"Error fetching seen question IDs for users {user_ids_str}: {e}", exc_info=True)
            # Return empty set on error to avoid blocking game start, but log it.
            return set()
    # --- END NEW METHOD ---
</file>

<file path="backend/src/repositories/user_repository.py">
# backend/src/repositories/user_repository.py
import uuid
from typing import Optional, List
from supabase import AsyncClient

from ..models.user import User, UserCreate, UserUpdate
from .base_repository_impl import BaseRepositoryImpl
from ..utils import ensure_uuid

class UserRepository(BaseRepositoryImpl[User, UserCreate, UserUpdate, str]):
    """
    Repository for managing User data in Supabase.
    Inherits generic CRUD operations from BaseRepositoryImpl.
    """
    def __init__(self, db: AsyncClient):
        super().__init__(model=User, db=db, table_name="users") # Table name: "users"

    # --- Custom User-specific methods can be added here ---

    async def get_by_email(self, email: str) -> Optional[User]:
        """Retrieve a user by their email address."""
        query = self.db.table(self.table_name).select("*").eq("email", email).limit(1)
        response = await self._execute_query(query)
        if response.data:
            return self.model.parse_obj(response.data[0])
        return None

    async def get_by_auth_details(self, auth_provider: str, auth_id: str) -> Optional[User]:
        """Retrieve a user by their authentication provider and ID."""
        query = (
            self.db.table(self.table_name)
            .select("*")
            .eq("auth_provider", auth_provider)
            .eq("auth_id", auth_id)
            .limit(1)
        )
        response = await self._execute_query(query)
        if response.data:
            return self.model.parse_obj(response.data[0])
        return None
</file>

<file path="backend/src/services/__init__.py">
"""
Services module for business logic operations.
"""

from .pack_service import PackService
from .topic_service import TopicService
from .difficulty_service import DifficultyService
from .seed_question_service import SeedQuestionService
from .question_service import QuestionService
from .game_service import GameService
from .user_service import UserService
from .incorrect_answer_service import IncorrectAnswerService # Add export for IncorrectAnswerService


__all__ = [
    "PackService",
    "TopicService",
    "DifficultyService",
    "SeedQuestionService",
    "QuestionService",
    "GameService",
    "UserService",
    "IncorrectAnswerService" 
]
</file>

<file path="backend/src/services/difficulty_service.py">
# backend/src/services/difficulty_service.py
from typing import List, Dict, Any, Optional
import logging

# --- UPDATED IMPORTS ---
from ..models.pack import PackUpdate # Import PackUpdate
from ..repositories.pack_repository import PackRepository # Import PackRepository
# --- END UPDATED IMPORTS ---
from ..services.topic_service import TopicService
from ..utils.question_generation.pack_difficulty_creation import PackDifficultyCreation
from ..utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

class DifficultyService:
    """
    Service for managing difficulty descriptions for trivia packs.
    Stores descriptions directly within the Pack model.
    Uses TopicService to get pack topics for generation context.
    """

    def __init__(
        self,
        topic_service: TopicService,
        pack_repository: PackRepository # <<< CHANGED: Use PackRepository
        ):
        """
        Initialize with required services and repositories.

        Args:
            topic_service: Service for topic-related operations.
            pack_repository: Repository for pack operations.
        """
        self.topic_service = topic_service
        self.pack_repository = pack_repository # <<< CHANGED: Store PackRepository
        self.difficulty_creator = PackDifficultyCreation()

    async def store_difficulty_descriptions(self, pack_id: str, difficulty_json: Dict[str, Dict[str, str]]) -> bool:
        """
        Store difficulty descriptions in the packs table.

        Args:
            pack_id: ID of the pack.
            difficulty_json: Nested dictionary of difficulty descriptions.

        Returns:
            True if successful, False otherwise.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        try:
            # Check if the pack exists first
            existing_pack = await self.pack_repository.get_by_id(pack_id_uuid)
            if not existing_pack:
                logger.error(f"Cannot store difficulty descriptions: Pack with ID {pack_id_uuid} not found.")
                return False

            # Update the pack record with the new descriptions
            update_data = PackUpdate(
                custom_difficulty_description=difficulty_json
            )
            updated_pack = await self.pack_repository.update(id=pack_id_uuid, obj_in=update_data)

            if updated_pack:
                logger.info(f"Stored/Updated difficulty descriptions for pack {pack_id_uuid}")
                return True
            else:
                # This case might happen if the update fails for some reason
                logger.error(f"Failed to update pack {pack_id_uuid} with difficulty descriptions.")
                return False
        except Exception as e:
             logger.error(f"Error storing difficulty descriptions for pack {pack_id_uuid}: {e}", exc_info=True)
             return False


    async def get_existing_difficulty_descriptions(self, pack_id: str) -> Dict[str, Dict[str, str]]:
        """
        Retrieve existing difficulty descriptions for a pack from the packs table.

        Args:
            pack_id: ID of the pack.

        Returns:
            Nested dictionary of difficulty descriptions. Returns defaults if not found or empty.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        pack = await self.pack_repository.get_by_id(pack_id_uuid)

        # Default structure if pack not found or has no descriptions
        default_structure = self.difficulty_creator._get_default_difficulty_structure()

        if pack and hasattr(pack, 'custom_difficulty_description'):
            stored_data = pack.custom_difficulty_description
            # Check if stored_data is a non-empty dictionary
            if isinstance(stored_data, dict) and stored_data:
                # Ensure all expected levels exist, using defaults if needed
                for level, default_content in default_structure.items():
                    if level not in stored_data:
                         stored_data[level] = default_content
                    elif not isinstance(stored_data[level], dict): # Ensure inner value is a dict
                         stored_data[level] = default_content
                    elif "base" not in stored_data[level]: # Ensure base key exists
                         stored_data[level]["base"] = default_content["base"]
                    # "custom" can be missing or empty, which is fine
                return stored_data

        # Return default if pack not found, description field is missing/None, or empty
        logger.debug(f"No valid existing difficulty descriptions found for pack {pack_id_uuid}, returning default structure.")
        return default_structure

    async def update_specific_difficulty_descriptions(
        self,
        pack_id: str,
        difficulty_updates: Dict[str, str]
    ) -> Dict[str, Dict[str, str]]:
        """
        Update specific difficulty descriptions without replacing all of them.

        Args:
            pack_id: ID of the pack.
            difficulty_updates: Dictionary mapping difficulty levels to their new custom descriptions.

        Returns:
            Updated nested dictionary of difficulty descriptions, or default if update failed.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        existing_descriptions = await self.get_existing_difficulty_descriptions(pack_id_uuid) # Fetches defaults if needed

        for level, new_custom_desc in difficulty_updates.items():
            if level in existing_descriptions:
                # Ensure the inner structure is a dict before updating
                if not isinstance(existing_descriptions[level], dict):
                    base_desc = self.difficulty_creator.base_descriptions.get(level, "")
                    existing_descriptions[level] = {"base": base_desc}
                existing_descriptions[level]["custom"] = new_custom_desc
            else:
                # If level doesn't exist yet (e.g., 'Mixed'), create it
                base_desc = self.difficulty_creator.base_descriptions.get(level, "")
                existing_descriptions[level] = {
                    "base": base_desc,
                    "custom": new_custom_desc
                }

        # Store updated descriptions
        success = await self.store_difficulty_descriptions(pack_id_uuid, existing_descriptions)
        return existing_descriptions if success else self.difficulty_creator._get_default_difficulty_structure()

    async def generate_and_store_difficulty_descriptions(
        self,
        pack_id: str,
        # creation_name is removed, will get from pack object
        pack_topics: List[str] # Now passed explicitly
    ) -> Dict[str, Dict[str, str]]:
        """
        Generate and store difficulty descriptions for a pack in JSON format.
        This will overwrite any existing difficulty descriptions in the pack record.

        Args:
            pack_id: ID of the pack.
            pack_topics: List of topics in the pack.

        Returns:
            Nested dictionary of difficulty descriptions, or default if generation/storage failed.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        pack = await self.pack_repository.get_by_id(pack_id_uuid)
        if not pack:
            logger.error(f"Cannot generate difficulty descriptions: Pack {pack_id_uuid} not found.")
            return self.difficulty_creator._get_default_difficulty_structure()

        if not pack_topics:
            logger.warning(f"Cannot generate custom difficulty descriptions for pack {pack_id_uuid} as it has no topics.")
            difficulty_json = self.difficulty_creator._get_default_difficulty_structure()
        else:
            # Generate custom descriptions using the utility and pack name
            custom_descriptions = await self.difficulty_creator.generate_difficulty_descriptions(
                pack_name=pack.name, # <<< CHANGED: Use pack_name
                pack_topics=pack_topics
            )
            # Convert to JSON structure
            difficulty_json = self.difficulty_creator.create_difficulty_json(custom_descriptions)

        # Store in database
        success = await self.store_difficulty_descriptions(
            pack_id=pack_id_uuid,
            difficulty_json=difficulty_json
        )
        return difficulty_json if success else self.difficulty_creator._get_default_difficulty_structure()

    async def generate_and_handle_existing_difficulty_descriptions(
        self,
        pack_id: str,
        # creation_name is removed
        force_regenerate: bool = False
    ) -> Dict[str, Dict[str, str]]:
        """
        Handles the generation of difficulty descriptions while respecting existing ones.
        Fetches topics using TopicService. Stores descriptions in the Pack object.

        Args:
            pack_id: ID of the pack.
            force_regenerate: If True, will regenerate descriptions even if they exist.

        Returns:
            Nested dictionary of difficulty descriptions.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        pack = await self.pack_repository.get_by_id(pack_id_uuid)
        if not pack:
            logger.error(f"Cannot handle difficulty descriptions: Pack {pack_id_uuid} not found.")
            return self.difficulty_creator._get_default_difficulty_structure()

        existing_descriptions = await self.get_existing_difficulty_descriptions(pack_id_uuid)

        # Check if custom descriptions already exist and regeneration isn't forced
        has_custom_descriptions = any(d.get("custom", "") for d in existing_descriptions.values())
        if has_custom_descriptions and not force_regenerate:
            logger.info(f"Using existing difficulty descriptions for pack {pack_id_uuid}.")
            return existing_descriptions

        # Fetch topics needed for generation
        pack_topics = await self.topic_service.get_existing_pack_topics(pack_id_uuid)
        if not pack_topics:
             logger.warning(f"No topics found for pack {pack_id_uuid}. Cannot generate custom difficulty descriptions. Storing defaults.")
             default_structure = self.difficulty_creator._get_default_difficulty_structure()
             await self.store_difficulty_descriptions(pack_id_uuid, default_structure)
             return default_structure

        # Generate and store new descriptions
        logger.info(f"Generating new difficulty descriptions for pack {pack_id_uuid}.")
        return await self.generate_and_store_difficulty_descriptions(
            pack_id=pack_id_uuid,
            # creation_name is derived internally now
            pack_topics=pack_topics
        )

    async def generate_specific_difficulty_descriptions(
        self,
        pack_id: str,
        # creation_name is removed
        difficulty_levels: List[str]
    ) -> Dict[str, Dict[str, str]]:
        """
        Generate descriptions for specific difficulty levels and update them in the Pack.

        Args:
            pack_id: ID of the pack.
            difficulty_levels: List of difficulty levels to update (e.g., ["Hard", "Expert"]).

        Returns:
            Updated nested dictionary of difficulty descriptions.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        pack = await self.pack_repository.get_by_id(pack_id_uuid)
        if not pack:
            logger.error(f"Cannot generate specific difficulty descriptions: Pack {pack_id_uuid} not found.")
            return self.difficulty_creator._get_default_difficulty_structure()

        # Fetch topics needed for generation
        pack_topics = await self.topic_service.get_existing_pack_topics(pack_id_uuid)
        if not pack_topics:
             logger.warning(f"No topics found for pack {pack_id_uuid}. Cannot generate specific difficulty descriptions.")
             return await self.get_existing_difficulty_descriptions(pack_id_uuid) # Return existing

        # Generate all difficulty descriptions temporarily using pack name
        all_descriptions = await self.difficulty_creator.generate_difficulty_descriptions(
            pack_name=pack.name, # <<< CHANGED: Use pack_name
            pack_topics=pack_topics
        )

        # Extract only the requested difficulty levels
        updates = {level: all_descriptions.get(level, "") for level in difficulty_levels if level in all_descriptions}

        # Update only the specified levels in the pack record
        return await self.update_specific_difficulty_descriptions(
            pack_id=pack_id_uuid,
            difficulty_updates=updates
        )
</file>

<file path="backend/src/services/game_service.py">
# backend/src/services/game_service.py
import random
import string
import logging
import asyncio
from typing import List, Optional, Tuple, Dict, Any, Set
from datetime import datetime, timezone # Ensure timezone is imported

# Models
from ..models.game_session import GameSession, GameSessionCreate, GameSessionUpdate, GameStatus
from ..models.game_participant import GameParticipant, GameParticipantCreate, GameParticipantUpdate
from ..models.game_question import GameQuestion, GameQuestionCreate, GameQuestionUpdate
# Corrected import path for Question model if needed (assuming it's directly under models)
from ..models.question import Question # Ensure Question model is imported correctly
from ..models.user_question_history import UserQuestionHistoryCreate

# Repositories
from ..repositories.game_session_repository import GameSessionRepository
from ..repositories.game_participant_repository import GameParticipantRepository
from ..repositories.game_question_repository import GameQuestionRepository
from ..repositories.question_repository import QuestionRepository
from ..repositories.incorrect_answers_repository import IncorrectAnswersRepository
from ..repositories.user_repository import UserRepository
from ..repositories.user_question_history_repository import UserQuestionHistoryRepository
from ..repositories.user_pack_history_repository import UserPackHistoryRepository

# Utils & Schemas
from ..utils import ensure_uuid
# Import GamePlayQuestionResponse for type hint if used internally, else remove
from ..api.schemas.game import GamePlayQuestionResponse

# --- WebSocket Integration ---
from ..websocket_manager import ConnectionManager
# --- End WebSocket Integration ---

# Configure logger
logger = logging.getLogger(__name__)

class GameService:
    """
    Service for game management operations.
    Handles business logic related to creating, joining, and playing
    multiplayer trivia games, including question selection, history tracking,
    and real-time updates via WebSockets.
    """

    def __init__(
        self,
        game_session_repository: GameSessionRepository,
        game_participant_repository: GameParticipantRepository,
        game_question_repository: GameQuestionRepository,
        question_repository: QuestionRepository,
        incorrect_answers_repository: IncorrectAnswersRepository,
        user_repository: UserRepository,
        user_question_history_repository: UserQuestionHistoryRepository,
        user_pack_history_repository: UserPackHistoryRepository,
        connection_manager: ConnectionManager
    ):
        """
        Initialize the service with required repositories and connection manager.
        """
        self.game_session_repo = game_session_repository
        self.game_participant_repo = game_participant_repository
        self.game_question_repo = game_question_repository
        self.question_repo = question_repository
        self.incorrect_answers_repo = incorrect_answers_repository
        self.user_repo = user_repository
        self.user_question_history_repo = user_question_history_repository
        self.user_pack_history_repo = user_pack_history_repository
        self.connection_manager = connection_manager

    async def create_game_session(
        self,
        host_user_id: str,
        pack_id: str,
        max_participants: int = 10,
        question_count: int = 10,
        time_limit_seconds: int = 0
    ) -> GameSession:
        host_user_id = ensure_uuid(host_user_id)
        pack_id = ensure_uuid(pack_id)
        game_code = await self._generate_unique_game_code()
        game_session_data = GameSessionCreate(
            code=game_code, host_user_id=host_user_id, pack_id=pack_id,
            max_participants=max_participants, question_count=question_count,
            time_limit_seconds=time_limit_seconds, status=GameStatus.PENDING
        )
        game_session = await self.game_session_repo.create(obj_in=game_session_data)
        logger.info(f"Created game session with ID: {game_session.id}, code: {game_session.code}")
        host_display_name = "Captain"
        try:
            host_user = await self.user_repo.get_by_id(host_user_id)
            if host_user and host_user.displayname:
                host_display_name = host_user.displayname
            else: logger.warning(f"Could not find user or display name for host {host_user_id}. Using default '{host_display_name}'.")
        except Exception as e: logger.error(f"Error fetching host user {host_user_id} details: {e}. Using default name.")
        host_participant_data = GameParticipantCreate(
            game_session_id=game_session.id, user_id=host_user_id,
            display_name=host_display_name, is_host=True
        )
        await self.game_participant_repo.create(obj_in=host_participant_data)
        logger.info(f"Created host participant record for game {game_session.id} with name '{host_display_name}'")
        # Note: Host will connect via WebSocket separately
        return game_session

    async def _generate_unique_game_code(self, length: int = 6) -> str:
        characters = string.ascii_uppercase + string.digits
        characters = characters.replace('O', '').replace('0', '').replace('I', '').replace('1', '')
        max_attempts = 10
        for _ in range(max_attempts):
            code = ''.join(random.choice(characters) for _ in range(length))
            existing_session = await self.game_session_repo.get_by_code(code)
            if not existing_session: return code
        logger.warning(f"Failed to generate unique code of length {length}, trying length {length+1}")
        return await self._generate_unique_game_code(length + 1)

    async def join_game(
        self,
        game_code: str,
        user_id: str,
        display_name: str
    ) -> Tuple[GameSession, GameParticipant]:
        user_id_str = ensure_uuid(user_id)
        game_session = await self.game_session_repo.get_by_code(game_code)
        if not game_session: raise ValueError(f"Game with code {game_code} not found")
        if game_session.status != GameStatus.PENDING: raise ValueError(f"Game is not accepting new players (status: {game_session.status})")

        participants = await self.game_participant_repo.get_by_game_session_id(game_session.id)
        if len(participants) >= game_session.max_participants: raise ValueError(f"Game with code {game_code} is full")

        existing_participant = await self.game_participant_repo.get_by_user_and_game(user_id_str, game_session.id)
        participant_record: GameParticipant
        is_rejoin = False

        if existing_participant:
            logger.info(f"User {user_id_str} ({display_name}) rejoining game {game_code}")
            is_rejoin = True
            if existing_participant.display_name != display_name:
                logger.info(f"Updating display name for rejoining user {user_id_str} to '{display_name}'")
                updated_record = await self.game_participant_repo.update(
                    id=existing_participant.id,
                    # Type hinting might complain, ignore or adjust Update schema
                    obj_in=GameParticipantUpdate(display_name=display_name) # type: ignore[call-arg]
                )
                if updated_record:
                     participant_record = updated_record
                     # Broadcast name change on rejoin if needed (UserService also handles updates)
                     await self._broadcast_participant_update(game_session.id, participant_record)
                else:
                     participant_record = existing_participant # Fallback if update fails
            else:
                 participant_record = existing_participant
        else:
            # New participant
            participant_data = GameParticipantCreate(
                game_session_id=game_session.id, user_id=user_id_str,
                display_name=display_name, is_host=False
            )
            participant_record = await self.game_participant_repo.create(obj_in=participant_data)
            logger.info(f"User {user_id_str} ({display_name}) joined game {game_code} as participant {participant_record.id}")

        # --- Broadcast Join Event ---
        if not is_rejoin: # Only broadcast for new joins here
             await self._broadcast_participant_update(game_session.id, participant_record)

        return game_session, participant_record

    async def _broadcast_participant_update(self, game_id: str, participant: GameParticipant):
        """Helper to format and broadcast participant join/update messages."""
        message = {
            "type": "participant_update",
            "payload": {
                "id": participant.id,
                "user_id": participant.user_id,
                "display_name": participant.display_name,
                "score": participant.score,
                "is_host": participant.is_host,
            }
        }
        await self.connection_manager.broadcast(message, game_id)
        logger.debug(f"Broadcasted participant update for user {participant.user_id} in game {game_id}")

    async def start_game(self, game_session_id: str, host_user_id: str) -> GameSession:
        """
        Start a game session: Select/prioritize questions based on user history,
        populate game_questions, update user_pack_history, set game to active,
        and broadcast the start event.
        """
        game_session_id = ensure_uuid(game_session_id)
        host_user_id = ensure_uuid(host_user_id)

        # 1. Validation
        game_session = await self.game_session_repo.get_by_id(game_session_id)
        if not game_session: raise ValueError(f"Game with ID {game_session_id} not found")
        if str(game_session.host_user_id) != str(host_user_id): raise ValueError("Only the host can start the game") # Compare as strings
        if game_session.status != GameStatus.PENDING: raise ValueError(f"Game cannot be started (current status: {game_session.status})")

        # 2. Get Participants
        participants = await self.game_participant_repo.get_by_game_session_id(game_session.id)
        participant_user_ids = [p.user_id for p in participants]
        if not participant_user_ids: raise ValueError("Cannot start a game with no participants")

        # 3. Select and Prepare Game Questions
        selected_questions_for_game = await self._select_questions_for_game(
            pack_id=game_session.pack_id,
            target_count=game_session.question_count,
            participant_user_ids=participant_user_ids
        )
        actual_question_count = len(selected_questions_for_game)
        if actual_question_count == 0: raise ValueError("No questions available for this game pack.")

        # Adjust game session count if needed
        if actual_question_count < game_session.question_count:
            updated_session = await self.game_session_repo.update(
                 id=game_session_id,
                 # Type hinting might complain, ignore or adjust Update schema
                 obj_in=GameSessionUpdate(question_count=actual_question_count) # type: ignore[call-arg]
            )
            if not updated_session: raise ValueError(f"Failed to update question count for game {game_session_id}")
            game_session = updated_session

        # 4. Populate `game_questions` Table Concurrently
        game_question_creation_tasks = [
            asyncio.create_task(self.game_question_repo.create(obj_in=GameQuestionCreate(
                game_session_id=game_session_id, question_id=q.id, question_index=idx
            ))) for idx, q in enumerate(selected_questions_for_game)
        ]
        game_question_results = await asyncio.gather(*game_question_creation_tasks, return_exceptions=True)
        failed_creations = [i for i, res in enumerate(game_question_results) if isinstance(res, Exception)]
        if failed_creations:
            logger.error(f"Failed to create {len(failed_creations)} game_question records for game {game_session_id}. Errors: {game_question_results}")
            raise ValueError("Failed to prepare all game questions.")
        logger.info(f"Created {actual_question_count} game question records for game {game_session_id}")

        # 5. Update `user_pack_history` Concurrently
        pack_history_tasks = [
            asyncio.create_task(self.user_pack_history_repo.increment_play_count(user_id, game_session.pack_id))
            for user_id in participant_user_ids
        ]
        pack_history_results = await asyncio.gather(*pack_history_tasks, return_exceptions=True)
        failed_history_updates = [i for i, res in enumerate(pack_history_results) if isinstance(res, Exception) or res is None]
        if failed_history_updates: logger.warning(f"Failed to update pack history for {len(failed_history_updates)} users in game {game_session_id}.")

        # 6. Update Game Status
        updated_game = await self.game_session_repo.update(
            id=game_session_id,
            # Type hinting might complain, ignore or adjust Update schema
            obj_in=GameSessionUpdate(status=GameStatus.ACTIVE, current_question_index=0, updated_at=datetime.now(timezone.utc)) # type: ignore[call-arg]
        )
        if not updated_game: raise ValueError(f"Failed to update game status to ACTIVE for game {game_session_id}")

        # --- 7. Broadcast Game Started Event ---
        # Fetch the formatted first question for the broadcast
        play_questions = await self.get_questions_for_play(updated_game.id) # Use updated game ID
        first_question_payload = play_questions[0] if play_questions else None

        start_message = {
            "type": "game_started",
            "payload": {
                "game_id": updated_game.id,
                "status": updated_game.status.value,
                "total_questions": updated_game.question_count,
                "time_limit": updated_game.time_limit_seconds,
                "pack_id": updated_game.pack_id,
                # Include first question details directly in the start message
                "current_question": first_question_payload
            }
        }
        await self.connection_manager.broadcast(start_message, updated_game.id)
        logger.info(f"Broadcasted game_started event for game {updated_game.id}")
        # --- End Broadcast ---

        logger.info(f"Game {game_session_id} started with {actual_question_count} questions by host {host_user_id}")
        return updated_game

    async def _select_questions_for_game(
        self,
        pack_id: str,
        target_count: int,
        participant_user_ids: List[str]
    ) -> List[Question]:
        pack_id_str = ensure_uuid(pack_id)
        all_pack_questions = await self.question_repo.get_by_pack_id(pack_id_str)
        if not all_pack_questions: return []
        effective_count = min(target_count, len(all_pack_questions))
        pack_question_ids = [str(q.id) for q in all_pack_questions] # Ensure string IDs
        seen_question_ids = await self.user_question_history_repo.get_seen_question_ids_for_users(
            user_ids=participant_user_ids, question_ids=pack_question_ids
        )
        unseen_questions: List[Question] = []
        seen_questions: List[Question] = []
        for q in all_pack_questions: (seen_questions if str(q.id) in seen_question_ids else unseen_questions).append(q) # Compare as strings
        selected_questions_for_game: List[Question] = []
        random.shuffle(unseen_questions); random.shuffle(seen_questions)
        take_from_unseen = min(effective_count, len(unseen_questions))
        selected_questions_for_game.extend(unseen_questions[:take_from_unseen])
        num_needed = effective_count - take_from_unseen
        if num_needed > 0:
            take_from_seen = min(num_needed, len(seen_questions))
            selected_questions_for_game.extend(seen_questions[:take_from_seen])
        random.shuffle(selected_questions_for_game)
        return selected_questions_for_game

    async def get_questions_for_play(self, game_session_id: str) -> List[GamePlayQuestionResponse]:
        game_session_id = ensure_uuid(game_session_id)
        game_session = await self.game_session_repo.get_by_id(game_session_id)
        if not game_session: raise ValueError(f"Game session {game_session_id} not found.")
        game_questions = await self.game_question_repo.get_by_game_session_id(game_session_id)
        if not game_questions: raise ValueError(f"No questions found linked to game session {game_session_id}.")
        fetch_tasks = [
            asyncio.gather( self.question_repo.get_by_id(gq.question_id), self.incorrect_answers_repo.get_by_question_id(gq.question_id), return_exceptions=True )
            for gq in game_questions
        ]
        fetched_data = await asyncio.gather(*fetch_tasks)
        play_questions: List[GamePlayQuestionResponse] = []
        for i, (gq, data) in enumerate(zip(game_questions, fetched_data)):
            original_question, incorrect_answers_record = data
            if isinstance(original_question, Exception) or not original_question: logger.error(f"Failed to fetch original question {gq.question_id}: {original_question}"); continue
            incorrect_options = []
            if isinstance(incorrect_answers_record, Exception): logger.error(f"Failed to fetch incorrect answers for {gq.question_id}: {incorrect_answers_record}")
            elif incorrect_answers_record: incorrect_options = incorrect_answers_record.incorrect_answers

            # Use correctAnswer field from Question model
            correct_answer_text = original_question.answer
            all_options_texts = [correct_answer_text] + incorrect_options
            random.shuffle(all_options_texts)

            # Create answer IDs like "qID-optionIndex"
            answer_options_with_ids = [
                {"id": f"{gq.question_id}-{idx}", "text": text}
                for idx, text in enumerate(all_options_texts)
            ]

            # Find the ID of the correct option after shuffling
            correct_answer_id = None
            for option in answer_options_with_ids:
                if option["text"] == correct_answer_text:
                    correct_answer_id = option["id"]
                    break

            if correct_answer_id is None:
                logger.error(f"Could not determine correct_answer_id for question {gq.question_id}. Correct text: '{correct_answer_text}'. Options: {answer_options_with_ids}")
                continue

            play_question = GamePlayQuestionResponse(
                index=gq.question_index,
                question_id=gq.question_id,
                question_text=original_question.question,
                options=[opt["text"] for opt in answer_options_with_ids], # Pass only texts
                correct_answer_id=correct_answer_id, # Pass the generated correct ID
                time_limit=game_session.time_limit_seconds
            )
            play_questions.append(play_question)

        play_questions.sort(key=lambda q: q.index)
        return play_questions

    async def _advance_to_next_question(
        self,
        game_session_id: str,
        next_index: Optional[int] = None
    ) -> Optional[GameQuestion]:
        game_session_id = ensure_uuid(game_session_id)
        game_session = await self.game_session_repo.get_by_id(game_session_id)
        if not game_session: logger.error(f"Game session {game_session_id} not found during advance"); return None
        if next_index is None: next_index = game_session.current_question_index + 1
        total_questions_in_game = game_session.question_count
        if next_index >= total_questions_in_game:
            if game_session.status == GameStatus.ACTIVE:
                updated_session = await self.game_session_repo.update_game_status(game_id=game_session_id, status=GameStatus.COMPLETED)
                if updated_session: logger.info(f"Game {game_session_id} completed")
                else: logger.error(f"Failed to update game status to COMPLETED for {game_session_id}")
            else: logger.info(f"Game {game_session_id} already in status {game_session.status}")
            return None # Indicates game end
        # Update the game session's current index
        updated_session = await self.game_session_repo.update(id=game_session_id, obj_in=GameSessionUpdate(current_question_index=next_index) ) # type: ignore[call-arg]
        if not updated_session: logger.error(f"Failed to update current_question_index for game {game_session_id}"); return None
        # Get the corresponding GameQuestion record
        next_game_question = await self.game_question_repo.get_by_game_session_and_index(game_session_id=game_session_id, question_index=next_index)
        if next_game_question:
            # Mark the question as started (sets start_time) - Note: Timer start should be triggered by client receiving the WS message
            started_question = await self.game_question_repo.start_question(next_game_question.id)
            if started_question: logger.info(f"Game {game_session_id} advanced to question {next_index}"); return started_question
            else: logger.error(f"Failed to mark game question {next_game_question.id} as started for game {game_session_id}"); return None
        else: logger.error(f"Game {game_session_id}: Failed to find game question at index {next_index}"); return None

    # --- METHOD WITH FIXES APPLIED ---
    async def submit_answer(
        self,
        game_session_id: str,
        participant_id: str,
        question_index: int,
        answer: str # Frontend sends answer ID like "qID-optionIndex"
    ) -> Dict[str, Any]:
        # Ensure UUIDs are strings
        game_session_id = ensure_uuid(game_session_id)
        participant_id = ensure_uuid(participant_id)

        # 1. Fetch game session and participant
        game_session = await self.game_session_repo.get_by_id(game_session_id)
        if not game_session: raise ValueError(f"Game {game_session_id} not found")
        if game_session.status != GameStatus.ACTIVE: raise ValueError(f"Game not active")

        participant = await self.game_participant_repo.get_by_id(participant_id)
        if not participant or str(participant.game_session_id) != str(game_session_id):
            raise ValueError(f"Participant not found in game")

        # 2. Fetch the specific GameQuestion
        game_question = await self.game_question_repo.get_by_game_session_and_index(game_session_id, question_index)
        if not game_question: raise ValueError(f"Question index {question_index} not found for this game")

        # 3. Check question timing and if already answered
        # *** REMOVED THE start_time CHECK ***
        # if not game_question.start_time: raise ValueError(f"Question {question_index} not started yet")
        # *** KEEP THE end_time CHECK ***
        if game_question.end_time: raise ValueError(f"Question {question_index} has already ended")

        # Check if this participant already answered
        if participant_id in game_question.participant_answers:
            raise ValueError("Answer already submitted for this question")

        # 5. Record answer
        await self.game_question_repo.record_participant_answer(game_question.id, participant_id, str(answer))

        # 6. Check correctness and calculate score
        original_question = await self.question_repo.get_by_id(game_question.question_id)
        if not original_question:
            logger.error(f"Original question {game_question.question_id} not found for game question {game_question.id}")
            return {"success": False, "error": "Original question data missing"}

        # --- Correctness check (requires reconstructing options/IDs) ---
        incorrect_answers_record = await self.incorrect_answers_repo.get_by_question_id(original_question.id)
        incorrect_options = incorrect_answers_record.incorrect_answers if incorrect_answers_record else []
        all_options_texts = [original_question.answer] + incorrect_options
        # We need a deterministic way to map submitted ID back to text or compare IDs.
        # Let's reconstruct the potential IDs based on the order the backend knows.
        answer_options_with_ids = [
             {"id": f"{original_question.id}-{idx}", "text": text}
             for idx, text in enumerate(all_options_texts)
        ]
        correct_answer_option = next((opt for opt in answer_options_with_ids if opt["text"] == original_question.answer), None)
        correct_answer_id_generated = correct_answer_option["id"] if correct_answer_option else None

        if not correct_answer_id_generated:
             logger.error(f"Could not reconstruct correct answer ID for question {original_question.id}")
             return {"success": False, "error": "Internal error checking answer"}

        is_correct = str(answer) == str(correct_answer_id_generated)
        logger.info(f"Correctness check for Q{question_index}: Submitted='{answer}', Correct ID='{correct_answer_id_generated}', Result={is_correct}")
        # --- End Correctness Check ---

        # --- Simplified Score Calculation ---
        score = 1 if is_correct else 0
        # --- End Simplified Score Calculation ---

        # 7. Record score for this question
        await self.game_question_repo.record_participant_score(game_question.id, participant_id, score)

        # 8. Update participant's total score
        current_total_score = participant.score if participant.score is not None else 0
        new_total_score = current_total_score + score
        updated_participant = await self.game_participant_repo.update_score(participant_id, new_total_score)
        final_total_score = updated_participant.score if updated_participant else new_total_score

        # 9. Record in user history
        try:
            history_data = UserQuestionHistoryCreate(
                user_id=participant.user_id,
                question_id=game_question.question_id,
                correct=is_correct,
            )
            await self.user_question_history_repo.create(obj_in=history_data)
        except Exception as hist_error:
            logger.error(f"Failed to record question history for user {participant.user_id}, question {game_question.question_id}: {hist_error}", exc_info=True)

        # 10. Return result
        return {
            "success": True,
            "is_correct": is_correct,
            "correct_answer": original_question.answer, # Return correct text
            "score": score, # Score for this question (now 1 or 0)
            "total_score": final_total_score # Participant's new total score
        }
    # --- END METHOD WITH FIXES APPLIED ---


    async def end_current_question(
        self,
        game_session_id: str,
        host_user_id: str
    ) -> Dict[str, Any]:
        """Ends the current question, calculates results/scores for it, advances the game, and broadcasts the next step."""
        game_session_id = ensure_uuid(game_session_id); host_user_id = ensure_uuid(host_user_id)
        game_session = await self.game_session_repo.get_by_id(game_session_id)
        if not game_session: raise ValueError(f"Game {game_session_id} not found")
        if str(game_session.host_user_id) != str(host_user_id): raise ValueError("Only host can end question/advance game") # Compare as strings
        if game_session.status != GameStatus.ACTIVE: raise ValueError(f"Game not active")

        current_index = game_session.current_question_index
        current_game_question = await self.game_question_repo.get_by_game_session_and_index(game_session_id, current_index)

        # End the current question in DB if not already ended
        if current_game_question and current_game_question.start_time and not current_game_question.end_time:
             ended_question = await self.game_question_repo.end_question(current_game_question.id)
             if ended_question: current_game_question = ended_question # Use updated record
             else: logger.warning(f"Failed to mark question {current_index} as ended.")
        elif not current_game_question: logger.warning(f"Current game question (index {current_index}) not found when trying to end it.")

        # Advance to the next question or get game end signal
        next_game_question = await self._advance_to_next_question(game_session_id)

        if next_game_question:
            # Fetch formatted next question details
            play_questions = await self.get_questions_for_play(game_session_id)
            next_question_payload = next((q for q in play_questions if q.index == next_game_question.question_index), None)

            if next_question_payload:
                # --- Broadcast Next Question Event ---
                next_q_message = {"type": "next_question", "payload": next_question_payload}
                await self.connection_manager.broadcast(next_q_message, game_session_id)
                logger.info(f"Broadcasted next_question event (index {next_game_question.question_index}) for game {game_session_id}")
                # --- End Broadcast ---
                # Return minimal REST response containing the next question payload
                return {"game_complete": False, "next_question": next_question_payload}
            else:
                 logger.error(f"Failed to format next question payload for index {next_game_question.question_index} in game {game_session_id}")
                 # If formatting fails, we might still need to end the game gracefully
                 await self.game_session_repo.update_game_status(game_id=game_session_id, status=GameStatus.COMPLETED) # Force complete
                 return {"game_complete": True, "error": "Failed to load next question data"}
        else:
            # Game has ended (or failed to advance)
            final_game_session = await self.game_session_repo.get_by_id(game_session_id) # Re-fetch to confirm status
            if final_game_session and final_game_session.status == GameStatus.COMPLETED:
                 final_results = await self.get_game_results(game_session_id)
                 # --- Broadcast Game End Event ---
                 end_message = {"type": "game_over", "payload": final_results}
                 await self.connection_manager.broadcast(end_message, game_session_id)
                 logger.info(f"Broadcasted game_over event for game {game_session_id}")
                 # --- End Broadcast ---
                 return {"game_complete": True} # Minimal REST response
            else:
                 logger.warning(f"Game {game_session_id} advance returned None, but status is {final_game_session.status if final_game_session else 'Not Found'}. Ending game.")
                 # Force status update just in case
                 await self.game_session_repo.update_game_status(game_id=game_session_id, status=GameStatus.COMPLETED)
                 final_results = await self.get_game_results(game_session_id) # Get results again
                 end_message = {"type": "game_over", "payload": final_results}
                 await self.connection_manager.broadcast(end_message, game_session_id)
                 return {"game_complete": True}

    async def get_game_participants(self, game_session_id: str) -> List[Dict[str, Any]]:
        game_session_id_str = ensure_uuid(game_session_id)
        participants: List[GameParticipant] = await self.game_participant_repo.get_by_game_session_id(game_session_id_str)
        # Use model_dump for Pydantic V2 serialization if needed, or manual dict creation
        return [{"id": p.id, "user_id": p.user_id, "display_name": p.display_name, "score": p.score, "is_host": p.is_host} for p in participants]

    async def get_game_results(self, game_session_id: str) -> Dict[str, Any]:
        game_session_id = ensure_uuid(game_session_id)
        game_session = await self.game_session_repo.get_by_id(game_session_id)
        if not game_session: raise ValueError(f"Game {game_session_id} not found")

        participants = await self.game_participant_repo.get_by_game_session_id(game_session_id)
        participants.sort(key=lambda p: p.score, reverse=True) # Sort by score desc

        game_questions = await self.game_question_repo.get_by_game_session_id(game_session_id)
        question_results = []
        for gq in game_questions:
             original_question = await self.question_repo.get_by_id(gq.question_id)
             if original_question:
                 correct_count = sum(1 for score in gq.participant_scores.values() if score > 0)
                 total_answered = len(gq.participant_answers)
                 correct_percentage = (correct_count / total_answered * 100) if total_answered > 0 else 0
                 question_results.append({
                     "index": gq.question_index,
                     "question_text": original_question.question,
                     "correct_answer": original_question.answer, # Return correct answer text
                     "correct_count": correct_count,
                     "total_answered": total_answered,
                     "correct_percentage": round(correct_percentage, 1) # Round percentage
                 })

        participant_results = [{"id": p.id, "user_id": p.user_id, "display_name": p.display_name, "score": p.score, "is_host": p.is_host} for p in participants]
        completion_time = game_session.updated_at if game_session.status in [GameStatus.COMPLETED, GameStatus.CANCELLED] else datetime.now(timezone.utc)

        return {
            "game_id": game_session_id,
            "game_code": game_session.code,
            "status": game_session.status.value,
            "participants": participant_results,
            "questions": question_results,
            "total_questions": len(game_questions),
            "completed_at": completion_time.isoformat() # Use ISO format
        }

    async def cancel_game(self, game_session_id: str, host_user_id: str) -> GameSession:
        game_session_id = ensure_uuid(game_session_id); host_user_id = ensure_uuid(host_user_id)
        game_session = await self.game_session_repo.get_by_id(game_session_id)
        if not game_session: raise ValueError(f"Game {game_session_id} not found")
        if str(game_session.host_user_id) != str(host_user_id): raise ValueError("Only host can cancel") # Compare as strings
        if game_session.status not in [GameStatus.PENDING, GameStatus.ACTIVE]: raise ValueError(f"Game cannot be cancelled (status: {game_session.status})")

        updated_game = await self.game_session_repo.update_game_status(game_id=game_session_id, status=GameStatus.CANCELLED)
        if not updated_game: raise ValueError(f"Failed to cancel game {game_session_id}")

        # --- Broadcast Cancel Event ---
        cancel_message = {"type": "game_cancelled", "payload": {"game_id": game_session_id}}
        await self.connection_manager.broadcast(cancel_message, game_session_id)
        logger.info(f"Broadcasted game_cancelled event for game {game_session_id}")
        # --- End Broadcast ---

        logger.info(f"Game {game_session_id} cancelled by host {host_user_id}")
        return updated_game

    async def handle_disconnect(self, game_id: str, user_id: str):
        """Handles logic when a user disconnects (called by WS endpoint)."""
        logger.info(f"Handling disconnect for user {user_id} in game {game_id}")
        # Find the participant record
        participant = await self.game_participant_repo.get_by_user_and_game(user_id, game_id)
        if participant:
            # Broadcast user_left message
            message = {"type": "participant_left", "payload": {"user_id": user_id, "participant_id": participant.id, "display_name": participant.display_name}}
            await self.connection_manager.broadcast(message, game_id)
            logger.debug(f"Broadcasted participant_left for user {user_id} in game {game_id}")

        else:
            logger.warning(f"Participant record not found for disconnected user {user_id} in game {game_id}")

    async def get_user_games(self, user_id: str, include_completed: bool = False) -> List[Dict[str, Any]]:
        user_id = ensure_uuid(user_id); participations = await self.game_participant_repo.get_user_active_games(user_id)
        results = []; processed_game_ids = set()
        for participation in participations:
             game_session_id = str(participation.game_session_id) # Ensure string
             if game_session_id in processed_game_ids: continue
             game_session = await self.game_session_repo.get_by_id(game_session_id)
             if not game_session: logger.warning(f"Game session {game_session_id} not found for participation {participation.id}"); continue
             if not include_completed and game_session.status in [GameStatus.COMPLETED, GameStatus.CANCELLED]: continue
             participants_in_game = await self.game_participant_repo.get_by_game_session_id(game_session.id)
             game_info = {"id": game_session.id, "code": game_session.code, "status": game_session.status.value, "participant_count": len(participants_in_game), "max_participants": game_session.max_participants, "current_question": game_session.current_question_index, "total_questions": game_session.question_count, "is_host": participation.is_host, "created_at": game_session.created_at.isoformat(), "updated_at": game_session.updated_at.isoformat()}
             results.append(game_info); processed_game_ids.add(game_session_id)
        return results
</file>

<file path="backend/src/services/incorrect_answer_service.py">
# backend/src/services/incorrect_answer_service.py
import logging
from typing import List, Optional, Dict, Any
import asyncio

from ..models.question import Question
from ..models.incorrect_answers import IncorrectAnswers, IncorrectAnswersCreate, IncorrectAnswersUpdate
from ..repositories.question_repository import QuestionRepository
from ..repositories.incorrect_answers_repository import IncorrectAnswersRepository
from ..utils.question_generation.incorrect_answer_generator import IncorrectAnswerGenerator, IncorrectAnswerGenerationError # Import the custom error
from ..utils import ensure_uuid

logger = logging.getLogger(__name__)

class IncorrectAnswerService:
    """
    Service for generating and managing incorrect answers for trivia questions.
    """

    def __init__(
        self,
        question_repository: QuestionRepository,
        incorrect_answers_repository: IncorrectAnswersRepository,
        incorrect_answer_generator: Optional[IncorrectAnswerGenerator] = None
    ):
        self.question_repository = question_repository
        self.incorrect_answers_repository = incorrect_answers_repository
        self.incorrect_answer_generator = incorrect_answer_generator or IncorrectAnswerGenerator()

    async def generate_and_store_incorrect_answers(
        self,
        questions: List[Question], # Accepts List[Question]
        num_incorrect_answers: int = 3,
        batch_size: int = 5,
        debug_mode: bool = False
    ) -> Dict[str, List[str]]:
        """
        Generate incorrect answers for a list of questions and store them.
        Handles potential errors from the generator.

        Args:
            questions: List of Question objects
            num_incorrect_answers: Number of incorrect answers per question
            batch_size: Size of question batches for processing
            debug_mode: Enable verbose debug logging

        Returns:
            Dictionary mapping successfully processed question IDs (as strings)
            to their incorrect answers.

        Raises:
             IncorrectAnswerGenerationError: If generation fails definitively for
                                             one or more questions after retries.
        """
        if not questions:
            logger.warning("No questions provided for incorrect answer generation")
            return {}

        generation_results: List[Tuple[str, List[str]]] = [] # Expects (id_str, answers_list)
        failed_question_ids_from_gen: List[str] = []

        try:
            # Generate incorrect answers using the generator which might raise an error
            # The generator now returns List[Tuple[str, List[str]]] only for successes
            generation_results = await self.incorrect_answer_generator.generate_incorrect_answers(
                questions=questions,
                num_incorrect_answers=num_incorrect_answers,
                batch_size=batch_size,
                max_retries=1, # Allow one retry
                debug_mode=debug_mode
            )
            # If no exception, generation was successful for all questions attempted in the final retry.

        except IncorrectAnswerGenerationError as e:
            # Log the error and the IDs that failed definitively during generation
            logger.error(f"Incorrect answer generation failed permanently for some questions: {e.message}")
            failed_question_ids_from_gen = e.failed_question_ids
            # Continue to store results for questions that *did* succeed in generation_results

        # --- Store the successfully generated incorrect answers ---
        stored_answers_map: Dict[str, List[str]] = {}
        tasks_to_store = []

        for question_id_str, incorrect_answers in generation_results:
            # Create a task for each DB operation
             tasks_to_store.append(
                 asyncio.create_task(
                     self._store_single_incorrect_answer_set(question_id_str, incorrect_answers)
                 )
             )

        # Run storage operations concurrently
        storage_results = await asyncio.gather(*tasks_to_store, return_exceptions=True)

        # Process storage results
        db_failed_ids = []
        for i, result in enumerate(storage_results):
             question_id_str = generation_results[i][0] # Get corresponding ID
             if isinstance(result, Exception):
                 db_failed_ids.append(question_id_str)
                 logger.error(f"Database error storing incorrect answers for question {question_id_str}: {result}", exc_info=result)
             elif result: # If _store_single returned True
                  stored_answers_map[question_id_str] = generation_results[i][1] # Store the answers

        # --- Consolidate failures and potentially raise error ---
        final_failed_ids = list(set(failed_question_ids_from_gen + db_failed_ids))
        total_attempted_count = len(questions)
        final_successful_count = len(stored_answers_map)
        final_failed_count = total_attempted_count - final_successful_count

        logger.info(f"Finished storing incorrect answers. Success: {final_successful_count}/{total_attempted_count}. Failed (gen or store): {final_failed_count}")

        # If there were any definitive failures (either in generation or storage), raise exception
        if final_failed_ids:
             # Ensure we only report IDs that were actually in the input list
             original_ids_str = {str(q.id) for q in questions}
             actual_failures = list(set(final_failed_ids).intersection(original_ids_str))
             if actual_failures:
                 raise IncorrectAnswerGenerationError(
                     f"Failed to generate or store incorrect answers for {len(actual_failures)} questions.",
                     actual_failures
                 )

        return stored_answers_map # Return map of successfully stored answers

    async def _store_single_incorrect_answer_set(self, question_id_str: str, incorrect_answers: List[str]) -> bool:
        """Helper coroutine to store answers for one question."""
        question_id_uuid = ensure_uuid(question_id_str) # Ensure UUID string format
        try:
            existing_answers = await self.incorrect_answers_repository.get_by_question_id(question_id_uuid)
            if existing_answers:
                update_schema = IncorrectAnswersUpdate(incorrect_answers=incorrect_answers)
                update_result = await self.incorrect_answers_repository.update(
                    id=existing_answers.id, obj_in=update_schema
                )
                if update_result:
                    logger.debug(f"Updated incorrect answers for question {question_id_str}")
                    return True
                else:
                    logger.error(f"Failed to update incorrect answers DB record for question {question_id_str}")
                    return False
            else:
                create_data = IncorrectAnswersCreate(
                    question_id=question_id_uuid,
                    incorrect_answers=incorrect_answers
                )
                created = await self.incorrect_answers_repository.create(obj_in=create_data)
                if created:
                    logger.debug(f"Created incorrect answers for question {question_id_str}")
                    return True
                else:
                    logger.error(f"Failed to create incorrect answers DB record for question {question_id_str}")
                    return False
        except Exception as db_error:
             # Let the exception propagate up to be caught by gather
             raise db_error


    async def generate_for_pack(
        self,
        pack_id: str,
        num_incorrect_answers: int = 3,
        batch_size: int = 5,
        debug_mode: bool = False
    ) -> Dict[str, List[str]]:
        """
        Generate incorrect answers for all questions currently in a pack.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        questions_in_pack = await self.question_repository.get_by_pack_id(pack_id_uuid)

        if not questions_in_pack:
            logger.warning(f"No questions found in pack {pack_id} to generate incorrect answers for.")
            return {}

        logger.info(f"Generating incorrect answers for {len(questions_in_pack)} questions in pack {pack_id}")

        # Call the core method that handles generation and storage
        # This will raise IncorrectAnswerGenerationError if generation fails for some questions
        # The API layer will catch this and report the failure.
        result_map = await self.generate_and_store_incorrect_answers(
            questions=questions_in_pack,
            num_incorrect_answers=num_incorrect_answers,
            batch_size=batch_size,
            debug_mode=debug_mode
        )
        return result_map # Returns dict of successes if no exception was raised


    async def get_incorrect_answers(
        self,
        question_id: str
    ) -> Optional[List[str]]:
        """
        Get incorrect answers for a specific question.
        """
        question_id_uuid = ensure_uuid(question_id)
        result = await self.incorrect_answers_repository.get_by_question_id(question_id_uuid)
        return result.incorrect_answers if result else None
</file>

<file path="backend/src/services/pack_service.py">
# backend/src/services/pack_service.py
from typing import Tuple, Optional, List
import logging
import traceback

from ..models.pack import Pack, PackCreate, PackUpdate, CreatorType
from ..repositories.pack_repository import PackRepository
from ..utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

class PackService:
    """
    Service for pack management operations.
    Handles business logic related to creating, retrieving, and validating packs.
    """
    
    def __init__(self, pack_repository: PackRepository):
        """
        Initialize the service with required repositories.
        
        Args:
            pack_repository: Repository for pack operations
        """
        self.pack_repository = pack_repository
    
    async def validate_creation_name(self, creation_name: str) -> Tuple[bool, Optional[str]]:
        """
        Check if a pack with the given creation name already exists.
        
        Args:
            creation_name: The name to validate (will be converted to lowercase)
            
        Returns:
            Tuple containing:
                - Boolean indicating if the pack exists
                - ID of the existing pack (if found, otherwise None)
        """
        # Import here to avoid circular imports
        from ..utils.document_processing.processors import normalize_text
        
        try:
            # Convert to lowercase as specified in requirements
            normalized_name = normalize_text(creation_name, lowercase=True)
            
            # Use the search_by_name method from the repository
            packs = await self.pack_repository.search_by_name(normalized_name)
            
            # Check for exact matches (case-insensitive)
            for pack in packs:
                if normalize_text(pack.name, lowercase=True) == normalized_name:
                    return True, pack.id
            
            # If we get here, no exact match was found
            return False, None
                
        except Exception as e:
            # Log the error with full traceback
            logger.error(f"Error validating creation name: {str(e)}")
            logger.error(traceback.format_exc())
            # Re-raise for proper error handling upstream
            raise
    
    async def get_all_packs(self, skip: int = 0, limit: int = 100) -> List[Pack]:
        """
        Get all packs with pagination.
        
        Args:
            skip: Number of packs to skip (pagination offset)
            limit: Maximum number of packs to return
            
        Returns:
            List of Pack objects
        """
        try:
            return await self.pack_repository.get_all(skip=skip, limit=limit)
        except Exception as e:
            logger.error(f"Error retrieving all packs: {str(e)}")
            logger.error(traceback.format_exc())
            raise
    
    async def get_or_create_pack(
        self,
        pack_name: str,
        pack_description: Optional[str] = None,
        price: float = 0.0,
        creator_type: CreatorType = CreatorType.SYSTEM,
        update_if_exists: bool = True
    ) -> Tuple[Pack, bool]:
        """
        Get an existing pack by name or create a new one if it doesn't exist.
        
        Args:
            pack_name: Name of the pack to get or create
            pack_description: Optional description for the pack
            price: Price of the pack (default: 0.0 for free packs)
            creator_type: Type of creator (default: SYSTEM)
            update_if_exists: Whether to update the description of an existing pack
            
        Returns:
            Tuple containing:
                - The existing or newly created Pack
                - Boolean indicating if the pack was newly created (True) or existed (False)
        """
        try:
            # Check if a pack with this name already exists
            exists, existing_pack_id = await self.validate_creation_name(pack_name)
            
            if exists and existing_pack_id:
                # Ensure existing_pack_id is a valid UUID string
                existing_pack_id_str = ensure_uuid(existing_pack_id)
                
                logger.info(f"Found existing pack with ID: {existing_pack_id_str}")
                
                # Pack exists, retrieve it
                existing_pack = await self.pack_repository.get_by_id(existing_pack_id_str)
                
                # Optionally update the description if provided and different
                if update_if_exists and pack_description and existing_pack.description != pack_description:
                    logger.info(f"Updating description for pack ID: {existing_pack_id_str}")
                    update_data = PackUpdate(description=pack_description)
                    existing_pack = await self.pack_repository.update(id=existing_pack_id_str, obj_in=update_data)
                    
                return existing_pack, False
            
            logger.info(f"Creating new pack: {pack_name}")
            # Pack doesn't exist, create a new one
            pack_data = PackCreate(
                name=pack_name,
                description=pack_description,
                price=price,
                creator_type=creator_type,
            )
            
            new_pack = await self.pack_repository.create(obj_in=pack_data)
            logger.info(f"Created new pack with ID: {new_pack.id}")
            return new_pack, True
        
        except Exception as e:
            logger.error(f"Error in get_or_create_pack: {str(e)}")
            logger.error(traceback.format_exc())
            raise
</file>

<file path="backend/src/services/question_service.py">
# backend/src/services/question_service.py
import uuid
import logging
import json
import traceback
import asyncio
from typing import List, Dict, Any, Optional, Union, Tuple

# --- UPDATED IMPORTS ---
from ..models.pack import Pack # Import Pack model
from ..models.question import Question, QuestionCreate, QuestionUpdate, DifficultyLevel
from ..repositories.question_repository import QuestionRepository
from ..repositories.pack_repository import PackRepository # Import PackRepository
from ..repositories.topic_repository import TopicRepository
# --- NEW IMPORT ---
from ..services.seed_question_service import SeedQuestionService # <<< ADDED
# --- END UPDATED IMPORTS ---
from ..utils.question_generation.question_generator import QuestionGenerator
# --- SCHEMA IMPORT ---
from ..api.schemas.question import TopicQuestionConfig, DifficultyConfig # Import schemas
# --- END SCHEMA IMPORT ---
from ..utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

# Helper to print JSON nicely during debug
def print_json(data: Any):
    try:
        # Use model_dump for Pydantic V2 if applicable, otherwise default=str
        print(json.dumps(data, indent=2, default=lambda x: x.value if isinstance(x, DifficultyLevel) else str(x)))
    except Exception as e:
        print(f"Could not print JSON: {e}")
        print(data)

class QuestionService:
    """
    Service for question management operations.

    Handles business logic related to creating, retrieving,
    and managing trivia questions. Fetches topic-specific instructions.
    Relies on PackRepository for seed questions and difficulty descriptions.
    Does NOT handle incorrect answer generation.
    """

    # --- MODIFIED __init__ ---
    def __init__(
        self,
        question_repository: QuestionRepository,
        topic_repository: TopicRepository,
        pack_repository: PackRepository,
        seed_question_service: SeedQuestionService, # <<< ADDED
        question_generator: Optional[QuestionGenerator] = None,
    ):
        """
        Initialize the service with required repositories.
        """
        self.question_repository = question_repository
        self.topic_repository = topic_repository
        self.pack_repository = pack_repository
        self.seed_question_service = seed_question_service # <<< ADDED
        self.question_generator = question_generator or QuestionGenerator()
        self.debug_enabled = False
    # --- END MODIFIED __init__ ---

    async def _create_question(self, question_data: Dict[str, Any]) -> Optional[Question]:
        """
        Helper method to create a single question in the database.
        Validates data and uses the repository.
        (Unchanged)
        """
        try:
            if self.debug_enabled:
                print("\n  === Creating Question (Internal) ===")
                print(f"  Raw Data: {question_data}")

            pack_id_uuid = ensure_uuid(question_data.get("pack_id"))
            if not pack_id_uuid:
                 logger.error("Missing or invalid pack_id in question data")
                 return None

            difficulty_initial_val = question_data.get("difficulty_initial")
            difficulty_current_val = question_data.get("difficulty_current")

            try:
                if isinstance(difficulty_initial_val, DifficultyLevel):
                     difficulty_initial_enum = difficulty_initial_val
                else:
                     difficulty_initial_enum = DifficultyLevel(difficulty_initial_val.lower()) if difficulty_initial_val else None

                if isinstance(difficulty_current_val, DifficultyLevel):
                     difficulty_current_enum = difficulty_current_val
                else:
                     difficulty_current_enum = DifficultyLevel(difficulty_current_val.lower()) if difficulty_current_val else None

            except (ValueError, AttributeError):
                logger.warning(f"Invalid difficulty value found: initial='{difficulty_initial_val}', current='{difficulty_current_val}'. Defaulting to MIXED.")
                difficulty_initial_enum = DifficultyLevel.MIXED
                difficulty_current_enum = DifficultyLevel.MIXED

            question_create = QuestionCreate(
                question=question_data["question"],
                answer=question_data["answer"],
                pack_id=pack_id_uuid,
                pack_topics_item=question_data.get("pack_topics_item"),
                difficulty_initial=difficulty_initial_enum,
                difficulty_current=difficulty_current_enum or difficulty_initial_enum, # Default current to initial if current is None
                correct_answer_rate=question_data.get("correct_answer_rate", 0.0)
            )

            if self.debug_enabled:
                print(f"  Prepared Schema:")
                print_json(question_create.model_dump(mode='json'))

            created_question = await self.question_repository.create(obj_in=question_create)

            if self.debug_enabled:
                 print(f"  Database Result ID: {created_question.id if created_question else 'None'}")

            return created_question

        except Exception as e:
            logger.error(f"Error creating question internally: {str(e)}", exc_info=True)
            if self.debug_enabled:
                print(f"  Error creating question: {str(e)}")
                print(traceback.format_exc())
            return None

    # --- MODIFIED _generate_questions_for_topic_difficulty ---
    async def _generate_questions_for_topic_difficulty(
        self,
        pack: Pack,
        topic: str,
        difficulty_config: DifficultyConfig,
        custom_instruction_for_topic: Optional[str], # <<< ADDED Parameter
        debug_mode: bool
    ) -> List[Question]:
        """
        Internal helper to generate and store questions for ONE topic-difficulty pair.
        Uses provided custom instructions. Reads seeds/diffs from Pack object.
        Returns the list of successfully created Question objects.
        """
        pack_id_uuid = ensure_uuid(pack.id)
        target_difficulty = difficulty_config.difficulty
        num_questions = difficulty_config.num_questions

        # Get seeds and difficulty descriptions from the pack object
        difficulty_descriptions = pack.custom_difficulty_description or {}
        all_seeds = pack.seed_questions or {}
        # Filter seeds per topic
        topic_seeds = {q: a for q, a in all_seeds.items() if topic.lower() in q.lower()}

        if debug_mode:
            print(f"\n  Starting generation for topic: '{topic}' (Difficulty: {target_difficulty.value}, Count: {num_questions})")
            print(f"    Using {len(topic_seeds)} seed questions for this topic.")
            if custom_instruction_for_topic:
                 print(f"    Using provided custom instruction: '{custom_instruction_for_topic[:50]}...'")
            else:
                 print(f"    No custom instruction provided for this topic.")

        # --- REMOVED Internal Fetch for custom instructions ---
        # topic_record = await self.topic_repository.get_by_name_and_pack_id(topic, pack_id_uuid)
        # ...

        try:
            # Call the QuestionGenerator, passing the provided instruction
            question_data_list: List[Dict] = await self.question_generator.generate_questions(
                pack_id=pack_id_uuid,
                pack_name=pack.name,
                pack_topic=topic,
                difficulty=target_difficulty,
                difficulty_descriptions=difficulty_descriptions,
                seed_questions=topic_seeds,
                num_questions=num_questions,
                debug_mode=debug_mode,
                custom_instructions=custom_instruction_for_topic # <<< USE Parameter
            )

            if debug_mode:
                print(f"  LLM generated {len(question_data_list)} raw items for '{topic}' ({target_difficulty.value}).")
                if question_data_list: print_json(question_data_list[0])

            # Store the questions
            created_questions: List[Question] = []
            for q_data in question_data_list:
                if "pack_id" not in q_data: q_data["pack_id"] = pack_id_uuid
                if "pack_topics_item" not in q_data: q_data["pack_topics_item"] = topic
                # Ensure difficulty is set based on target
                q_data["difficulty_initial"] = target_difficulty
                q_data["difficulty_current"] = target_difficulty

                question_obj = await self._create_question(q_data)
                if question_obj:
                    created_questions.append(question_obj)

            if debug_mode:
                 print(f"  Successfully created {len(created_questions)} DB questions for '{topic}' ({target_difficulty.value}).")

            return created_questions

        except Exception as e:
            logger.error(f"Error generating questions for topic '{topic}', difficulty '{target_difficulty.value}': {str(e)}", exc_info=True)
            if debug_mode:
                print(f"  ERROR generating for '{topic}' ({target_difficulty.value}): {str(e)}")
                print(traceback.format_exc())
            return []
    # --- END MODIFIED _generate_questions_for_topic_difficulty ---


    async def generate_and_store_questions(
        self,
        pack_id: str,
        pack_name: str,
        pack_topic: str,
        difficulty: DifficultyLevel,
        num_questions: int = 5,
        debug_mode: bool = False
    ) -> List[Question]:
        """
        Generate questions for a SINGLE topic and SINGLE difficulty and store them.
        Fetches topic-specific instructions internally. Reads context from Pack object.
        """
        self.debug_enabled = debug_mode
        pack_id_uuid = ensure_uuid(pack_id)

        pack_object = await self.pack_repository.get_by_id(pack_id_uuid)
        if not pack_object:
            logger.error(f"Cannot generate questions: Pack {pack_id_uuid} not found.")
            return []

        if self.debug_enabled:
            print(f"\n=== Starting Single Topic/Difficulty Question Generation (Service) ===")
            print(f"Pack ID: {pack_id_uuid}, Name: {pack_name}, Topic: {pack_topic}, Difficulty: {difficulty.value}, Count: {num_questions}")

        difficulty_config = DifficultyConfig(
            difficulty=difficulty,
            num_questions=num_questions
        )

        # --- Fetch instruction for this single topic before calling helper ---
        # (This part is now slightly redundant with the batch logic, but maintains functionality for the single endpoint)
        instruction_for_topic: Optional[str] = None
        try:
             topic_record = await self.topic_repository.get_by_name_and_pack_id(pack_topic, pack_id_uuid)
             if topic_record and topic_record.custom_instruction:
                 instruction_for_topic = topic_record.custom_instruction
        except Exception as e:
             logger.error(f"Error fetching custom instruction for single topic '{pack_topic}'", exc_info=True)
        # --- END Instruction Fetch ---


        # Use the specific helper, passing the Pack object and fetched instruction
        created_questions = await self._generate_questions_for_topic_difficulty(
            pack=pack_object,
            topic=pack_topic,
            difficulty_config=difficulty_config,
            custom_instruction_for_topic=instruction_for_topic, # <<< Pass fetched instruction
            debug_mode=debug_mode
        )
        return created_questions

    # --- MODIFIED batch_generate_and_store_questions ---
    async def batch_generate_and_store_questions(
        self,
        pack_id: str,
        pack_name: str,
        topic_configs: List[TopicQuestionConfig],
        regenerate_instructions: bool = False, # <<< ADDED parameter
        debug_mode: bool = False
    ) -> Dict[str, Any]:
        """
        Generate questions concurrently for multiple topics AND multiple difficulties.
        Also concurrently generates missing topic-specific custom instructions if needed.
        Reads context (seeds, diff descriptions) from the Pack object.
        Returns a summary dictionary including the list of created Question objects.
        """
        self.debug_enabled = debug_mode
        pack_id_uuid = ensure_uuid(pack_id)
        logger.info(f"Starting batch generation for pack {pack_id_uuid} across multiple topics/difficulties.")

        # 1. Fetch the Pack object ONCE
        pack_object = await self.pack_repository.get_by_id(pack_id_uuid)
        if not pack_object:
             logger.error(f"Cannot start batch generation: Pack {pack_id_uuid} not found.")
             return {
                 "topics_processed": [],
                 "failed_topics": [tc.topic for tc in topic_configs],
                 "total_generated": 0,
                 "generated_questions": []
             }

        if debug_mode:
            print(f"\n=== Starting Batch Question Generation (Service) ===")
            print(f"Pack ID: {pack_id_uuid}, Name: {pack_name}")
            print(f"Total Topic Configs: {len(topic_configs)}")
            print(f"Regenerate Instructions Flag: {regenerate_instructions}")
            print(f"  Pack has {len(pack_object.seed_questions)} seed questions.")
            print(f"  Pack has custom difficulty descriptions: {'Yes' if pack_object.custom_difficulty_description else 'No'}")

        # 2. Identify unique topics and check for existing instructions
        unique_topics = list({tc.topic for tc in topic_configs})
        topics_needing_instruction_gen = []
        existing_instructions_map: Dict[str, Optional[str]] = {}
        topic_check_tasks = [self.topic_repository.get_by_name_and_pack_id(topic, pack_id_uuid) for topic in unique_topics]
        topic_records = await asyncio.gather(*topic_check_tasks, return_exceptions=True)

        for i, record_or_exc in enumerate(topic_records):
            topic_name = unique_topics[i]
            if isinstance(record_or_exc, Exception):
                logger.error(f"Error checking topic '{topic_name}' existence: {record_or_exc}")
                existing_instructions_map[topic_name] = None # Treat as non-existent
                # Decide if we should attempt generation even if topic check failed? For now, yes.
                topics_needing_instruction_gen.append(topic_name)
            elif record_or_exc: # Topic record exists
                existing_instructions_map[topic_name] = record_or_exc.custom_instruction
                if regenerate_instructions or not record_or_exc.custom_instruction:
                    topics_needing_instruction_gen.append(topic_name)
            else: # Topic record does not exist (should not happen if topics were added correctly)
                logger.warning(f"Topic '{topic_name}' record not found in pack {pack_id_uuid}. Cannot fetch/generate instruction.")
                existing_instructions_map[topic_name] = None

        if debug_mode:
            print(f"  Found {len(existing_instructions_map)} unique topics in request.")
            print(f"  Existing instructions found for: {[t for t, inst in existing_instructions_map.items() if inst]}")
            print(f"  Topics identified for instruction generation ({len(topics_needing_instruction_gen)}): {topics_needing_instruction_gen}")

        # 3. Launch Concurrent Instruction Generation (if needed)
        generated_instructions_map: Dict[str, Optional[str]] = {}
        if topics_needing_instruction_gen:
            instruction_tasks = [
                self.seed_question_service.generate_custom_instructions(pack_id_uuid, topic_name)
                for topic_name in topics_needing_instruction_gen
            ]
            instruction_results = await asyncio.gather(*instruction_tasks, return_exceptions=True)

            for i, result_or_exc in enumerate(instruction_results):
                topic_name = topics_needing_instruction_gen[i]
                if isinstance(result_or_exc, Exception):
                    logger.error(f"Error generating instruction for topic '{topic_name}': {result_or_exc}")
                    generated_instructions_map[topic_name] = None
                else:
                    generated_instructions_map[topic_name] = result_or_exc # Store generated instruction (or None if failed internally)
            if debug_mode:
                 print(f"  Instruction generation tasks completed.")
                 print(f"  Successfully generated instructions for: {[t for t, inst in generated_instructions_map.items() if inst]}")
                 print(f"  Failed to generate instructions for: {[t for t, inst in generated_instructions_map.items() if inst is None]}")
        elif debug_mode:
            print("  No topics required instruction generation.")

        # 4. Create concurrent tasks for EACH topic-difficulty pair (using generated/existing instructions)
        question_gen_tasks = []
        task_metadata = []
        total_tasks = 0
        for topic_config in topic_configs:
            topic = topic_config.topic

            # Determine final instruction for this topic
            final_instruction_for_topic: Optional[str] = None
            # Priority: Request Override > Newly Generated > Pre-existing
            if topic_config.custom_instructions:
                final_instruction_for_topic = topic_config.custom_instructions
                if debug_mode: print(f"    Topic '{topic}': Using override instruction.")
            elif topic in generated_instructions_map and generated_instructions_map[topic]:
                final_instruction_for_topic = generated_instructions_map[topic]
                if debug_mode: print(f"    Topic '{topic}': Using newly generated instruction.")
            elif topic in existing_instructions_map and existing_instructions_map[topic]:
                final_instruction_for_topic = existing_instructions_map[topic]
                if debug_mode: print(f"    Topic '{topic}': Using pre-existing instruction.")
            elif debug_mode:
                 print(f"    Topic '{topic}': No instruction available or generated.")


            for difficulty_config in topic_config.difficulty_configs:
                # Pass the whole pack object and the determined instruction
                task = asyncio.create_task(
                    self._generate_questions_for_topic_difficulty(
                        pack=pack_object,
                        topic=topic,
                        difficulty_config=difficulty_config,
                        custom_instruction_for_topic=final_instruction_for_topic, # <<< PASS FINAL INSTRUCTION
                        debug_mode=debug_mode
                    ), name=f"GenerateQ_{topic}_{difficulty_config.difficulty.value}"
                )
                question_gen_tasks.append(task)
                task_metadata.append({"topic": topic, "difficulty": difficulty_config.difficulty.value})
                total_tasks += 1
        if debug_mode: print(f"  Created {total_tasks} question generation tasks.")

        # 5. Run question generation tasks concurrently and gather results
        if debug_mode: print("  Awaiting question generation task completion...")
        results_list = await asyncio.gather(*question_gen_tasks, return_exceptions=True)
        if debug_mode: print("  Question generation tasks completed.")

        # 6. Process results (Same logic as before)
        all_generated_questions: List[Question] = []
        successful_topics: set[str] = set()
        failed_configs: List[Dict[str, Any]] = []
        total_generated_count = 0
        for i, result in enumerate(results_list):
            meta = task_metadata[i]
            topic_name = meta["topic"]
            difficulty_name = meta["difficulty"]
            if isinstance(result, Exception):
                failed_configs.append({**meta, "error": str(result)})
                logger.error(f"Task for Topic '{topic_name}' ({difficulty_name}) failed: {result}", exc_info=result)
                if debug_mode: print(f"  Task '{topic_name}' ({difficulty_name}) FAILED: {result}")
            elif isinstance(result, list):
                if result:
                     all_generated_questions.extend(result)
                     total_generated_count += len(result)
                     successful_topics.add(topic_name)
                     if debug_mode: print(f"  Task '{topic_name}' ({difficulty_name}) SUCCEEDED, added {len(result)} questions.")
                else:
                     logger.warning(f"Task for Topic '{topic_name}' ({difficulty_name}) generated 0 questions.")
                     # Consider if 0 questions should count as failure for the topic
                     failed_configs.append({**meta, "error": "Generated 0 questions"})
                     if debug_mode: print(f"  Task '{topic_name}' ({difficulty_name}) completed but generated 0 questions.")
            else:
                failed_configs.append({**meta, "error": f"Unexpected return type: {type(result)}"})
                logger.error(f"Task for Topic '{topic_name}' ({difficulty_name}) returned unexpected type: {type(result)}")
                if debug_mode: print(f"  Task '{topic_name}' ({difficulty_name}) FAILED (unexpected return type: {type(result)})")

        # Determine overall status
        final_status = "completed"
        failed_topic_names = list(set(fc['topic'] for fc in failed_configs))
        if failed_configs and len(successful_topics) == 0: final_status = "failed"
        elif failed_configs: final_status = "partial_failure"

        logger.info(f"Batch generation finished. Status: {final_status}. Success Topics: {len(successful_topics)}. Failed Configs: {len(failed_configs)}. Total Questions: {total_generated_count}")
        if debug_mode:
             print(f"Batch Summary: Status={final_status}, Success Topics={len(successful_topics)}, Failed Configs={len(failed_configs)}, Total Questions={total_generated_count}")
             if failed_configs: print_json({"Failed Configs Details": failed_configs})

        return {
            "topics_processed": list(successful_topics),
            "failed_topics": failed_topic_names,
            "total_generated": total_generated_count,
            "generated_questions": all_generated_questions # Return the actual Question objects
        }
    # --- END MODIFIED batch_generate_and_store_questions ---


    # --- OTHER METHODS (Retrieval and Update - Unchanged) ---
    async def get_questions_by_pack_id(self, pack_id: str) -> List[Question]:
        """Retrieve all questions for a specific pack."""
        pack_id_uuid = ensure_uuid(pack_id)
        return await self.question_repository.get_by_pack_id(pack_id_uuid)

    async def get_questions_by_topic(self, pack_id: str, topic: str) -> List[Question]:
        """Retrieve questions for a specific pack filtered by topic."""
        pack_id_uuid = ensure_uuid(pack_id)
        all_questions = await self.question_repository.get_by_pack_id(pack_id_uuid)
        topic_lower = topic.lower()
        return [q for q in all_questions if q.pack_topics_item and q.pack_topics_item.lower() == topic_lower]

    async def update_question_statistics(
        self,
        question_id: str,
        correct: bool
    ) -> Optional[Question]:
        """Update question statistics based on user answer."""
        question_id_uuid = ensure_uuid(question_id)
        question = await self.question_repository.get_by_id(question_id_uuid)
        if not question: return None

        weight = 0.1
        current_rate = question.correct_answer_rate if question.correct_answer_rate is not None else 0.5
        new_rate = current_rate * (1 - weight) + (1.0 if correct else 0.0) * weight

        new_difficulty = self._adjust_difficulty_based_on_rate(
            question.difficulty_current,
            new_rate,
            question.difficulty_initial
        )

        update_data = QuestionUpdate(correct_answer_rate=new_rate)
        if new_difficulty != question.difficulty_current:
             update_data.difficulty_current = new_difficulty

        if update_data.model_dump(exclude_unset=True):
             return await self.question_repository.update(id=question_id_uuid, obj_in=update_data)
        else:
            return question

    def _adjust_difficulty_based_on_rate(
        self,
        current_difficulty: Optional[DifficultyLevel],
        correct_rate: float,
        initial_difficulty: Optional[DifficultyLevel]
    ) -> Optional[DifficultyLevel]:
        """Adjust difficulty based on correct answer rate."""
        EASY_UPPER = 0.90
        MEDIUM_UPPER = 0.85
        MEDIUM_LOWER = 0.40
        HARD_UPPER = 0.80
        HARD_LOWER = 0.35
        EXPERT_LOWER = 0.30

        if not current_difficulty: return None

        if current_difficulty == DifficultyLevel.EASY and correct_rate > EASY_UPPER: return DifficultyLevel.MEDIUM
        if current_difficulty == DifficultyLevel.MEDIUM and correct_rate > MEDIUM_UPPER: return DifficultyLevel.HARD
        if current_difficulty == DifficultyLevel.HARD and correct_rate > HARD_UPPER: return DifficultyLevel.EXPERT

        if current_difficulty == DifficultyLevel.MEDIUM and correct_rate < MEDIUM_LOWER: return DifficultyLevel.EASY
        if current_difficulty == DifficultyLevel.HARD and correct_rate < HARD_LOWER: return DifficultyLevel.MEDIUM
        if current_difficulty == DifficultyLevel.EXPERT and correct_rate < EXPERT_LOWER: return DifficultyLevel.HARD

        return current_difficulty
</file>

<file path="backend/src/services/seed_question_service.py">
# backend/src/services/seed_question_service.py
import logging
from typing import Dict, Optional, List

# --- UPDATED IMPORTS ---
from ..models.pack import PackUpdate # Import PackUpdate
from ..repositories.pack_repository import PackRepository # Import PackRepository
# --- END UPDATED IMPORTS ---
from ..repositories.topic_repository import TopicRepository
from ..utils.question_generation.seed_question_processor import SeedQuestionProcessor
from ..utils.question_generation.custom_instructions_creator import CustomInstructionsCreator
from ..utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

class SeedQuestionService:
    """
    Service for managing seed questions (now stored in Pack) and
    topic-specific custom instructions (stored in Topic).
    """

    def __init__(
        self,
        pack_repository: PackRepository, # <<< CHANGED: Use PackRepository
        topic_repository: TopicRepository
        ):
        """
        Initialize with required repositories.

        Args:
            pack_repository: Repository for pack operations.
            topic_repository: Repository for topic operations.
        """
        self.pack_repository = pack_repository # <<< CHANGED: Store PackRepository
        self.topic_repository = topic_repository
        self.seed_processor = SeedQuestionProcessor(llm_service=None) # Assuming LLM not needed here
        self.custom_instructions_creator = CustomInstructionsCreator()

    # --- Seed Question Methods (Now use PackRepository) ---
    async def store_seed_questions(self, pack_id: str, seed_questions: Dict[str, str]) -> bool:
        """
        Store seed questions in the packs table.

        Args:
            pack_id: ID of the pack.
            seed_questions: Dictionary of question-answer pairs.

        Returns:
            Success flag.
        """
        try:
            pack_id_uuid = ensure_uuid(pack_id)
            existing_pack = await self.pack_repository.get_by_id(pack_id_uuid)

            if existing_pack:
                update_data = PackUpdate(seed_questions=seed_questions)
                updated_pack = await self.pack_repository.update(id=existing_pack.id, obj_in=update_data)
                if updated_pack:
                    logger.info(f"Stored seed questions for pack {pack_id_uuid}")
                    return True
                else:
                    logger.error(f"Failed to update pack {pack_id_uuid} with seed questions.")
                    return False
            else:
                logger.warning(f"Cannot store seed questions: Pack with ID {pack_id_uuid} not found.")
                return False
        except Exception as e:
            logger.error(f"Error storing seed questions for pack {pack_id_uuid}: {str(e)}")
            return False

    async def get_seed_questions(self, pack_id: str) -> Dict[str, str]:
        """
        Retrieve seed questions for a pack from the packs table.

        Args:
            pack_id: ID of the pack.

        Returns:
            Dictionary of seed questions. Returns empty dict if not found or empty.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        pack = await self.pack_repository.get_by_id(pack_id_uuid)

        if pack and hasattr(pack, 'seed_questions') and isinstance(pack.seed_questions, dict):
            return pack.seed_questions
        return {}

    # --- Custom Instruction Methods (Remain largely unchanged, operate on TopicRepository) ---

    async def store_topic_custom_instruction(self, pack_id: str, topic_name: str, custom_instruction: str) -> bool:
        """
        Store custom instructions for a specific topic in the 'topics' table.

        Args:
            pack_id: ID of the pack.
            topic_name: The name of the topic.
            custom_instruction: Custom instructions for the topic.

        Returns:
            Success flag.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        try:
            # Find the topic record
            topic_record = await self.topic_repository.get_by_name_and_pack_id(topic_name, pack_id_uuid)

            if topic_record:
                # Update the instruction for the existing topic
                updated_topic = await self.topic_repository.update_custom_instruction(
                    topic_id=topic_record.id,
                    instruction=custom_instruction
                )
                if updated_topic:
                    logger.info(f"Stored custom instruction for topic '{topic_name}' in pack {pack_id_uuid}")
                    return True
                else:
                    logger.error(f"Failed to update custom instruction for topic '{topic_name}' in pack {pack_id_uuid}")
                    return False
            else:
                logger.warning(f"Topic '{topic_name}' not found in pack {pack_id_uuid}. Cannot store custom instruction.")
                return False
        except Exception as e:
            logger.error(f"Error storing custom instruction for topic '{topic_name}' in pack {pack_id_uuid}: {str(e)}")
            return False

    async def get_topic_custom_instruction(self, pack_id: str, topic_name: str) -> Optional[str]:
        """
        Retrieve custom instructions for a specific topic.

        Args:
            pack_id: ID of the pack.
            topic_name: The name of the topic.

        Returns:
            Custom instructions string or None if not found.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        try:
            topic_record = await self.topic_repository.get_by_name_and_pack_id(topic_name, pack_id_uuid)
            if topic_record:
                return topic_record.custom_instruction
            else:
                logger.debug(f"No topic record found for '{topic_name}' in pack {pack_id_uuid}")
                return None
        except Exception as e:
            logger.error(f"Error retrieving custom instruction for topic '{topic_name}' in pack {pack_id_uuid}: {str(e)}")
            return None

    async def get_all_topic_instructions(self, pack_id: str) -> Dict[str, Optional[str]]:
        """
        Retrieve all custom instructions for all topics in a pack.

        Args:
            pack_id: ID of the pack.

        Returns:
            Dictionary mapping topic names to their custom instructions.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        instructions_map = {}
        try:
            topics = await self.topic_repository.get_by_pack_id(pack_id_uuid)
            for topic in topics:
                instructions_map[topic.name] = topic.custom_instruction
            return instructions_map
        except Exception as e:
            logger.error(f"Error retrieving all topic instructions for pack {pack_id_uuid}: {e}")
            return {}

    async def generate_custom_instructions(self,
                                         pack_id: str,
                                         pack_topic: str) -> Optional[str]:
        """
        Generate and store custom instructions for a specific topic.
        Uses seed questions from the Pack object.

        Args:
            pack_id: ID of the pack.
            pack_topic: Topic to base instructions on.

        Returns:
            Generated custom instructions or None if generation/storage failed.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        try:
            # Get seed questions relevant to this topic if available (now from pack repo)
            all_seed_questions = await self.get_seed_questions(pack_id_uuid)
            # Simple filtering: check if topic name is in the question text (case-insensitive)
            topic_seeds = {q: a for q, a in all_seed_questions.items() if pack_topic.lower() in q.lower()}

            # Generate custom instructions using the creator utility
            custom_instructions = await self.custom_instructions_creator.generate_custom_instructions(
                pack_topic=pack_topic,
                seed_questions=topic_seeds # Pass potentially filtered seeds
            )

            if not custom_instructions:
                 logger.warning(f"LLM failed to generate custom instructions for topic '{pack_topic}' in pack {pack_id_uuid}")
                 return None

            # Store the generated instructions for this specific topic
            success = await self.store_topic_custom_instruction(
                pack_id=pack_id_uuid,
                topic_name=pack_topic,
                custom_instruction=custom_instructions
            )

            if success:
                return custom_instructions
            else:
                logger.warning(f"Failed to store generated custom instructions for topic '{pack_topic}' in pack {pack_id_uuid}")
                return None # Return None even if generated, if storage failed

        except Exception as e:
            logger.error(f"Error generating or storing custom instructions for topic '{pack_topic}' in pack {pack_id_uuid}: {str(e)}")
            return None
</file>

<file path="backend/src/services/topic_service.py">
# backend/src/services/topic_service.py
import logging
from typing import List, Optional

# Removed PackCreationData imports as they are no longer directly used for topics
from ..repositories.topic_repository import TopicRepository # Changed import
from ..models.topic import TopicCreate # Import the create schema
from ..utils.question_generation.pack_topic_creation import PackTopicCreation
from ..utils.llm.llm_service import LLMService
from ..utils import ensure_uuid

# Setup logger
logger = logging.getLogger(__name__)

class TopicService:
    """
    Service for managing pack topics using the dedicated 'topics' table.
    Handles creation, retrieval, and addition of topics for trivia packs.
    """

    def __init__(self, topic_repository: TopicRepository): # Changed dependency
        """
        Initialize with required repositories.

        Args:
            topic_repository: Repository for topic operations.
        """
        self.topic_repository = topic_repository # Renamed attribute
        llm_service = LLMService()
        self.topic_creator = PackTopicCreation(llm_service=llm_service)

    async def store_pack_topics(self, pack_id: str, topics: List[str]) -> List[str]:
        """
        Store topics in the 'topics' table for a specific pack.
        It tries to create each topic and handles potential duplicates based on
        the repository's logic (or unique constraint).

        Args:
            pack_id: ID of the pack.
            topics: List of topic names to store.

        Returns:
            List of topic names that were successfully stored or already existed.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        stored_topic_names = []

        for topic_name in topics:
            topic_create = TopicCreate(pack_id=pack_id_uuid, name=topic_name.strip())
            try:
                # Use the repository's create_topic method which handles checks/creation
                topic_obj = await self.topic_repository.create_topic(topic_create)
                if topic_obj:
                    stored_topic_names.append(topic_obj.name)
                else:
                    # This might happen if create_topic returns None on failure without raising
                    logger.warning(f"Failed to store topic '{topic_name}' for pack {pack_id_uuid}")
            except Exception as e:
                # Log error but continue trying to store other topics
                logger.error(f"Error storing topic '{topic_name}' for pack {pack_id_uuid}: {e}")

        return stored_topic_names

    async def get_existing_pack_topics(self, pack_id: str) -> List[str]:
        """
        Retrieve existing topic names for a pack from the 'topics' table.

        Args:
            pack_id: ID of the pack.

        Returns:
            List of existing topic names.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        try:
            topic_objects = await self.topic_repository.get_by_pack_id(pack_id_uuid)
            return [topic.name for topic in topic_objects]
        except Exception as e:
            logger.error(f"Error retrieving topics for pack {pack_id_uuid}: {e}")
            return []

    async def generate_or_use_topics(self, pack_id: str,
                                 pack_name: str, # <<< CHANGED: Expect pack_name
                                 num_topics: int = 5,
                                 predefined_topic: Optional[str] = None) -> List[str]:
        """
        Generate topics or use a predefined topic, storing them in the 'topics' table.

        Args:
            pack_id: ID of the pack.
            pack_name: The name of the trivia pack (used for generation context). # <<< CHANGED
            num_topics: Number of topics to generate (if no predefined topic).
            predefined_topic: Optional predefined topic to use instead of generation.

        Returns:
            List of topics (either generated or just the predefined one) successfully stored.
        """
        pack_id_uuid = ensure_uuid(pack_id)
        topic_names_to_store = []

        if predefined_topic:
            topic_names_to_store = [predefined_topic.strip()]
            logger.info(f"Using predefined topic for pack {pack_id_uuid}: {predefined_topic}")
        else:
            logger.info(f"Generating {num_topics} topics for pack {pack_id_uuid} ('{pack_name}')") # <<< CHANGED
            # Generate topic names using LLM
            topic_names_to_store = await self.topic_creator.create_pack_topics(
                pack_name=pack_name, # <<< CHANGED: Pass pack_name
                num_topics=num_topics
            )

        # Store the generated/predefined topic names
        if topic_names_to_store:
            stored_topics = await self.store_pack_topics(pack_id_uuid, topic_names_to_store)
            return stored_topics
        else:
            logger.warning(f"No topics to store for pack {pack_id_uuid}.")
            return []

    async def add_additional_topics(self, pack_id: str,
                                  pack_name: str, # <<< CHANGED: Expect pack_name
                                  num_additional_topics: int = 3,
                                  predefined_topic: Optional[str] = None) -> List[str]:
        """
        Add additional topics to an existing pack, storing them in the 'topics' table.

        Args:
            pack_id: ID of the pack.
            pack_name: The name of the trivia pack (used for generation context). # <<< CHANGED
            num_additional_topics: Number of new topics to generate/add.
            predefined_topic: Optional predefined topic to add directly.

        Returns:
            Full list of topic names for the pack after additions.
        """
        pack_id_uuid = ensure_uuid(pack_id)

        # Get existing topic names first
        existing_topic_names = await self.get_existing_pack_topics(pack_id_uuid)
        new_topic_names_to_store = []

        if predefined_topic:
            cleaned_topic = predefined_topic.strip()
            if cleaned_topic not in existing_topic_names:
                new_topic_names_to_store.append(cleaned_topic)
                logger.info(f"Adding predefined additional topic: {cleaned_topic}")
            else:
                logger.warning(f"Predefined topic '{cleaned_topic}' already exists. Not adding.")
        else:
            # Generate additional topic names, avoiding existing ones
            logger.info(f"Generating {num_additional_topics} additional topics for pack {pack_id_uuid}")
            new_topic_names_to_store = await self.topic_creator.create_additional_topics(
                existing_topics=existing_topic_names,
                pack_name=pack_name, # <<< CHANGED: Pass pack_name
                num_additional_topics=num_additional_topics
            )

        # Store the newly generated/added topic names
        if new_topic_names_to_store:
            await self.store_pack_topics(pack_id_uuid, new_topic_names_to_store)
        else:
            logger.info(f"No new topics generated or provided to add for pack {pack_id_uuid}.")

        # Return the full updated list of topic names for the pack
        return await self.get_existing_pack_topics(pack_id_uuid)
</file>

<file path="backend/src/services/user_service.py">
# backend/src/services/user_service.py
"""
Service for user management operations.

This module provides business logic for user creation, authentication,
and profile management, including broadcasting updates via WebSockets.
"""
import logging
import traceback
from typing import Optional, Tuple, Dict, Any, List

from ..models.user import User, UserCreate, UserUpdate
from ..models.game_session import GameStatus
from ..repositories.user_repository import UserRepository
from ..repositories.game_participant_repository import GameParticipantRepository
from ..repositories.game_session_repository import GameSessionRepository
from ..models.game_participant import GameParticipantUpdate

# --- WebSocket Integration ---
from ..websocket_manager import ConnectionManager
# --- End WebSocket Integration ---

from ..utils import ensure_uuid

# Configure logger
logger = logging.getLogger(__name__)

class UserService:
    """
    Service for user management operations.

    Handles business logic related to creating, retrieving, updating,
    and authenticating users. Propagates display name changes to games
    via database updates and WebSocket broadcasts.
    """

    # --- MODIFIED __init__ ---
    def __init__(
        self,
        user_repository: UserRepository,
        game_participant_repository: GameParticipantRepository,
        game_session_repository: GameSessionRepository,
        connection_manager: ConnectionManager # <<< ADDED
    ):
        """
        Initialize the service with required repositories and connection manager.
        """
        self.user_repository = user_repository
        self.game_participant_repository = game_participant_repository
        self.game_session_repository = game_session_repository
        self.connection_manager = connection_manager # <<< ADDED
    # --- END MODIFIED __init__ ---

    async def create_user(
        self,
        displayname: Optional[str] = None,
        email: Optional[str] = None,
        is_temporary: bool = False,
        auth_provider: Optional[str] = None,
        auth_id: Optional[str] = None
    ) -> User:
        """
        Create a new user. (No changes needed here for WS)
        """
        try:
            if email:
                existing_user = await self.user_repository.get_by_email(email)
                if existing_user:
                    logger.warning(f"User with email {email} already exists")
                    raise ValueError(f"User with email {email} already exists")

            user_data = UserCreate(
                displayname=displayname, email=email, is_temporary=is_temporary,
                auth_provider=auth_provider, auth_id=auth_id
            )
            user = await self.user_repository.create(obj_in=user_data)
            logger.info(f"Created new user with ID: {user.id}")
            return user

        except ValueError: raise
        except Exception as e: logger.error(f"Error creating user: {str(e)}"); logger.error(traceback.format_exc()); raise

    async def get_user(self, user_id: str) -> Optional[User]:
        """ Get a user by ID. (No changes needed here) """
        try:
            user_id_str = ensure_uuid(user_id)
            return await self.user_repository.get_by_id(user_id_str)
        except Exception as e: logger.error(f"Error retrieving user {user_id}: {str(e)}"); logger.error(traceback.format_exc()); raise

    # --- MODIFIED update_user ---
    async def update_user(
        self,
        user_id: str,
        displayname: Optional[str] = None,
        email: Optional[str] = None,
        is_temporary: Optional[bool] = None,
        auth_provider: Optional[str] = None,
        auth_id: Optional[str] = None
    ) -> Optional[User]:
        """
        Update a user and propagate display name changes via DB and WebSockets.
        """
        updated_user_record: Optional[User] = None
        name_changed = False
        new_display_name: Optional[str] = None

        try:
            user_id_str = ensure_uuid(user_id)
            user = await self.user_repository.get_by_id(user_id_str)
            if not user: logger.warning(f"User with ID {user_id_str} not found for update"); return None

            if email and email != user.email:
                existing_email_user = await self.user_repository.get_by_email(email)
                if existing_email_user and existing_email_user.id != user_id_str:
                    raise ValueError(f"Email {email} already in use by another user")

            update_data_dict = {}
            if displayname is not None and displayname != user.displayname:
                update_data_dict['displayname'] = displayname
                name_changed = True
                new_display_name = displayname
            if email is not None and email != user.email: update_data_dict['email'] = email
            if is_temporary is not None and is_temporary != user.is_temporary: update_data_dict['is_temporary'] = is_temporary
            if auth_provider is not None and auth_provider != user.auth_provider: update_data_dict['auth_provider'] = auth_provider
            if auth_id is not None and auth_id != user.auth_id: update_data_dict['auth_id'] = auth_id

            if not update_data_dict:
                logger.info(f"No fields to update for user {user_id_str}")
                updated_user_record = user # Return the original if no DB update needed
            else:
                update_data = UserUpdate(**update_data_dict)
                updated_user_record = await self.user_repository.update(id=user_id_str, obj_in=update_data)
                if updated_user_record: logger.info(f"Updated user record for ID: {user_id_str}")
                else: logger.error(f"Failed to update user record for ID: {user_id_str}"); return None

            # --- Propagate display name change ---
            if name_changed and new_display_name is not None:
                logger.info(f"Propagating name change '{new_display_name}' for user {user_id_str}")
                await self._propagate_name_change(user_id_str, new_display_name)

            return updated_user_record

        except ValueError: raise
        except Exception as e: logger.error(f"Error updating user {user_id_str}: {str(e)}"); logger.error(traceback.format_exc()); raise
    # --- END MODIFIED update_user ---

    # --- NEW Helper Method: _propagate_name_change ---
    async def _propagate_name_change(self, user_id: str, new_display_name: str):
        """Propagates name change to active/pending games via DB and WebSocket."""
        try:
            participant_records = await self.game_participant_repository.get_user_active_games(user_id)
            game_ids_to_notify: List[str] = []
            update_tasks = []

            for participant in participant_records:
                # Check game status before updating participant record
                game_session = await self.game_session_repository.get_by_id(participant.game_session_id)
                if game_session and game_session.status in [GameStatus.PENDING, GameStatus.ACTIVE]:
                    if participant.display_name != new_display_name:
                        # Schedule DB update
                        participant_update_payload = GameParticipantUpdate(display_name=new_display_name) # type: ignore[call-arg]
                        update_tasks.append(
                           asyncio.create_task(self.game_participant_repository.update(id=participant.id, obj_in=participant_update_payload))
                        )
                        if participant.game_session_id not in game_ids_to_notify:
                           game_ids_to_notify.append(participant.game_session_id)
                    # Include game ID even if DB name was already correct, in case WS connection state is different
                    elif participant.game_session_id not in game_ids_to_notify:
                         game_ids_to_notify.append(participant.game_session_id)

            # Execute DB updates concurrently
            db_update_results = await asyncio.gather(*update_tasks, return_exceptions=True)
            failed_db_updates = [res for res in db_update_results if isinstance(res, Exception) or res is None]
            if failed_db_updates: logger.warning(f"Failed {len(failed_db_updates)} participant DB name updates for user {user_id}.")

            # Broadcast WebSocket update to relevant game rooms
            if game_ids_to_notify:
                message = {
                    "type": "user_name_updated",
                    "payload": {"user_id": user_id, "new_display_name": new_display_name}
                }
                broadcast_tasks = [self.connection_manager.broadcast(message, game_id) for game_id in game_ids_to_notify]
                await asyncio.gather(*broadcast_tasks, return_exceptions=True) # Log errors within broadcast
                logger.info(f"Broadcasted name update for user {user_id} to {len(game_ids_to_notify)} games.")

        except Exception as propagation_error:
            logger.error(f"Error propagating name change for user {user_id}: {propagation_error}", exc_info=True)
    # --- END NEW Helper Method ---

    async def delete_user(self, user_id: str) -> Optional[User]:
        """ Delete a user. (No changes needed here) """
        try:
            user_id_str = ensure_uuid(user_id)
            deleted_user = await self.user_repository.delete(id=user_id_str)
            if deleted_user: logger.info(f"Deleted user with ID: {user_id_str}")
            else: logger.warning(f"User with ID {user_id_str} not found for deletion")
            return deleted_user
        except Exception as e: logger.error(f"Error deleting user {user_id_str}: {str(e)}"); logger.error(traceback.format_exc()); raise

    async def get_user_by_email(self, email: str) -> Optional[User]:
        """ Get a user by email address. (No changes needed here) """
        try: return await self.user_repository.get_by_email(email)
        except Exception as e: logger.error(f"Error retrieving user by email {email}: {str(e)}"); logger.error(traceback.format_exc()); raise

    async def get_or_create_user_by_auth(
        self, auth_provider: str, auth_id: str, email: Optional[str] = None,
        displayname: Optional[str] = None, is_temporary: bool = False
    ) -> Tuple[User, bool]:
        """ Get/Create user by auth details. (No changes needed here) """
        try:
            user = await self.user_repository.get_by_auth_details(auth_provider, auth_id)
            if user: return user, False
            new_user = await self.create_user(displayname=displayname, email=email, is_temporary=is_temporary, auth_provider=auth_provider, auth_id=auth_id)
            return new_user, True
        except Exception as e: logger.error(f"Error in get_or_create_user_by_auth: {str(e)}"); logger.error(traceback.format_exc()); raise

    async def convert_temporary_user(
        self, user_id: str, displayname: str, email: Optional[str] = None,
        auth_provider: Optional[str] = None, auth_id: Optional[str] = None
    ) -> Optional[User]:
        """ Convert temporary user. (No changes needed here, calls updated `update_user`) """
        try:
            user_id_str = ensure_uuid(user_id)
            user = await self.user_repository.get_by_id(user_id_str)
            if not user: logger.warning(f"User with ID {user_id_str} not found for conversion"); return None
            if not user.is_temporary: raise ValueError(f"User with ID {user_id_str} is not a temporary user")
            # Update call will now handle propagation
            updated_user = await self.update_user( user_id=user_id_str, displayname=displayname, email=email, is_temporary=False, auth_provider=auth_provider, auth_id=auth_id )
            if updated_user: logger.info(f"Converted temporary user {user_id_str} to permanent account")
            return updated_user
        except ValueError: raise
        except Exception as e: logger.error(f"Error converting temporary user {user_id_str}: {str(e)}"); logger.error(traceback.format_exc()); raise
</file>

<file path="backend/src/utils/document_processing/__init__.py">
# backend/src/utils/document_processing/__init__.py
"""
Document processing utilities for handling various file types and extracting information.

This package provides utilities for parsing, extracting, and processing documents
of different formats, such as PDF, CSV, JSON, and plain text files.
"""

from .processors import clean_text, normalize_text, split_into_chunks, detect_language

__all__ = [
    # Processors
    "clean_text",
    "normalize_text", 
    "split_into_chunks",
    "detect_language",
]
</file>

<file path="backend/src/utils/document_processing/processors.py">
# backend/src/utils/document_processing/processors.py
"""
Document content processing utilities.

This module provides functions for cleaning, normalizing, and processing
text extracted from documents.
"""

import re
import unicodedata
from typing import List, Dict, Any, Optional, Union
import logging

# Configure logging
logger = logging.getLogger(__name__)

def clean_text(text: str, 
              remove_extra_whitespace: bool = True,
              remove_urls: bool = False,
              remove_emails: bool = False,
              remove_special_chars: bool = False) -> str:
    """
    Clean text by removing unwanted elements.
    
    Args:
        text: Input text to clean
        remove_extra_whitespace: Whether to collapse multiple whitespaces
        remove_urls: Whether to remove URLs
        remove_emails: Whether to remove email addresses
        remove_special_chars: Whether to remove special characters
        
    Returns:
        Cleaned text
    """
    if not text:
        return ""
    
    # Remove URLs if requested
    if remove_urls:
        text = re.sub(r'https?://\S+', '', text)
    
    # Remove emails if requested
    if remove_emails:
        text = re.sub(r'\S+@\S+', '', text)
    
    # Remove special characters if requested
    if remove_special_chars:
        text = re.sub(r'[^\w\s]', '', text)
    
    # Remove extra whitespace if requested
    if remove_extra_whitespace:
        # Replace newlines, tabs, and multiple spaces with a single space
        text = re.sub(r'\s+', ' ', text)
        # Trim leading/trailing whitespace
        text = text.strip()
    
    return text

def normalize_text(text: str,
                  lowercase: bool = True,
                  remove_accents: bool = False,
                  normalize_whitespace: bool = True) -> str:
    """
    Normalize text for consistent processing.
    
    Args:
        text: Input text to normalize
        lowercase: Whether to convert to lowercase
        remove_accents: Whether to remove accents from characters
        normalize_whitespace: Whether to normalize whitespace
        
    Returns:
        Normalized text
    """
    if not text:
        return ""
    
    # Convert to lowercase if requested
    if lowercase:
        text = text.lower()
    
    # Remove accents if requested
    if remove_accents:
        text = unicodedata.normalize('NFKD', text)
        text = ''.join([c for c in text if not unicodedata.combining(c)])
    
    # Normalize whitespace if requested
    if normalize_whitespace:
        # Replace tabs, newlines, and multiple spaces with a single space
        text = re.sub(r'\s+', ' ', text)
        # Trim leading/trailing whitespace
        text = text.strip()
    
    return text

def split_into_chunks(text: str,
                     chunk_size: int = 1000,
                     overlap: int = 100,
                     respect_sentences: bool = True) -> List[str]:
    """
    Split a long text into smaller overlapping chunks.
    
    Args:
        text: Input text to split
        chunk_size: Maximum size of each chunk in characters
        overlap: Number of characters to overlap between chunks
        respect_sentences: Whether to try to break at sentence boundaries
        
    Returns:
        List of text chunks
    """
    if not text:
        return []
    
    # If text is shorter than chunk_size, return it as a single chunk
    if len(text) <= chunk_size:
        return [text]
    
    chunks = []
    start = 0
    
    while start < len(text):
        # Calculate end position for this chunk
        end = start + chunk_size
        
        # If we're at the end of the text, just add the final chunk
        if end >= len(text):
            chunks.append(text[start:])
            break
        
        # If we should respect sentence boundaries, try to find a sentence end
        if respect_sentences:
            # Look for sentence-ending punctuation followed by space or newline
            sentence_end = -1
            for pattern in [r'\.[\s\n]', r'![\s\n]', r'\?[\s\n]', r'\."\s', r'!"\s', r'\?"\s']:
                matches = list(re.finditer(pattern, text[start:end + overlap]))
                if matches:
                    # Get the position of the last match
                    last_match = matches[-1]
                    # Add 1 to include the punctuation but not the space
                    sentence_end = start + last_match.start() + 1
            
            if sentence_end > start:
                # We found a sentence boundary
                chunks.append(text[start:sentence_end + 1])
                start = sentence_end + 1
                continue
        
        # If we couldn't find a sentence boundary or aren't respecting them,
        # look for the last space within the overlap region
        if end < len(text):
            # Look for the last space in the overlap region
            last_space = text.rfind(' ', end - overlap, end + overlap)
            
            if last_space > start:
                # We found a space to break at
                chunks.append(text[start:last_space])
                start = last_space + 1
                continue
        
        # If we couldn't find a good break point, just break at chunk_size
        chunks.append(text[start:end])
        start = end
    
    return chunks

def detect_language(text: str) -> str:
    """
    Detect the language of a text.
    
    Args:
        text: Input text to analyze
        
    Returns:
        ISO 639-1 language code (2 letters)
        
    Note:
        This is a placeholder. A real implementation would use a language
        detection library like langdetect or a more comprehensive approach.
    """
    # In a real implementation, you would use a language detection library
    # For example:
    # from langdetect import detect
</file>

<file path="backend/src/utils/llm/__init__.py">
# backend/src/utils/llm/__init__.py
"""
LLM service module for interacting with Language Model APIs.

This package provides services and utilities for working with
various LLM providers (OpenAI, Anthropic, Gemini) and processing
their outputs.
"""

from .llm_service import LLMService
from .llm_parsing_utils import (
    LLMParsingUtils,
    extract_bullet_list,
    parse_json_from_llm,
    format_as_bullet_list,
    extract_key_value_pairs,
    detect_and_parse_format
)
from .llm_json_repair import (
    LLMJsonRepair,
    repair_json,
    repair_and_parse
)

__all__ = [
    "LLMService",
    "LLMParsingUtils",
    "extract_bullet_list",
    "parse_json_from_llm",
    "format_as_bullet_list",
    "extract_key_value_pairs",
    "detect_and_parse_format",
    "LLMJsonRepair",
    "repair_json",
    "repair_and_parse",
]
</file>

<file path="backend/src/utils/llm/llm_json_repair.py">
# backend/src/utils/llm/llm_json_repair.py
"""
Utility for repairing malformed JSON outputs from LLMs using LLM itself.

This module leverages LLMs to fix structural issues in JSON that
rule-based approaches might fail to address.
"""

import json
import logging
import re
from typing import Any, Dict, List, Optional, Union

from .llm_service import LLMService
from ..document_processing.processors import clean_text

# Configure logger
logger = logging.getLogger(__name__)


class LLMJsonRepair:
    """
    Service for repairing malformed JSON using LLM capabilities.
    
    This class provides methods to fix common JSON issues by
    leveraging LLM's understanding of JSON structure.
    """
    
    def __init__(self, llm_service: Optional[LLMService] = None):
        """
        Initialize the JSON repair service.
        
        Args:
            llm_service: Service for LLM interactions. If None, creates a new instance.
        """
        self.llm_service = llm_service or LLMService()
    
    async def repair_json(self, malformed_json: str, json_type: str = "auto") -> str:
        """
        Repair malformed JSON using an LLM.
        
        Args:
            malformed_json: The malformed JSON string to repair
            json_type: Type of JSON structure expected ("object", "array", or "auto" for automatic detection)
            
        Returns:
            Repaired JSON string
        """
        # Detect JSON type if not specified
        if json_type == "auto":
            json_type = self._detect_json_type(malformed_json)
        
        # Create a prompt based on the JSON type
        prompt = self._create_repair_prompt(malformed_json, json_type)
        
        try:
            # Use LLM to generate a fixed version
            raw_response = self.llm_service.generate_content(
                prompt=prompt,
                temperature=0.2,  # Lower temperature for more deterministic output
                max_tokens=3000   # Ensure enough tokens for the repaired JSON
            )
            
            # Process and validate the response
            repaired_json = self._extract_json_from_response(raw_response)
            
            # Try to validate the result is proper JSON
            try:
                json.loads(repaired_json)
                logger.info("Successfully repaired JSON with LLM")
                return repaired_json
            except json.JSONDecodeError as e:
                logger.warning(f"LLM repair returned invalid JSON: {str(e)}")
                # Attempt second-level repair with more explicit instructions
                return await self._fallback_repair(repaired_json, json_type, str(e))
                
        except Exception as e:
            logger.error(f"Error repairing JSON with LLM: {str(e)}")
            # Return the original JSON if repair failed
            return malformed_json
    
    async def repair_and_parse(self, malformed_json: str, default_value: Any = None) -> Any:
        """
        Repair malformed JSON and parse it into a Python object.
        
        Args:
            malformed_json: The malformed JSON string to repair
            default_value: Default value to return if repair and parsing fails
            
        Returns:
            Parsed Python object (dict, list, etc.) or default_value if repair fails
        """
        # Try to parse directly first
        try:
            return json.loads(malformed_json)
        except json.JSONDecodeError:
            # If parsing fails, try to repair with LLM
            repaired_json = await self.repair_json(malformed_json)
            
            # Try to parse the repaired JSON
            try:
                return json.loads(repaired_json)
            except json.JSONDecodeError:
                logger.error("Failed to parse JSON even after LLM repair")
                return default_value
    
    def _detect_json_type(self, json_str: str) -> str:
        """
        Detect the type of JSON structure (object or array).
        
        Args:
            json_str: JSON string to analyze
            
        Returns:
            "object", "array", or "unknown"
        """
        # Clean and normalize the string
        cleaned = json_str.strip()
        
        # Check for array structure
        if cleaned.startswith('[') or re.search(r'\[\s*{', cleaned):
            return "array"
        # Check for object structure
        elif cleaned.startswith('{') or re.search(r'{\s*"', cleaned):
            return "object"
        # Check for items that look like they should be in an array
        elif re.search(r'{\s*".*":', cleaned) and ',' in cleaned:
            return "array"
        else:
            return "unknown"
    
    def _create_repair_prompt(self, malformed_json: str, json_type: str) -> str:
        """
        Create a prompt for the LLM to repair the JSON.
        
        Args:
            malformed_json: The malformed JSON string
            json_type: Type of JSON structure expected
            
        Returns:
            Formatted prompt for LLM
        """
        # Base prompt template
        base_prompt = f"""You are a JSON repair expert. I have a malformed or incomplete JSON that needs to be fixed.

The JSON is supposed to be a valid JSON {json_type}. Fix all structural issues, syntax errors, and incomplete elements while maintaing as much existing data as possible.  
If dealing with truncated data, it is fine to remove the object related to the truncated part.

Here is the malformed JSON:
```
{malformed_json}
```

Provide ONLY the correctly formatted JSON with no explanations or markdown formatting. Do not use ```json or ``` tags.
"""
        
        # Add specific instructions based on JSON type
        if json_type == "array":
            base_prompt += "\nMake sure the output is a valid JSON array with properly formatted objects, valid commas, and balanced brackets."
        elif json_type == "object":
            base_prompt += "\nMake sure the output is a valid JSON object with proper key-value pairs, quotes around keys, valid commas, and balanced braces."
        
        return base_prompt
    
    async def _fallback_repair(self, json_str: str, json_type: str, error_message: str) -> str:
        """
        Fallback repair method with more explicit instructions about the error.
        
        Args:
            json_str: The JSON string that failed first repair attempt
            json_type: Type of JSON structure expected
            error_message: The error message from the JSON parser
            
        Returns:
            Repaired JSON string
        """
        # Create a more detailed prompt with specific error information
        prompt = f"""You are a JSON repair expert. The JSON I provided earlier is still invalid after one repair attempt.

The specific JSON error is: {error_message}

The JSON should be a valid {json_type}. Fix ONLY the structural issues causing this error.
Do not change any content unless absolutely necessary to make it valid JSON, however if dealing with truncated data - you can remove the truncated part

Here is the JSON to fix:
```
{json_str}
```

Return ONLY the fixed JSON with no explanation or markdown. Return it exactly as it should be parsed.
"""
        
        try:
            # Use LLM to generate a fixed version with lower temperature for precision
            raw_response = self.llm_service.generate_content(
                prompt=prompt,
                temperature=0.1,
                max_tokens=3000
            )
            
            return self._extract_json_from_response(raw_response)
            
        except Exception as e:
            logger.error(f"Error in fallback JSON repair: {str(e)}")
            # Return the input JSON if fallback fails
            return json_str
    
    def _extract_json_from_response(self, response: str) -> str:
        """
        Extract JSON from LLM response, handling potential markdown or explanation text.
        
        Args:
            response: Raw LLM response
            
        Returns:
            Extracted JSON string
        """
        # Try to extract JSON from code blocks first
        code_block_pattern = r"```(?:json)?\s*([\s\S]*?)\s*```"
        code_blocks = re.findall(code_block_pattern, response)
        
        if code_blocks:
            return code_blocks[0].strip()
        
        # If no code blocks, try to find JSON by brackets
        # For objects
        if '{' in response and '}' in response:
            object_start = response.find('{')
            object_end = response.rfind('}')
            if object_start < object_end:
                return response[object_start:object_end+1].strip()
        
        # For arrays
        if '[' in response and ']' in response:
            array_start = response.find('[')
            array_end = response.rfind(']')
            if array_start < array_end:
                return response[array_start:array_end+1].strip()
        
        # If no clear JSON structure is found, return the cleaned response
        return clean_text(response)


# Standalone helper functions for direct use
async def repair_json(malformed_json: str, json_type: str = "auto", llm_service: Optional[LLMService] = None) -> str:
    """
    Repair malformed JSON using an LLM.
    
    Args:
        malformed_json: The malformed JSON string to repair
        json_type: Type of JSON structure expected ("object", "array", or "auto")
        llm_service: Optional LLMService instance for LLM interaction
        
    Returns:
        Repaired JSON string
    """
    repair_service = LLMJsonRepair(llm_service)
    return await repair_service.repair_json(malformed_json, json_type)


async def repair_and_parse(malformed_json: str, default_value: Any = None, llm_service: Optional[LLMService] = None) -> Any:
    """
    Repair malformed JSON and parse it into a Python object.
    
    Args:
        malformed_json: The malformed JSON string to repair
        default_value: Default value to return if repair and parsing fails
        llm_service: Optional LLMService instance for LLM interaction
        
    Returns:
        Parsed Python object (dict, list, etc.) or default_value if repair fails
    """
    repair_service = LLMJsonRepair(llm_service)
    return await repair_service.repair_and_parse(malformed_json, default_value)
</file>

<file path="backend/src/utils/llm/llm_parsing_utils.py">
# backend/src/utils/llm/llm_parsing_utils.py
"""
Utilities for parsing and processing outputs from LLM responses.

This module provides specialized functions to extract structured data
from LLM outputs and convert between various formats.
"""

import json
import re
import logging
import asyncio
from typing import List, Dict, Any, Optional, Union, Tuple

from ..document_processing.processors import clean_text, normalize_text
from .llm_json_repair import repair_and_parse

# Configure logger
logger = logging.getLogger(__name__)

class LLMParsingUtils:
    """
    Utilities for parsing and processing LLM outputs into structured formats.
    """
    
    @staticmethod
    def extract_bullet_list(text: str) -> List[str]:
        """
        Extract a bullet-pointed list from LLM text output.
        
        Args:
            text: Raw text containing bullet points
            
        Returns:
            List of extracted bullet point items
        """
        # Find all bullet points with various bullet characters
        bullet_pattern = r'(?:^|\n)\s*(?:|\*|-|||\d+\.)\s*(.+?)(?=$|\n)'
        matches = re.findall(bullet_pattern, text, re.MULTILINE)
        
        # Clean up each item
        items = []
        for match in matches:
            # Strip whitespace and remove any quotes
            cleaned = match.strip().strip('"\'')
            if cleaned:  # Only add non-empty items
                items.append(cleaned)
                
        return items
    
    @staticmethod
    def extract_numbered_list(text: str) -> List[Dict[str, Any]]:
        """
        Extract a numbered list with potential descriptions.
        
        Args:
            text: Raw text containing numbered items
            
        Returns:
            List of dictionaries with 'number' and 'content' keys
        """
        # Pattern to match numbered items: digit(s) + delimiter + content
        numbered_pattern = r'(?:^|\n)\s*(\d+)[.:\)]\s*(.+?)(?=$|\n)'
        matches = re.findall(numbered_pattern, text, re.MULTILINE)
        
        numbered_items = []
        for number, content in matches:
            cleaned_content = content.strip()
            if cleaned_content:
                numbered_items.append({
                    'number': int(number),
                    'content': cleaned_content
                })
        
        return numbered_items
    
    @staticmethod
    def extract_key_value_pairs(text: str, delimiter: str = ':') -> Dict[str, str]:
        """
        Extract key-value pairs from text.
        
        Args:
            text: Text containing key-value pairs
            delimiter: Character separating keys from values
            
        Returns:
            Dictionary of key-value pairs
        """
        pairs = {}
        
        # Split by lines and extract key-value pairs
        lines = text.strip().split('\n')
        for line in lines:
            line = line.strip()
            if delimiter in line:
                # Split on first occurrence of delimiter
                parts = line.split(delimiter, 1)
                if len(parts) == 2:
                    key = parts[0].strip()
                    value = parts[1].strip()
                    
                    # Remove quotes if present
                    key = key.strip('"\'')
                    value = value.strip('"\'')
                    
                    if key:
                        pairs[key] = value
        
        return pairs
    
    @staticmethod
    def extract_json_from_response(response_text: str) -> str:
        """
        Extract JSON content from a potentially mixed text response.
        
        Args:
            response_text: Raw response from LLM
            
        Returns:
            Cleaned JSON string
        """
        # Remove leading/trailing whitespace
        response_text = response_text.strip()
        
        # Check if the response is already valid JSON
        try:
            json.loads(response_text)
            return response_text
        except json.JSONDecodeError:
            pass  # Not valid JSON, continue with extraction
        
        # Try to extract JSON from markdown code blocks
        code_block_pattern = r"```(?:json)?\s*([\s\S]*?)\s*```"
        code_blocks = re.findall(code_block_pattern, response_text)
        
        if code_blocks:
            # Try each extracted code block
            for block in code_blocks:
                try:
                    json.loads(block)
                    return block  # Return the first valid JSON block
                except json.JSONDecodeError:
                    continue  # Try next block if this one isn't valid
        
        # If no code blocks with valid JSON, look for array/object patterns
        # Find the first [ and last ]
        array_start = response_text.find("[")
        array_end = response_text.rfind("]")
        
        if array_start != -1 and array_end != -1 and array_start < array_end:
            potential_json = response_text[array_start:array_end+1]
            try:
                json.loads(potential_json)
                return potential_json
            except json.JSONDecodeError:
                pass  # Not valid JSON, continue with other methods
        
        # Find the first { and last }
        object_start = response_text.find("{")
        object_end = response_text.rfind("}")
        
        if object_start != -1 and object_end != -1 and object_start < object_end:
            potential_json = response_text[object_start:object_end+1]
            try:
                json.loads(potential_json)
                return potential_json
            except json.JSONDecodeError:
                pass  # Not valid JSON, continue with other methods
        
        # If all else fails, return the original text for further processing
        return response_text
    
    @staticmethod
    def handle_truncated_json_array(json_str: str) -> str:
        """
        Handles truncated JSON arrays by finding the last complete item.
        
        Args:
            json_str: Potentially truncated JSON string
            
        Returns:
            Fixed JSON string
        """
        # If it's already valid, return as is
        try:
            json.loads(json_str)
            return json_str
        except json.JSONDecodeError:
            pass  # Not valid JSON, try to fix
        
        # Check if it's an array format
        if not (json_str.strip().startswith('[') and (']' not in json_str or  # Completely missing closing bracket
               json_str.strip().startswith('[') and ']' in json_str)):  # Has at least one closing bracket
            # Not an array, can't use this method
            return json_str
        
        try:
            # Find the last complete object by finding all complete items
            items = []
            depth = 0
            item_start = 1  # Skip initial '['
            in_string = False
            escape_char = False
            item_complete = False
            
            # For completely truncated arrays (no closing bracket)
            if ']' not in json_str:
                json_str = json_str + "]"  # Add a closing bracket for processing
            
            for i, char in enumerate(json_str[1:], 1):  # Skip initial '['
                # Handle string quotes and escaping
                if char == '"' and not escape_char:
                    in_string = not in_string
                elif char == '\\' and in_string and not escape_char:
                    escape_char = True
                    continue
                
                # Reset escape flag
                escape_char = False
                
                # Only count brackets when not inside a string
                if not in_string:
                    if char == '{' or char == '[':
                        depth += 1
                    elif char == '}' or char == ']':
                        depth -= 1
                        # If we just closed an object at the top level, mark it as complete
                        if depth == 0 and char == '}':
                            item_complete = True
                
                # Check if we have a complete item at the top level
                if depth == 0 and char == ',':
                    if item_complete:
                        item_end = i
                        items.append(json_str[item_start:item_end].strip())
                        item_start = i + 1
                        item_complete = False
                elif depth == -1 and char == ']':  # End of array
                    if item_complete:
                        item_end = i
                        if item_start < item_end:
                            # There's content before the closing bracket
                            items.append(json_str[item_start:item_end].strip())
                    break
            
            # If we found complete items, rebuild the array
            if items:
                return "[" + ",".join(items) + "]"
            
            # If we couldn't parse it this way, return original
            return json_str
            
        except Exception as e:
            logger.warning(f"Error handling truncated JSON: {e}")
            return json_str
    
    @staticmethod
    def recover_items_from_truncated_array(json_str: str) -> List[Any]:
        """
        Recover complete objects from a truncated JSON array by parsing each item separately.
        Enhanced to be more resilient to different types of truncation.
        
        Args:
            json_str: Potentially truncated JSON array string
            
        Returns:
            List of successfully parsed items
        """
        # Verify it's an array and extract content
        if not json_str.strip().startswith('['):
            return []
        
        recovered_items = []
        
        # Remove the opening bracket and any potential closing bracket
        content = json_str.strip()[1:]
        if content.endswith(']'):
            content = content[:-1]
            
        # Split by commas, but only at the top level (not inside objects or arrays)
        depth = 0
        in_string = False
        escape_char = False
        item_boundaries = []
        current_start = 0
        
        # First pass: find boundaries of items at top level
        for i, char in enumerate(content):
            # Handle string quotes and escaping
            if char == '"' and not escape_char:
                in_string = not in_string
            elif char == '\\' and in_string:
                escape_char = True
                continue
            else:
                escape_char = False
            
            # Track nested objects/arrays when not in a string
            if not in_string:
                if char in '{[':
                    depth += 1
                elif char in '}]':
                    depth -= 1
            
            # If at top level and found comma, this is an item boundary
            if depth == 0 and char == ',' and not in_string:
                item_boundaries.append((current_start, i))
                current_start = i + 1
        
        # Add the last item boundary
        if current_start < len(content):
            item_boundaries.append((current_start, len(content)))
        
        # Second pass: process each item using the boundaries
        for start, end in item_boundaries:
            item_json = content[start:end].strip()
            
            # Enhanced check for complete JSON objects
            if (item_json.startswith('{') and item_json.endswith('}')) or \
               (item_json.startswith('[') and item_json.endswith(']')):
                try:
                    item = json.loads(item_json)
                    recovered_items.append(item)
                except json.JSONDecodeError:
                    # Try to fix common JSON issues in the item
                    fixed_item = LLMParsingUtils.sanitize_json(item_json)
                    try:
                        item = json.loads(fixed_item)
                        recovered_items.append(item)
                    except json.JSONDecodeError:
                        # Skip invalid items after cleanup attempt
                        pass
            else:
                # For partially complete objects (e.g., missing closing brace)
                if item_json.startswith('{') and '}' not in item_json[-1:]:
                    try:
                        # Try adding a closing brace
                        fixed_json = item_json + '}'
                        item = json.loads(fixed_json)
                        recovered_items.append(item)
                    except json.JSONDecodeError:
                        # Skip invalid items
                        pass
        
        return recovered_items
    
    @staticmethod
    def chunk_recover_json_array(json_str: str, chunk_size: int = 3) -> List[Any]:
        """
        Recover JSON array items by processing chunks of the input string.
        Useful for large responses that may be truncated in unpredictable ways.
        
        Args:
            json_str: JSON array string that might be truncated
            chunk_size: Number of potential objects to examine at once
            
        Returns:
            List of successfully parsed items
        """
        if not json_str.strip().startswith('['):
            return []
            
        # Step 1: Extract content inside array brackets
        content = json_str.strip()[1:]
        if content.endswith(']'):
            content = content[:-1]
        
        # Step 2: Find all object candidates (text between { and })
        object_pattern = r'(\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\})'
        object_candidates = re.findall(object_pattern, content)
        
        # Step 3: Process each candidate and combine valid ones
        recovered_items = []
        
        for obj in object_candidates:
            try:
                parsed = json.loads(obj)
                if isinstance(parsed, dict) and parsed:  # Ensure it's a non-empty dict
                    recovered_items.append(parsed)
            except json.JSONDecodeError:
                # Skip invalid JSON objects
                pass
                
        return recovered_items
    
    @staticmethod
    def sanitize_json(json_str: str) -> str:
        """
        Manually sanitize JSON string for common issues.
        
        Args:
            json_str: JSON string to sanitize
            
        Returns:
            Sanitized JSON string
        """
        # Replace common problematic patterns
        sanitized = json_str
        
        # Fix unescaped quotes in strings
        # This is a simplistic approach - full JSON parsing would be more robust
        sanitized = re.sub(r'(?<!\\)"([^"]*?)(?<!\\)"([^"]*?)(?<!\\)"', r'"\1\\"\2"', sanitized)
        
        # Fix trailing commas in arrays/objects
        sanitized = re.sub(r',\s*}', '}', sanitized)
        sanitized = re.sub(r',\s*\]', ']', sanitized)
        
        # Fix missing quotes around keys
        sanitized = re.sub(r'([{,])\s*([a-zA-Z0-9_]+)\s*:', r'\1"\2":', sanitized)
        
        # Fix truncated arrays - if we have an opening [ but no closing ]
        if sanitized.strip().startswith('[') and ']' not in sanitized:
            sanitized = sanitized + ']'
        
        # Fix truncated objects - if we have an opening { but no closing }
        if sanitized.strip().startswith('{') and '}' not in sanitized:
            sanitized = sanitized + '}'
        
        # Fix incomplete object properties (missing closing quotes or values)
        # Common case: "key": or "key":,
        sanitized = re.sub(r'"([^"]+)":\s*,', r'"\1": "",', sanitized)
        sanitized = re.sub(r'"([^"]+)":\s*$', r'"\1": ""', sanitized)
        sanitized = re.sub(r'"([^"]+)":\s*}', r'"\1": ""}', sanitized)
        
        return sanitized
    
    @staticmethod
    def detect_format(text: str) -> str:
        """
        Detect the format of the text from an LLM.
        
        Args:
            text: Text to analyze
            
        Returns:
            Format type: 'json', 'bullet_list', 'numbered_list', 'key_value', or 'raw_text'
        """
        # Check for JSON format
        if (text.strip().startswith('{') and text.strip().endswith('}')) or \
           (text.strip().startswith('[') and text.strip().endswith(']')):
            try:
                json.loads(text.strip())
                return 'json'
            except json.JSONDecodeError:
                pass
        
        # Check for markdown code blocks containing JSON
        if '```json' in text or '```' in text:
            code_block_pattern = r"```(?:json)?\s*([\s\S]*?)\s*```"
            code_blocks = re.findall(code_block_pattern, text)
            for block in code_blocks:
                try:
                    json.loads(block.strip())
                    return 'json'
                except json.JSONDecodeError:
                    continue
        
        # Check for bullet list
        bullet_pattern = r'(?:^|\n)\s*(?:|\*|-||)\s+.+'
        if re.search(bullet_pattern, text):
            return 'bullet_list'
        
        # Check for numbered list
        numbered_pattern = r'(?:^|\n)\s*\d+[.:\)]\s+.+'
        if re.search(numbered_pattern, text):
            return 'numbered_list'
        
        # Check for key-value pattern (at least 2 key-value pairs required)
        kv_pattern = r'(?:^|\n)\s*[A-Za-z0-9_\s]+\s*:\s*.+'
        kv_matches = re.findall(kv_pattern, text)
        if len(kv_matches) >= 2:
            return 'key_value'
        
        # Default to raw text
        return 'raw_text'
    
    @staticmethod
    def format_as_bullet_list(items: List[str]) -> str:
        """
        Format a list of items as a bullet list.
        
        Args:
            items: List of string items
            
        Returns:
            Formatted bullet list text
        """
        return "\n".join([f"- {item}" for item in items])
    
    @staticmethod
    def format_as_numbered_list(items: List[str]) -> str:
        """
        Format a list of items as a numbered list.
        
        Args:
            items: List of string items
            
        Returns:
            Formatted numbered list text
        """
        return "\n".join([f"{i+1}. {item}" for i, item in enumerate(items)])
    
    @staticmethod
    def format_as_key_value(data: Dict[str, Any]) -> str:
        """
        Format a dictionary as key-value pairs.
        
        Args:
            data: Dictionary to format
            
        Returns:
            Formatted key-value text
        """
        lines = []
        for key, value in data.items():
            if isinstance(value, (dict, list)):
                value = json.dumps(value)
            lines.append(f"{key}: {value}")
        return "\n".join(lines)
    
    @staticmethod
    def parse_based_on_format(text: str) -> Union[List, Dict, str]:
        """
        Parse text based on auto-detected format.
        
        Args:
            text: Text to parse
            
        Returns:
            Parsed data in appropriate structure
        """
        format_type = LLMParsingUtils.detect_format(text)
        
        if format_type == 'json':
            # Use parse_json_from_llm which now integrates the functionality 
            # of parse_json_with_fallbacks
            return asyncio.run(parse_json_from_llm(text, {}))
        elif format_type == 'bullet_list':
            return LLMParsingUtils.extract_bullet_list(text)
        elif format_type == 'numbered_list':
            return LLMParsingUtils.extract_numbered_list(text)
        elif format_type == 'key_value':
            return LLMParsingUtils.extract_key_value_pairs(text)
        else:
            return clean_text(text)  # Default to cleaned text
    
    @staticmethod
    def extract_sections_by_headers(text: str) -> Dict[str, str]:
        """
        Extract sections from text based on headers.
        
        Args:
            text: Text with sections marked by headers
            
        Returns:
            Dictionary with header names as keys and content as values
        """
        # Look for patterns like "# Header" or "## Header" or "Header:" at the beginning of lines
        header_pattern = r'(?:^|\n)(?:#{1,3}\s+([^#\n]+)|([^:\n]+):)\s*\n'
        
        sections = {}
        header_positions = []
        
        # Find all headers and their positions
        for match in re.finditer(header_pattern, text, re.MULTILINE):
            header = match.group(1) or match.group(2)
            if header:
                header = header.strip()
                position = match.end()
                header_positions.append((header, position))
        
        # Extract content between headers
        for i, (header, start_pos) in enumerate(header_positions):
            # Find the end of this section (start of next section or end of text)
            end_pos = header_positions[i+1][1] if i < len(header_positions) - 1 else len(text)
            # Extract content
            content = text[start_pos:end_pos].strip()
            sections[header] = content
        
        return sections


# Helper functions for common parsing operations

def extract_bullet_list(text: str) -> List[str]:
    """Helper function to extract bullet list from text."""
    return LLMParsingUtils.extract_bullet_list(text)

async def parse_json_from_llm(text: str, default_value: Any = None) -> Any:
    """
    Parse JSON from LLM output with automatic LLM-based repair if needed.
    
    This function tries traditional parsing methods first and falls back to
    LLM-based repair if those methods fail.
    
    Args:
        text: JSON text from LLM to parse
        default_value: Default value to return if parsing fails
            
    Returns:
        Parsed JSON object or default_value if parsing fails
    """
    # First try traditional rule-based parsing approaches
    try:
        # Try direct JSON parsing first (fastest)
        try:
            return json.loads(text)
        except json.JSONDecodeError:
            pass
            
        # Extract JSON from mixed content
        cleaned_json = LLMParsingUtils.extract_json_from_response(text)
        try:
            return json.loads(cleaned_json)
        except json.JSONDecodeError:
            pass
            
        # Handle potentially truncated arrays
        fixed_json = LLMParsingUtils.handle_truncated_json_array(cleaned_json)
        try:
            return json.loads(fixed_json)
        except json.JSONDecodeError:
            pass
        
        # Manual character-by-character cleanup
        sanitized_json = LLMParsingUtils.sanitize_json(fixed_json)
        try:
            return json.loads(sanitized_json)
        except json.JSONDecodeError:
            # Try recovery approaches for arrays
            if fixed_json.strip().startswith('['):
                recovered_items = LLMParsingUtils.recover_items_from_truncated_array(fixed_json)
                if recovered_items:
                    return recovered_items
                    
                chunk_recovered_items = LLMParsingUtils.chunk_recover_json_array(fixed_json)
                if chunk_recovered_items:
                    return chunk_recovered_items
                    
            # If we reach here, all rule-based approaches failed
            raise ValueError("Rule-based JSON parsing failed")
            
    except Exception as e:
        logger.debug(f"Traditional JSON parsing failed: {str(e)}")
    
    # If we get here, traditional parsing failed, try LLM repair
    logger.info("Attempting to repair malformed JSON with LLM")
    try:
        # Use the LLM repair method as fallback
        repaired_result = await repair_and_parse(text, default_value)
        if repaired_result is not None:
            logger.info("Successfully repaired and parsed JSON with LLM")
        else:
            logger.warning("LLM repair failed to fix JSON")
        return repaired_result
    except Exception as e:
        logger.error(f"Error during LLM JSON repair: {str(e)}")
        return default_value

def format_as_bullet_list(items: List[str]) -> str:
    """Helper function to format items as bullet list."""
    return LLMParsingUtils.format_as_bullet_list(items)

def extract_key_value_pairs(text: str) -> Dict[str, str]:
    """Helper function to extract key-value pairs from text."""
    return LLMParsingUtils.extract_key_value_pairs(text)

def detect_and_parse_format(text: str) -> Union[List, Dict, str]:
    """Helper function to detect and parse based on format."""
    return LLMParsingUtils.parse_based_on_format(text)


__all__ = [
    "LLMParsingUtils",
    "extract_bullet_list",
    "parse_json_from_llm",
    "format_as_bullet_list",
    "extract_key_value_pairs",
    "detect_and_parse_format",
]
</file>

<file path="backend/src/utils/llm/llm_service.py">
# backend/src/utils/llm/llm_service.py
from typing import Optional, Dict, Any
from ...config.config import LLMConfig
from ..document_processing.processors import clean_text, normalize_text

class LLMService:
    """
    Service for interacting with Language Model APIs.
    Abstracts the details of different LLM providers.
    """
    
    def __init__(self, llm_config: Optional[LLMConfig] = None):
        """
        Initialize the LLM service with configuration.
        
        Args:
            llm_config: Configuration for LLM providers. If None, uses default config.
        """
        self.llm_config = llm_config or LLMConfig()
        self.client = self.llm_config.get_client()
        self.model = self.llm_config.get_model()
        self.provider = self.llm_config.get_provider()
    
    def generate_content(self, prompt: str, temperature: float = 0.7, max_tokens: int = 1000, 
                         clean_prompt: bool = False) -> str:
        """
        Generate content using the configured LLM provider.
        
        Args:
            prompt: The prompt to send to the LLM
            temperature: Controls randomness (0-1), higher = more random
            max_tokens: Maximum number of tokens to generate
            clean_prompt: Whether to clean and normalize the prompt text
            
        Returns:
            String containing the raw LLM response
        """
        # Clean prompt if requested - using utility from document_processing
        if clean_prompt:
            prompt = clean_text(prompt, remove_extra_whitespace=True)
        
        # Call appropriate method based on provider
        if self.provider == "openai":
            return self._generate_with_openai(prompt, temperature, max_tokens)
        elif self.provider == "anthropic":
            return self._generate_with_anthropic(prompt, temperature, max_tokens)
        elif self.provider == "gemini":
            return self._generate_with_gemini(prompt, temperature, max_tokens)
        else:
            raise ValueError(f"Unsupported LLM provider: {self.provider}")
    
    def _generate_with_openai(self, prompt: str, temperature: float, max_tokens: int) -> str:
        """Generate content using OpenAI API."""
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[
                {"role": "system", "content": "You are a helpful assistant that creates high-quality trivia content."},
                {"role": "user", "content": prompt}
            ],
            temperature=temperature,
            max_tokens=max_tokens
        )
        return response.choices[0].message.content
    
    def _generate_with_anthropic(self, prompt: str, temperature: float, max_tokens: int) -> str:
        """Generate content using Anthropic API."""
        message = self.client.messages.create(
            model=self.model,
            max_tokens=max_tokens,
            temperature=temperature,
            system="You are a helpful assistant that creates high-quality trivia content.",
            messages=[
                {"role": "user", "content": prompt}
            ]
        )
        return message.content[0].text
    
    def _generate_with_gemini(self, prompt: str, temperature: float, max_tokens: int) -> str:
        """Generate content using Google's Gemini API."""
        genai = self.client
        model = genai.GenerativeModel(self.model)
        response = model.generate_content(  # Changed to sync version
            prompt,
            generation_config={
                "temperature": temperature,
                "max_output_tokens": max_tokens
            }
        )
        return response.text
    
    def process_llm_response(self, response: str, normalize: bool = True, 
                           remove_extra_whitespace: bool = True) -> str:
        """
        Process an LLM response using document processing utilities.
        
        Args:
            response: Raw LLM response text
            normalize: Whether to normalize the text
            remove_extra_whitespace: Whether to remove extra whitespace
            
        Returns:
            Processed response text
        """
        # Clean the text first
        processed_text = clean_text(response, remove_extra_whitespace=remove_extra_whitespace)
        
        # Normalize if requested
        if normalize:
            processed_text = normalize_text(processed_text, lowercase=False)
            
        return processed_text
</file>

<file path="backend/src/utils/question_generation/__init__.py">
# backend/src/utils/question_generation/__init__.py
"""
Question generation utilities for trivia pack creation.

This package provides utilities for creating trivia questions and processing
inputs for question generation.
"""

from .pack_topic_creation import PackTopicCreation
from .pack_difficulty_creation import PackDifficultyCreation
from .text_utils import clean_trivia_text, chunk_trivia_content
from .seed_question_processor import SeedQuestionProcessor
from .question_generator import QuestionGenerator
from .custom_instructions_creator import CustomInstructionsCreator

__all__ = [
    "PackTopicCreation",
    "PackDifficultyCreation",
    "clean_trivia_text", 
    "chunk_trivia_content",
    "SeedQuestionProcessor",
    "QuestionGenerator",
    "CustomInstructionsCreator",
]
</file>

<file path="backend/src/utils/question_generation/custom_instructions_creator.py">
# backend/src/utils/question_generation/custom_instructions_creator.py
"""
Utility for creating custom instructions for trivia question generation.
Provides options to generate instructions using LLM or process manual input.
Uses different LLM prompts based on the presence of seed questions.
"""

from typing import Dict, List, Optional
import logging
# Assuming LLMService and clean_text are correctly imported
from ..llm.llm_service import LLMService
from ..document_processing.processors import clean_text

# Configure logger
logger = logging.getLogger(__name__)

class CustomInstructionsCreator:
    """
    Utility for creating custom instructions for question generation,
    either by generating them with LLM or handling manual input.
    Uses different prompts depending on whether seed questions are provided.
    """

    def __init__(self, llm_service: Optional[LLMService] = None):
        """
        Initialize with required services.

        Args:
            llm_service: Service for LLM interactions. If None, creates a new instance.
        """
        self.llm_service = llm_service or LLMService()

    async def generate_custom_instructions(self,
                                         pack_topic: str,
                                         seed_questions: Optional[Dict[str, str]] = None) -> str:
        """
        Generate custom instructions for question generation using LLM.
        The prompt used will differ based on whether seed_questions are provided.

        Args:
            pack_topic: Topic of the trivia pack
            seed_questions: Optional dictionary of example questions and answers

        Returns:
            Generated custom instructions text
        """
        # Build prompt for custom instructions generation - this now contains the conditional logic
        prompt = self._build_instructions_prompt(pack_topic, seed_questions)

        try:
            # Generate instructions using LLM
            # No change needed here, just uses the generated prompt
            raw_response = self.llm_service.generate_content(prompt)
            processed_response = self.llm_service.process_llm_response(raw_response)

            # Log success
            logger.info(f"Successfully generated custom instructions for topic: {pack_topic}")

            return processed_response
        except Exception as e:
            logger.error(f"Error generating custom instructions: {str(e)}")
            # Return an empty string if generation fails
            return ""

    def _format_seed_examples_for_prompt(self, seed_questions: Dict[str, str]) -> str:
        """Helper to format seed questions for inclusion in the prompt."""
        if not seed_questions:
            return "No specific seed questions were provided."

        examples = []
        count = 0
        for question, answer in seed_questions.items():
            examples.append(f"Q: {question}\nA: {answer}")
            count += 1
            if count >= 5: # Limit to 5 examples
                break

        if examples:
            return "Here are some example questions and answers for this topic:\n\n" + "\n\n".join(examples)
        else:
            return "No valid seed questions could be formatted."


    def _build_instructions_prompt(self,
                                 pack_topic: str,
                                 seed_questions: Optional[Dict[str, str]] = None) -> str:
        """
        Build the prompt for custom instructions generation, choosing the template
        based on the presence of seed_questions.

        Args:
            pack_topic: Topic of the trivia pack
            seed_questions: Optional dictionary of example questions and answers

        Returns:
            Formatted prompt string suitable for the LLM
        """
        # --- Conditional Prompt Logic ---
        if seed_questions:
            # --- PROMPT VERSION 1: WITH SEED QUESTIONS ---
            examples_text = self._format_seed_examples_for_prompt(seed_questions)
            prompt = f"""You are being given a trivia topic: '{pack_topic}' and a set of example trivia clues from that category. Your task is to analyze these clues and explain how the category works.

Write a clear, structured description that would help another AI generate new clues that match the same pattern. Your explanation should cover:
- What kind of word or phrase is missing or being asked for in the answer (e.g., adjectives, names, titles, etc.)
- What type of information the clue provides (e.g., plot summary, cultural references, wordplay)
- How the clue leads the player to the answer
- Any consistent patterns in clue phrasing or formatting
- Instructions on how to construct questions if there is an identifiable format that's shown in the seed questions.  If there is variance, encourage variance.
- Limit your response to maximum 5 sentences.

Avoid restating the actual example clues, but use them to extract the underlying logic of the category. Your description should be general enough to guide clue creation but specific enough to preserve the style of the category.

{examples_text}

Your instructions MUST adhere to the following constraints:
1. Should NOT include references to specific difficulty levels (Easy, Medium, Hard, etc.) or adjusting questions based on audience familiarity.
2. Should NOT influence the length of the generated questions.
3. Should NOT guide creation of questions towards styles that are not appropriate for trivia (e.g., subjective opinions, open-ended questions).
4. Should NOT guide creation towards hypotheticals or questions that are not factual.
5. Should NOT try to dissuade from obscurity; obscure facts are acceptable in trivia.

Output Format:
- Sentence 1
- Sentence 2
- Sentence 3
- Sentence 4
- Sentence 5

Do not let style or creativity override accuracy. Respond ONLY with the custom instructions in a clear, direct format. Do not include any other text or markdown formatting (like ```).
"""
        else:
            # --- PROMPT VERSION 2: WITHOUT SEED QUESTIONS ---
            prompt = f"""You need to generate instructions for creating trivia questions for the category: '{pack_topic}'. No example questions are provided.

Your task is to write a clear, structured description based SOLELY on the topic '{pack_topic}' that would help another AI generate good trivia questions. Your description should cover:
- The typical scope and subject matter for this topic in a trivia context.
- Common types of questions or angles associated with '{pack_topic}' (e.g., definitions, key figures, historical events, specific works, technical details).
- Any inherent characteristics of the topic that might influence question style (e.g., is it inherently technical, creative, historical?).
- Potential areas within the topic suitable for trivia questions.
- Limit your response to maximum 5 sentences.

Your instructions MUST adhere to the following constraints:
1. Should NOT include references to specific difficulty levels (Easy, Medium, Hard, etc.) or adjusting questions based on audience familiarity.
2. Should NOT influence the length of the generated questions.
3. Should NOT guide creation of questions towards styles that are not appropriate for trivia (e.g., subjective opinions, open-ended questions).
4. Should NOT guide creation towards hypotheticals or questions that are not factual.
5. Should NOT try to dissuade from obscurity; obscure facts are acceptable in trivia.

Output Format:
- Sentence 1
- Sentence 2
- Sentence 3
- Sentence 4
- Sentence 5

Focus on the nature of the topic itself to provide guidance. Respond ONLY with the custom instructions in a clear, direct format. Do not include any other text or markdown formatting (like ```).
"""
        # --- End Conditional Logic ---

        return prompt

    def process_manual_instructions(self, instructions: str) -> str:
        """
        Process manually provided instructions.
        (No change needed here)

        Args:
            instructions: Manually provided custom instructions

        Returns:
            Processed instructions text
        """
        # Clean and normalize the input
        return clean_text(instructions)
</file>

<file path="backend/src/utils/question_generation/incorrect_answer_generator.py">
# backend/src/utils/question_generation/incorrect_answer_generator.py
import logging
from typing import List, Dict, Any, Optional, Tuple
import asyncio
import time
import math # Import math for ceiling

from ..llm.llm_service import LLMService
from ..document_processing.processors import clean_text
from ..llm.llm_parsing_utils import parse_json_from_llm
from ...models.question import Question

logger = logging.getLogger(__name__)

# --- Define Custom Exception ---
class IncorrectAnswerGenerationError(Exception):
    """Custom exception for failures in generating incorrect answers."""
    def __init__(self, message: str, failed_question_ids: List[str]):
        self.message = message
        self.failed_question_ids = failed_question_ids
        super().__init__(f"{message} Failed for question IDs: {', '.join(failed_question_ids)}")
# --- End Custom Exception ---

class IncorrectAnswerGenerator:
    """
    Generates plausible but incorrect answers for trivia questions,
    with a retry mechanism using smaller batches for failures.
    Raises an error if generation fails for any question after retries.
    """
    def __init__(self, llm_service: Optional[LLMService] = None):
        self.llm_service = llm_service or LLMService()
        self.debug_enabled = False

    async def generate_incorrect_answers(
        self,
        questions: List[Question],
        num_incorrect_answers: int = 3,
        batch_size: int = 5,
        max_retries: int = 1, # If > 0, allows one retry attempt with smaller batches
        debug_mode: bool = False
    ) -> List[Tuple[str, List[str]]]:
        """
        Generate incorrect answers for a list of questions with retries.

        Args:
            questions: List of Question objects.
            num_incorrect_answers: Number of incorrect answers per question.
            batch_size: Initial number of questions per LLM call.
            max_retries: If > 0, allows one retry attempt with a smaller batch size.
            debug_mode: Enable verbose debug output.

        Returns:
            List of tuples (question_id, incorrect_answers_list). Contains entries
            only for questions where generation was successful.

        Raises:
            IncorrectAnswerGenerationError: If answers could not be generated for
                                            one or more questions after all attempts.
        """
        self.debug_enabled = debug_mode
        if not questions:
            logger.warning("No questions provided for incorrect answer generation")
            return []

        all_results_map: Dict[str, List[str]] = {}
        original_question_map = {q.id: q for q in questions}
        original_question_ids = set(original_question_map.keys())

        questions_to_process = list(questions)

        # --- Initial Attempt ---
        initial_batches = [questions_to_process[i:i + batch_size] for i in range(0, len(questions_to_process), batch_size)]
        if self.debug_enabled:
             print(f"\nProcessing {len(questions_to_process)} questions in {len(initial_batches)} initial batches (size {batch_size})")

        tasks = []
        for batch_idx, batch in enumerate(initial_batches):
            if self.debug_enabled:
                print(f"  Creating task for Initial Batch {batch_idx+1}/{len(initial_batches)} ({len(batch)} questions)")
            task = asyncio.create_task(
                self._process_batch(batch, num_incorrect_answers, batch_idx, len(initial_batches), is_retry=False)
            )
            tasks.append(task)

        initial_batch_results = await asyncio.gather(*tasks)

        for batch_answers in initial_batch_results:
            for q_id, answers in batch_answers:
                if q_id not in all_results_map:
                     all_results_map[q_id] = answers

        # --- Identify Failures from Initial Attempt ---
        currently_failed_ids = original_question_ids - set(all_results_map.keys())
        failed_questions = [original_question_map[q_id] for q_id in currently_failed_ids]

        if self.debug_enabled:
            print(f"Initial attempt finished. Successful: {len(all_results_map)}. Failed: {len(failed_questions)}.")

        # --- Retry Attempt (if applicable and failures exist) ---
        if failed_questions and max_retries > 0:
            retry_batch_size = max(1, math.ceil(batch_size / 2))
            logger.warning(f"Retrying generation for {len(failed_questions)} failed questions with smaller batch size {retry_batch_size}")

            retry_batches = [failed_questions[i:i + retry_batch_size] for i in range(0, len(failed_questions), retry_batch_size)]
            if self.debug_enabled:
                 print(f"\nProcessing {len(failed_questions)} failed questions in {len(retry_batches)} retry batches (size {retry_batch_size})")

            retry_tasks = []
            for batch_idx, batch in enumerate(retry_batches):
                if self.debug_enabled:
                    print(f"  Creating task for Retry Batch {batch_idx+1}/{len(retry_batches)} ({len(batch)} questions)")
                task = asyncio.create_task(
                    self._process_batch(batch, num_incorrect_answers, batch_idx, len(retry_batches), is_retry=True)
                )
                retry_tasks.append(task)

            retry_batch_results = await asyncio.gather(*retry_tasks)

            processed_in_retry = 0
            for batch_answers in retry_batch_results:
                for q_id, answers in batch_answers:
                    if q_id not in all_results_map:
                         all_results_map[q_id] = answers
                         processed_in_retry += 1

            # Update the list of failures after the retry
            currently_failed_ids = original_question_ids - set(all_results_map.keys())

            if self.debug_enabled:
                 print(f"Retry attempt finished. Successful in retry: {processed_in_retry}. Still failed: {len(currently_failed_ids)}.")


        # --- Final Check and Error Handling (No Fallbacks) ---
        final_failed_ids = list(original_question_ids - set(all_results_map.keys()))

        if final_failed_ids:
            error_msg = f"Failed to generate incorrect answers for {len(final_failed_ids)} questions after {max_retries+1} attempts."
            logger.error(error_msg + f" Failed IDs: {final_failed_ids}")
            # Raise the custom error instead of generating fallbacks
            raise IncorrectAnswerGenerationError(error_msg, final_failed_ids)
        else:
            # All questions succeeded, format the results
            final_results = [(q_id, all_results_map[q_id]) for q_id in original_question_map.keys() if q_id in all_results_map] # Maintain order if possible
            # Ensure the final list matches the original count - should be guaranteed if no error raised
            if len(final_results) != len(questions):
                 logger.error(f"Mismatch in final result count ({len(final_results)}) vs original question count ({len(questions)}). This shouldn't happen if no error was raised.")
                 # Fallback to map just in case:
                 final_results = list(all_results_map.items())


            if self.debug_enabled:
                print(f"\nFinal Generation Summary:")
                print(f"  Total Questions: {len(questions)}")
                print(f"  Successfully Generated: {len(final_results)}")
                print(f"  Used Fallbacks: 0 (Error raised on failure)")

            return final_results

    # _process_batch, _build_incorrect_answers_prompt, _parse_and_match_response,
    # _validate_llm_answer_format methods remain unchanged from the previous version.
    # _generate_fallback_incorrect_answers and _generate_fallback_for_batch are kept
    # but should no longer be called by generate_incorrect_answers.

    async def _process_batch(
        self,
        questions_batch: List[Question],
        num_incorrect_answers: int,
        batch_idx: int,
        total_batches: int,
        is_retry: bool = False
    ) -> List[Tuple[str, List[str]]]:
        """
        Process a single batch, returning results ONLY for successes in this call.
        Does NOT generate fallbacks here.
        """
        batch_prefix = "Retry Batch" if is_retry else "Batch"
        logger.info(f"Processing {batch_prefix} {batch_idx+1}/{total_batches} ({len(questions_batch)} questions)")

        question_data_for_prompt = []
        original_questions_map = {}
        for q in questions_batch:
             question_data_for_prompt.append({
                  "id": q.id,
                  "question": q.question,
                  "answer": q.answer
             })
             original_questions_map[q.question] = q

        prompt = self._build_incorrect_answers_prompt(question_data_for_prompt, num_incorrect_answers)

        try:
            raw_response = self.llm_service.generate_content(
                prompt=prompt,
                temperature=0.7, # Consider slightly higher temp for retries?
                max_tokens=2000
            )

            if self.debug_enabled:
                print(f"\n  === Raw LLM Response ({batch_prefix} {batch_idx+1}) ===")
                print(f"  {raw_response[:500]}" + ("..." if len(raw_response) > 500 else ""))
                print("  ===================================\n")

            # Parse and match, returning only successful matches from THIS response
            # Do not generate fallbacks at this stage.
            batch_results = await self._parse_and_match_response(
                response=raw_response,
                original_questions_map=original_questions_map
            )
            return batch_results

        except Exception as e:
            logger.error(f"Error processing {batch_prefix} {batch_idx+1}: {str(e)}")
            if self.debug_enabled:
                print(f"  Error processing {batch_prefix} {batch_idx+1}: {str(e)}")
            return [] # Return empty list on error for this batch


    def _build_incorrect_answers_prompt(
        self,
        question_data: List[Dict[str, Any]], # Now includes ID
        num_incorrect_answers: int
    ) -> str:
        """
        Build the prompt for incorrect answer generation.
        """
        prompt = f"""Generate {num_incorrect_answers} plausible but incorrect answers for each of the following trivia questions.

For each question, I'll provide:
- A unique question_id
- The question text
- The correct answer

Your task is to create {num_incorrect_answers} incorrect answers that meet the guidelines provided previously.

Here are the questions (pay attention to the question_id):
"""
        for item in question_data:
            # Basic escaping for JSON within the prompt string
            q_text = item['question'].replace('"', '\\"')
            c_ans = item['answer'].replace('"', '\\"')
            prompt += f"""
{{
  "question_id": "{item['id']}",
  "question": "{q_text}",
  "correct_answer": "{c_ans}"
}}
"""
        prompt += f"""
Return your response as a valid JSON array containing objects. Each object MUST have these EXACT keys:
- "question_id": The EXACT unique ID provided for the question above.
- "question": The EXACT original question text provided above.
- "incorrect_answers": An array of {num_incorrect_answers} strings representing the generated incorrect answers.

Example of the required output structure:
[
  {{
    "question_id": "uuid-for-question-1",
    "question": "What is the capital of France?",
    "incorrect_answers": ["London", "Rome", "Berlin"]
  }},
  {{
    "question_id": "uuid-for-question-2",
    "question": "Which planet is known as the Red Planet?",
    "incorrect_answers": ["Venus", "Jupiter", "Saturn"]
  }}
  // ... more objects following the same structure
]

IMPORTANT NOTES:
- Use the EXACT question_id provided for each question in your response.
- Include the EXACT original question text in the "question" field of your response.
- Provide exactly {num_incorrect_answers} incorrect answers per question.
- DO NOT include the correct answer in the incorrect answers list.
- Ensure all incorrect answers are factually wrong.
- Return ONLY the JSON array without any additional text or markdown formatting.
- Ensure the final output is a single, valid JSON array.
- Ensure the incorrect answers are not overly verbose, they should be appropriate length for multiple choice trivia
"""
        return prompt

    async def _parse_and_match_response(
        self,
        response: str,
        original_questions_map: Dict[str, Question] # Map: original question text -> Question object
    ) -> List[Tuple[str, List[str]]]:
        """
        Parses the LLM response and matches items to original questions.
        Returns only successfully matched items from this specific response.
        """
        parsed_data = await parse_json_from_llm(response, []) # Default to empty list

        if self.debug_enabled:
            print(f"    Parsing LLM Response Chunk:")
            print(f"    Type: {type(parsed_data)}")

        # Inlined Logic from ensure_list_structure
        answers_data_list: List = []
        if isinstance(parsed_data, list):
            answers_data_list = parsed_data
        elif isinstance(parsed_data, dict):
            found = False
            common_list_keys = ['questions', 'answers', 'items', 'results', 'data', 'list', 'response', 'content', 'entities']
            for key in common_list_keys:
                if key in parsed_data and isinstance(parsed_data[key], list):
                    answers_data_list = parsed_data[key]
                    logger.debug(f"Extracted list from dictionary key: '{key}'")
                    found = True
                    break
            if not found and len(parsed_data) == 1:
                 first_value = next(iter(parsed_data.values()))
                 if isinstance(first_value, list):
                     answers_data_list = first_value
                     logger.debug("Extracted list from single-item dictionary's value")
                     found = True
            if not found:
                 logger.warning(f"Could not find list within parsed dict. Wrapping dict in list.")
                 answers_data_list = [parsed_data]
        elif parsed_data is not None:
             logger.warning(f"Parsed data was not list or dict ({type(parsed_data)}). Wrapping in list.")
             answers_data_list = [parsed_data]
        else:
             logger.warning("Parsed data was None. Using empty list.")
             answers_data_list = []
        # End Inlined Logic

        validated_answers_data = self._validate_llm_answer_format(answers_data_list)

        results = []
        processed_ids_in_this_response = set()

        for item in validated_answers_data:
            question_id_from_llm = item.get("question_id")
            question_text_from_llm = item.get("question")
            incorrect_answers = item.get("incorrect_answers", [])
            target_question: Optional[Question] = None

            # Matching Logic (ID first, then Text)
            if question_id_from_llm:
                found_by_id = False
                for q_obj in original_questions_map.values():
                    if q_obj.id == question_id_from_llm:
                        target_question = q_obj
                        found_by_id = True
                        break
            if not target_question and question_text_from_llm:
                if question_text_from_llm in original_questions_map:
                    target_question = original_questions_map[question_text_from_llm]
                else:
                    normalized_llm_text = clean_text(question_text_from_llm).lower()
                    for original_text, q_obj in original_questions_map.items():
                        normalized_original_text = clean_text(original_text).lower()
                        if normalized_llm_text == normalized_original_text:
                            target_question = q_obj
                            break

            if target_question:
                if target_question.id in processed_ids_in_this_response:
                    continue

                if isinstance(incorrect_answers, list) and all(isinstance(a, str) for a in incorrect_answers):
                    cleaned_answers = [clean_text(a) for a in incorrect_answers if a]
                    correct_answer_lower = target_question.answer.lower()
                    filtered_answers = [a for a in cleaned_answers if clean_text(a).lower() != correct_answer_lower]

                    if filtered_answers:
                        results.append((target_question.id, filtered_answers))
                        processed_ids_in_this_response.add(target_question.id)
                else:
                    logger.warning(f"Invalid incorrect_answers format from LLM for QID {target_question.id}")

        if self.debug_enabled:
            print(f"    Successfully parsed and matched {len(results)} items from this LLM response.")

        return results

    def _validate_llm_answer_format(self, answers: List) -> List[Dict]:
        """Validate and clean answer list format received from LLM."""
        result = []
        for a in answers:
            if not isinstance(a, dict):
                logger.warning(f"Skipping non-dict item in LLM answer response: {type(a)}")
                continue
            has_id = "question_id" in a
            has_text = "question" in a and isinstance(a["question"], str)
            has_answers = "incorrect_answers" in a and isinstance(a["incorrect_answers"], list)
            if (has_id or has_text) and has_answers:
                result.append(a)
            else:
                 logger.warning(f"Skipping item with missing/invalid keys in LLM response: {a}")
        return result
</file>

<file path="backend/src/utils/question_generation/pack_difficulty_creation.py">
# backend/src/utils/question_generation/pack_difficulty_creation.py
import re
from typing import List, Dict, Optional, Any
import logging # Added logging
from ..llm.llm_service import LLMService
from ..document_processing.processors import clean_text, normalize_text, split_into_chunks

# Configure logger
logger = logging.getLogger(__name__)

class PackDifficultyCreation:
    """
    Utility for generating difficulty descriptions for trivia packs.
    Focuses on LLM interactions for difficulty description creation.
    """

    def __init__(self, llm_service: Optional[LLMService] = None):
        """
        Initialize with required services.

        Args:
            llm_service: Service for LLM interactions. If None, creates a new instance.
        """
        self.llm_service = llm_service or LLMService()

        # Default base descriptions for each difficulty level
        self.base_descriptions = {
            "Easy": "Should be relatively easy questions that most audiences would know about.",
            "Medium": "Should be of medium difficulty.  Some people may not know about the topic of the question.",
            "Hard": "Should be hard questions that require a deeper understanding of the topic.  Many people may not know the topic, and they should be hard.",
            "Expert": "Questions should be designed for Experts on the topic.  These can be obscure or specialized questions that are genuinely difficult.  There should not be many hints within the question to help get at the answer.",
            "Mixed": "A mix of difficulties spanning easy all the way to obscure or specialized questions that are genuinely difficult.  See the above descriptions for easy, medium, hard, and expert."
        }

    async def generate_difficulty_descriptions(self, pack_name: str, pack_topics: List[str]) -> Dict[str, str]:
        """
        Generate custom difficulty descriptions for all levels including mixed.

        Args:
            pack_name: The name of the trivia pack (used instead of creation_name).
            pack_topics: List of topics in the pack.

        Returns:
            Dictionary with difficulty levels as keys and custom descriptions as values.
        """
        # Clean and normalize inputs
        pack_name = normalize_text(pack_name, lowercase=False) # Use pack_name
        cleaned_topics = [clean_text(topic) for topic in pack_topics]

        # Build prompt for difficulty description generation (using pack_name)
        prompt = self._build_difficulty_prompt(pack_name, cleaned_topics)

        try: # Added try/except for robustness
            # Generate descriptions using LLM
            raw_response = self.llm_service.generate_content(prompt)
            processed_response = self.llm_service.process_llm_response(raw_response)

            # Parse the response
            difficulty_descriptions = self._parse_difficulty_response(processed_response)

            # Ensure all expected difficulty levels are included
            expected_difficulties = ["Easy", "Medium", "Hard", "Expert", "Mixed"]
            for difficulty in expected_difficulties:
                if difficulty not in difficulty_descriptions:
                    logger.warning(f"LLM response did not contain description for '{difficulty}' level for pack '{pack_name}'. Adding empty string.")
                    difficulty_descriptions[difficulty] = ""

            return difficulty_descriptions
        except Exception as e:
             logger.error(f"Error generating difficulty descriptions for pack '{pack_name}': {e}", exc_info=True)
             # Return default descriptions on error
             return {level: "" for level in self.base_descriptions}


    def _parse_difficulty_response(self, response_text: str) -> Dict[str, str]:
        """
        Parse the LLM response into a dictionary of difficulty levels and descriptions.
        Handles various formatting inconsistencies.

        Args:
            response_text: Processed response from LLM.

        Returns:
            Dictionary mapping difficulty levels to their descriptions.
        """
        difficulty_descriptions = {}
        expected_difficulties = ["Easy", "Medium", "Hard", "Expert", "Mixed"]
        response_text = response_text.strip()

        # Attempt to split by newline first, assuming each level is on a new line
        lines = response_text.split('\n')
        processed_levels = set()

        for line in lines:
            line = line.strip()
            if not line: continue

            # Find the first matching difficulty level at the start of the line
            found_level = None
            for level in expected_difficulties:
                if level not in processed_levels:
                    # Match level at the beginning, followed by a colon or space
                    if line.lower().startswith(level.lower() + ":") or line.lower().startswith(level.lower() + " "):
                        # Extract description after the level and separator
                        start_index = len(level)
                        if line[start_index:].startswith(":"):
                            start_index += 1
                        description = line[start_index:].strip()
                        if description:
                            difficulty_descriptions[level] = description
                            found_level = level
                            break # Stop checking levels for this line once one is found

            if found_level:
                processed_levels.add(found_level)

        # If splitting by newline didn't capture all levels, try regex (more robust for messy formats)
        if len(difficulty_descriptions) < len(expected_difficulties):
            logger.debug("Newline splitting incomplete, attempting regex fallback for difficulty parsing.")
            remaining_levels = [level for level in expected_difficulties if level not in difficulty_descriptions]

            for level in remaining_levels:
                # Regex to find the level followed by ':' and capture text until the next level or end of string
                # Lookbehinds ensure we don't match a level name within another description
                pattern = rf"(?<!\w){re.escape(level)}:\s*(.*?)(?=(\n(?<!\w)(?:{'|'.join(expected_difficulties)}):|\Z))"
                match = re.search(pattern, response_text, re.IGNORECASE | re.DOTALL)
                if match:
                    description = match.group(1).strip()
                    # --- FIX: Corrected regex for cleaning ---
                    # Move hyphen to the end of the character set [] or escape it \-
                    description = re.sub(r'^["\'`*\s-]+|["\'`*\s-]+$', '', description)
                    # --- END FIX ---
                    if description:
                        difficulty_descriptions[level] = description

        # Ensure all levels have at least an empty string entry
        for level in expected_difficulties:
            if level not in difficulty_descriptions:
                difficulty_descriptions[level] = ""

        return difficulty_descriptions

    def _build_difficulty_prompt(self, pack_name: str, pack_topics: List[str]) -> str:
        """
        Build the prompt for difficulty description generation.

        Args:
            pack_name: Name of the trivia pack (used instead of creation_name).
            pack_topics: List of topics in the pack.

        Returns:
            Formatted prompt string.
        """
        # Use split_into_chunks if the topics text might be too long
        topics_text = "\n".join([f"- {topic}" for topic in pack_topics])

        # Only use chunking if the topics text is very long
        if len(topics_text) > 2000:
            chunks = split_into_chunks(topics_text, chunk_size=1500, respect_sentences=True)
            topics_text = chunks[0] + "\n(and additional topics...)"

        prompt = f"""Generate specific difficulty level descriptions for a trivia pack named "{pack_name}"
with the following topics:

{topics_text}

For each difficulty level (Easy, Medium, Hard, Expert, and Mixed), provide a detailed,
pack-specific description of what questions at that level should entail.

The descriptions should:
- Be tailored specifically to "{pack_name}" and its topics
- Explain what makes a question belong to that difficulty level for this specific pack
- Provide clear guidance for question creation at each level
- For the Mixed level, explain how different difficulties would be balanced in this pack

CRITICAL FORMATTING INSTRUCTIONS:
1. DO NOT include any other difficulty level names (Easy, Medium, Hard, Expert, Mixed) within any difficulty description.
2. Each difficulty MUST be on its own separate line with NO other difficulty names in that line's description.
3. Place each description on a SEPARATE LINE from other difficulties.
4. Start each line EXACTLY with the difficulty level name followed by a colon and a space (e.g., "Easy: ").

Format exactly like this (notice each difficulty is on its OWN LINE):

Easy: [description for Easy difficulty]
Medium: [description for Medium difficulty]
Hard: [description for Hard difficulty]
Expert: [description for Expert difficulty]
Mixed: [description for Mixed difficulty]

Example format (EACH ON SEPARATE LINES):

Easy: Questions about basic Roman emperors and common knowledge facts.
Medium: Questions about specific battles and political reforms.
Hard: Questions about lesser-known figures and complex historical events.
Expert: Questions about detailed historical analysis and obscure Roman customs.
Mixed: A balance of questions from all difficulty levels covering various Roman topics.

DO NOT include any explanatory text before or after the difficulty descriptions.
Ensure ONLY the descriptions follow the format above.
"""
        return prompt

    def create_difficulty_json(self, custom_descriptions: Dict[str, str]) -> Dict[str, Dict[str, str]]:
        """
        Create a structured JSON object with base and custom descriptions for each difficulty level.

        Args:
            custom_descriptions: Dictionary of custom descriptions by difficulty level.

        Returns:
            Nested dictionary with difficulty levels as keys, each containing a dictionary with 'base' and 'custom' keys.
        """
        difficulty_json = {}

        for level, base_desc in self.base_descriptions.items():
            custom_desc = custom_descriptions.get(level, "")
            difficulty_json[level] = {
                "base": base_desc,
                "custom": custom_desc
            }

        return difficulty_json

    def format_descriptions_for_prompt(self, difficulty_json: Dict[str, Dict[str, str]], difficulties: Optional[List[str]] = None) -> str:
        """
        Format the difficulty descriptions for use in future prompts.

        Args:
            difficulty_json: Nested dictionary of difficulty descriptions.
            difficulties: Optional list of difficulty levels to include (e.g., ["Easy", "Medium"]).
                         If None, all difficulties will be included.

        Returns:
            Formatted string for use in prompts.
        """
        formatted_descriptions = []

        # Ensure consistent order if difficulties is None
        levels_to_include = difficulties if difficulties is not None else ["Easy", "Medium", "Hard", "Expert", "Mixed"]

        for level in levels_to_include:
            if level in difficulty_json:
                descriptions = difficulty_json[level]
                base_desc = descriptions.get("base", "")
                custom_desc = descriptions.get("custom", "")

                # Combine base and custom, prioritizing custom if available
                combined_desc = custom_desc if custom_desc else base_desc
                if combined_desc: # Add only if there is some description
                    # Format as required for the prompt
                    formatted = f"* {level}: {combined_desc}"
                    if not combined_desc.endswith('.'): formatted += '.' # Ensure punctuation
                    formatted_descriptions.append(formatted)

        # Join with newlines
        return "\n".join(formatted_descriptions)

    def _get_default_difficulty_structure(self) -> Dict[str, Dict[str, str]]:
        """
        Get the default difficulty structure with empty custom descriptions.

        Returns:
            Default nested dictionary with base descriptions.
        """
        return {level: {"base": base_desc, "custom": ""} for level, base_desc in self.base_descriptions.items()}
</file>

<file path="backend/src/utils/question_generation/pack_topic_creation.py">
# backend/src/utils/question_generation/pack_topic_creation.py
import logging
from typing import List, Optional
from ..llm.llm_service import LLMService
from ..document_processing.processors import clean_text, normalize_text
from ..llm.llm_parsing_utils import parse_json_from_llm

# Setup logger
logger = logging.getLogger(__name__)

class PackTopicCreation:
    """
    Utility for generating pack topics for trivia question generation.
    Focuses on LLM interaction for topic creation.
    """

    def __init__(self, llm_service: Optional[LLMService] = None):
        """
        Initialize with required services.

        Args:
            llm_service: Service for LLM interactions. If None, creates a new instance.
        """
        self.llm_service = llm_service or LLMService()

    # --- UPDATED METHOD SIGNATURE ---
    async def create_pack_topics(self, pack_name: str,
                               num_topics: int = 5,
                               predefined_topic: Optional[str] = None) -> List[str]:
        """
        Create a list of topics for a trivia pack using LLM.

        Args:
            pack_name: The name of the trivia pack (used instead of creation_name).
            num_topics: Number of topics to generate.
            predefined_topic: Optional predefined topic to use instead of generation.

        Returns:
            List of topics (either generated or containing the predefined topic).
        """
        # --- END UPDATED SIGNATURE ---
        # If a predefined topic is provided, use it directly
        if predefined_topic:
            clean_topic = normalize_text(predefined_topic, lowercase=False)
            logger.info(f"Using predefined topic: {clean_topic}")
            return [clean_topic]

        # Clean and normalize inputs
        pack_name = normalize_text(pack_name, lowercase=False) # Use pack_name

        # Generate the prompt for topic creation (using pack_name)
        prompt = self._build_topic_generation_prompt(
            pack_name=pack_name,
            num_topics=num_topics
        )

        try: # Added try/except
            # Generate topics using LLM
            raw_response = self.llm_service.generate_content(prompt)

            # Parse the raw response directly into JSON
            default_topics = []
            topics_data = await parse_json_from_llm(raw_response, default_topics)

            # Validate the result is a list of strings
            if isinstance(topics_data, list):
                topics = [str(item) for item in topics_data if item] # Filter out empty strings
            else:
                logger.warning(f"LLM topic generation for '{pack_name}' returned non-list data: {type(topics_data)}. Using empty list.")
                topics = default_topics

            # Ensure we have the requested number of topics (truncate if too many)
            if len(topics) > num_topics:
                topics = topics[:num_topics]

            # Check if we got fewer topics than requested
            if len(topics) < num_topics:
                logger.warning(
                    f"Requested {num_topics} topics for '{pack_name}', but only received {len(topics)}. "
                    f"Continuing with available topics."
                )
                print(f"Warning: Requested {num_topics} topics but only got {len(topics)}")

            return topics
        except Exception as e:
             logger.error(f"Error generating topics for pack '{pack_name}': {e}", exc_info=True)
             return [] # Return empty list on error


    # --- UPDATED METHOD SIGNATURE ---
    def _build_topic_generation_prompt(self, pack_name: str,
                                      num_topics: int = 5) -> str:
        """
        Build the prompt for topic creation.

        Args:
            pack_name: Name of the trivia pack (used instead of creation_name).
            num_topics: Number of topics to generate.

        Returns:
            Formatted prompt string.
        """
        # --- END UPDATED SIGNATURE ---
        prompt = f"""Generate {num_topics} specific topics for a trivia pack named "{pack_name}".

The topics should:
- Be specific enough to generate interesting trivia questions
- Cover different aspects related to {pack_name}
- They should be wide enough that there is room for a variety of interesting questions to be generated about the topic

IMPORTANT: Return the topics as a valid JSON array of strings in this exact format:
[
  "{pack_name}: Topic 1",
  "{pack_name}: Topic 2",
  "{pack_name}: Topic 3"
]

For example, if the pack name was "World Geography", the response should be:
[
  "World Geography: Mountain ranges across continents",
  "World Geography: Island nations and archipelagos",
  "World Geography: Capital cities of the world",
  "World Geography: Major rivers and watersheds",
  "World Geography: Desert ecosystems"
]

DO NOT include any additional text, explanations, or markdown - ONLY return the JSON array.
"""
        return prompt

    # --- UPDATED METHOD SIGNATURE ---
    async def create_additional_topics(self, existing_topics: List[str],
                                     pack_name: str,
                                     num_additional_topics: int = 3,
                                     predefined_topic: Optional[str] = None) -> List[str]:
        """
        Create additional topics that don't overlap with existing ones.

        Args:
            existing_topics: List of existing topics to avoid duplicating.
            pack_name: The name of the trivia pack (used instead of creation_name).
            num_additional_topics: Number of new topics to add.
            predefined_topic: Optional predefined topic to add directly.

        Returns:
            List of new topics.
        """
        # --- END UPDATED SIGNATURE ---
        # If a predefined topic is provided, use it directly
        if predefined_topic:
            clean_topic = normalize_text(predefined_topic, lowercase=False)
            if clean_topic in existing_topics:
                logger.warning(f"Predefined topic '{clean_topic}' already exists in topics list")
                return []
            logger.info(f"Adding predefined topic: {clean_topic}")
            return [clean_topic]

        # Clean pack name
        pack_name = normalize_text(pack_name, lowercase=False) # Use pack_name

        # Build prompt for additional topics (using pack_name)
        additional_prompt = f"""Generate {num_additional_topics} new specific topics for a trivia pack named "{pack_name}".

Please provide topics DIFFERENT from these existing topics:
{', '.join(existing_topics)}

The topics should:
- Be specific enough to generate interesting trivia questions
- Cover different aspects related to {pack_name}

IMPORTANT: Return the topics as a valid JSON array of strings in this exact format:
[
  "New Topic 1",
  "New Topic 2",
  "New Topic 3"
]

DO NOT include any additional text, explanations, or markdown - ONLY return the JSON array.
"""

        try: # Added try/except
            # Generate additional topics
            raw_response = self.llm_service.generate_content(additional_prompt)

            # Parse the raw response directly into JSON
            default_topics = []
            new_topics_data = await parse_json_from_llm(raw_response, default_topics)

            # Validate the result is a list of strings
            if isinstance(new_topics_data, list):
                new_topics = [str(item) for item in new_topics_data if item] # Filter empty strings
            else:
                logger.warning(f"LLM additional topic generation for '{pack_name}' returned non-list data: {type(new_topics_data)}. Using empty list.")
                new_topics = default_topics

            # Check if we got fewer topics than requested
            if len(new_topics) < num_additional_topics:
                logger.warning(
                    f"Requested {num_additional_topics} additional topics for '{pack_name}', "
                    f"but only received {len(new_topics)}. Continuing with available topics."
                )
                print(f"Warning: Requested {num_additional_topics} additional topics but only got {len(new_topics)}")

            # Filter out any topics that might *still* duplicate existing ones (LLM might ignore instructions)
            final_new_topics = [topic for topic in new_topics if topic not in existing_topics]
            if len(final_new_topics) < len(new_topics):
                logger.warning(f"Filtered out {len(new_topics) - len(final_new_topics)} additional topics that already existed.")

            return final_new_topics
        except Exception as e:
             logger.error(f"Error generating additional topics for pack '{pack_name}': {e}", exc_info=True)
             return [] # Return empty list on error
</file>

<file path="backend/src/utils/question_generation/question_generator.py">
# backend/src/utils/question_generation/question_generator.py
"""
Utility for generating trivia questions using LLM based on pack topics and difficulty.
"""

import json
from typing import List, Dict, Any, Optional, Union
import logging
import traceback

# --- UPDATED IMPORTS ---
from ...models.question import DifficultyLevel, Question # Keep Question import for type hint if needed elsewhere, though not directly used here
from ..llm.llm_service import LLMService
from ..llm.llm_parsing_utils import parse_json_from_llm
from ..document_processing.processors import clean_text
# --- END UPDATED IMPORTS ---

# Configure logger
logger = logging.getLogger(__name__)

class QuestionGenerator:
    """
    Generates trivia questions using LLM based on specified topics and difficulties.
    """

    def __init__(self, llm_service: Optional[LLMService] = None):
        """
        Initialize the question generator with services.

        Args:
            llm_service: Service for LLM interactions. If None, creates a new instance.
        """
        self.llm_service = llm_service or LLMService()
        self.debug_enabled = False
        self.last_raw_response = None
        self.last_processed_questions = None

    # --- UPDATED METHOD SIGNATURE ---
    async def generate_questions(
        self,
        pack_id: str,
        pack_name: str, # <<< CHANGED: Use pack_name instead of creation_name
        pack_topic: str,
        difficulty: Union[str, DifficultyLevel],
        difficulty_descriptions: Dict[str, Dict[str, str]],
        seed_questions: Dict[str, str] = None,
        custom_instructions: Optional[str] = None,
        num_questions: int = 5,
        debug_mode: bool = False
    ) -> List[Dict[str, Any]]:
        """
        Generate questions for a specific topic and difficulty.

        Args:
            pack_id: ID of the pack.
            pack_name: Name of the trivia pack (used instead of creation_name).
            pack_topic: The specific topic to generate questions for.
            difficulty: Difficulty level for the questions.
            difficulty_descriptions: Dictionary with difficulty descriptions for ALL levels.
            seed_questions: Optional dictionary of example questions and answers.
            custom_instructions: Optional custom instructions for question generation.
            num_questions: Number of questions to generate.
            debug_mode: Enable verbose debug output.

        Returns:
            List of dictionaries containing question data ready to be stored.
        """
        # --- END UPDATED SIGNATURE ---
        self.debug_enabled = debug_mode

        # Ensure we have valid difficulty level string
        if isinstance(difficulty, DifficultyLevel):
            difficulty_str = difficulty.value.capitalize()
        else:
            difficulty_str = difficulty.capitalize()

        # Build prompt for question generation (using pack_name)
        prompt = self._build_question_generation_prompt(
            pack_name=pack_name, # <<< CHANGED: Pass pack_name
            pack_topic=pack_topic,
            difficulty=difficulty_str,
            difficulty_descriptions=difficulty_descriptions,
            seed_questions=seed_questions,
            custom_instructions=custom_instructions,
            num_questions=num_questions
        )

        if self.debug_enabled:
            print("\n=== Question Generation Prompt ===")
            print(prompt)
            print("==================================\n")

        try:
            # Generate questions using LLM
            raw_response = self.llm_service.generate_content(
                prompt=prompt,
                temperature=0.7,
                max_tokens=2000
            )

            self.last_raw_response = raw_response

            if self.debug_enabled:
                print("\n=== Raw LLM Response ===")
                print(raw_response)
                print("========================\n")

            # Process the response
            processed_questions = await self._process_question_response(
                response=raw_response,
                pack_id=pack_id,
                pack_topic=pack_topic,
                difficulty_str=difficulty_str
            )

            self.last_processed_questions = processed_questions

            if self.debug_enabled:
                print("\n=== Processed Questions ===")
                try:
                    print(json.dumps(processed_questions, indent=2, default=str))
                except Exception as e:
                    print(f"Error showing processed questions: {str(e)}")
                    print(f"Raw processed questions: {processed_questions}")
                print("===========================\n")

            return processed_questions

        except Exception as e:
            logger.error(f"Error generating questions: {str(e)}")
            if self.debug_enabled:
                print(f"\n=== Question Generation Error ===")
                print(f"Error: {str(e)}")
                print(traceback.format_exc())
                print("================================\n")
            return []

    def _format_all_difficulty_descriptions(
        self,
        difficulty_descriptions: Dict[str, Dict[str, str]]
    ) -> str:
        """Formats all difficulty descriptions for inclusion in the LLM prompt."""
        formatted_lines = []
        levels = ["Easy", "Medium", "Hard", "Expert", "Mixed"]
        for level in levels:
            if level in difficulty_descriptions:
                descriptions = difficulty_descriptions[level]
                base_desc = descriptions.get("base", "").strip()
                custom_desc = descriptions.get("custom", "").strip()
                combined_desc = base_desc
                if custom_desc:
                    if combined_desc and not combined_desc.endswith('.'):
                        combined_desc += ". "
                    elif not combined_desc:
                         pass
                    combined_desc += custom_desc
                if combined_desc and not combined_desc.endswith('.'):
                     combined_desc += '.'
                if combined_desc:
                    formatted_lines.append(f"*   {level}: {combined_desc}")
        if not formatted_lines:
            return "No specific difficulty descriptions were generated for this pack."
        return "\n".join(formatted_lines)

    # --- UPDATED METHOD SIGNATURE ---
    def _build_question_generation_prompt(
        self,
        pack_name: str, # <<< CHANGED: Use pack_name instead of creation_name
        pack_topic: str,
        difficulty: str,
        difficulty_descriptions: Dict[str, Dict[str, str]],
        seed_questions: Dict[str, str] = None,
        custom_instructions: Optional[str] = None,
        num_questions: int = 5
    ) -> str:
        """Build the prompt for question generation."""
        # --- END UPDATED SIGNATURE ---
        all_descriptions_text = self._format_all_difficulty_descriptions(difficulty_descriptions)
        examples_text = self._format_seed_questions_as_examples(seed_questions)

        # Build the prompt using pack_name
        prompt = f"""Generate {num_questions} trivia questions about "{pack_topic}" for a trivia pack called "{pack_name}".

The TARGET difficulty level for these questions is: {difficulty}.

Use the following descriptions for ALL difficulty levels in this pack as context to understand what {difficulty} means relative to the others:
{all_descriptions_text}

Each generated question should:
1. Be clear and unambiguous.
2. Have a single correct answer that is factually accurate. The question should also have factually correct elements.
3. Not state the answer within the question text itself. E.g., "Question: Who is the main character of Harry Potter" is a bad question because the answer is "Harry Potter."
4. Be specific to the topic "{pack_topic}".
5. Match the TARGET difficulty level ({difficulty}) based on the provided context.
6. Be interesting and creative while maintaining accuracy.
7. Have a question length appropriate for trivia (e.g., 10-20 words or max 125 characters).
8. Have a concise answer.
"""

        if custom_instructions:
            prompt += f"\nAdditional instructions for question generation:\n{custom_instructions}\n"

        prompt += f"""
{examples_text}

Return ONLY a valid JSON array of question objects with the following format:
[
  {{
    "question": "The full question text?",
    "answer": "The correct answer"
  }},
  ...
]

IMPORTANT:
- Generate questions ONLY for the TARGET difficulty level: {difficulty}.
- Make sure each question has exactly ONE correct answer.
- Return ONLY the JSON array without any additional text or markdown formatting.
- Ensure the JSON is properly formatted.
"""
        return prompt

    def _format_seed_questions_as_examples(self, seed_questions: Optional[Dict[str, str]]) -> str:
        """Format seed questions as examples for the prompt."""
        if not seed_questions: return ""
        examples = []
        count = 0
        for question, answer in seed_questions.items():
            examples.append(f"Question: {question}\nAnswer: {answer}")
            count += 1
            if count >= 5: break
        if examples:
            return f"""
Here are some example questions and answers for this pack and topic:

{"\n\n".join(examples)}

Use the instructions and example questions as inspiration, but create entirely new questions that play with wordplay, allusions, and clever phrasing that ties to the topic without being too on-the-nose. Ensure you follow all instructions listed. Above all, the question and answer created must be correct. Do not let style or creativity override accuracy.
"""
        return ""

    async def _process_question_response(
        self,
        response: str,
        pack_id: str,
        pack_topic: str,
        difficulty_str: str
    ) -> List[Dict[str, Any]]:
        """Process the LLM response into structured question data."""
        try:
            target_difficulty = DifficultyLevel(difficulty_str.lower())
        except ValueError:
            logger.warning(f"Invalid target difficulty level '{difficulty_str}', defaulting to MEDIUM")
            target_difficulty = DifficultyLevel.MEDIUM

        questions_data = await parse_json_from_llm(response, [])

        if self.debug_enabled:
            print("\n=== Parsed JSON from LLM ===")
            print(f"Type: {type(questions_data)}")
            print(f"Content: {questions_data}")
            print("============================\n")

        structured_questions = []
        if isinstance(questions_data, list):
            for item in questions_data:
                if isinstance(item, dict) and "question" in item and "answer" in item:
                    question_text = clean_text(item["question"])
                    answer_text = clean_text(item["answer"])
                    if not question_text or not answer_text:
                        logger.warning(f"Skipping question with empty content/answer: {item}")
                        continue
                    question_dict = {
                        "question": question_text,
                        "answer": answer_text,
                        "pack_id": pack_id,
                        "pack_topics_item": pack_topic,
                        "difficulty_initial": target_difficulty,
                        "difficulty_current": target_difficulty
                    }
                    structured_questions.append(question_dict)
                    if self.debug_enabled:
                        print(f"Structured question: {json.dumps(question_dict, default=lambda x: x.value if isinstance(x, DifficultyLevel) else str(x))}")
                else:
                    logger.warning(f"Skipping invalid question format in LLM response: {item}")
        else:
            logger.error(f"Failed to parse questions response as a list: {type(questions_data)}")
            if self.debug_enabled:
                print(f"Failed to parse questions response as a list. Type: {type(questions_data)}")

        return structured_questions
</file>

<file path="backend/src/utils/question_generation/seed_question_processor.py">
# backend/src/utils/question_generation/seed_question_processor.py
"""
Utility for processing seed questions from various input formats (CSV, text)
and converting them to standardized JSON output.
"""

import json
import csv
import io
import re
from typing import Dict, Optional
import logging
from ...utils.llm.llm_service import LLMService
from ...utils.document_processing.processors import clean_text
from ...utils.llm.llm_parsing_utils import parse_json_from_llm

# Configure logger
logger = logging.getLogger(__name__)

class SeedQuestionProcessor:
    """
    Processes seed questions from various input formats and
    converts them to standardized JSON.
    """
    
    def __init__(self, llm_service: Optional[LLMService] = None):
        """
        Initialize with LLM service.
        
        Args:
            llm_service: Service for LLM interactions. If None, creates a new instance.
        """
        self.llm_service = llm_service or LLMService()
    
    async def process_csv_content(self, csv_content: str, 
                                  question_column: str = "question", 
                                  answer_column: str = "answer") -> Dict[str, str]:
        """
        Process CSV content to extract question-answer pairs.
        
        Args:
            csv_content: Raw CSV content as string
            question_column: Name of the column containing questions
            answer_column: Name of the column containing answers
            
        Returns:
            Dictionary of question-answer pairs
        """
        result = {}
        
        try:
            # Use CSV reader to parse the content
            csv_file = io.StringIO(csv_content)
            reader = csv.DictReader(csv_file)
            
            # Check if the required columns exist
            fieldnames = reader.fieldnames or []
            lowercase_fieldnames = [field.lower() for field in fieldnames]
            
            # Find the matching columns (case-insensitive)
            question_idx = None
            answer_idx = None
            
            for i, field in enumerate(lowercase_fieldnames):
                if field == question_column.lower():
                    question_idx = i
                elif field == answer_column.lower():
                    answer_idx = i
            
            # If column names don't match exactly, try to find by substring
            if question_idx is None:
                for i, field in enumerate(lowercase_fieldnames):
                    if "question" in field.lower():
                        question_idx = i
                        break
            
            if answer_idx is None:
                for i, field in enumerate(lowercase_fieldnames):
                    if "answer" in field.lower():
                        answer_idx = i
                        break
            
            # If still not found, use the first two columns
            if question_idx is None and len(fieldnames) > 0:
                question_idx = 0
            
            if answer_idx is None and len(fieldnames) > 1:
                answer_idx = 1
            
            # If we have the necessary columns, extract the Q&A pairs
            if question_idx is not None and answer_idx is not None:
                # Restart the reader from the beginning
                csv_file.seek(0)
                reader = csv.DictReader(csv_file)
                
                # Get the actual column names
                q_col = fieldnames[question_idx]
                a_col = fieldnames[answer_idx]
                
                for row in reader:
                    question = clean_text(row[q_col])
                    answer = clean_text(row[a_col])
                    
                    if question and answer:  # Only add non-empty pairs
                        result[question] = answer
            else:
                logger.warning(f"Required columns not found in CSV. Available columns: {fieldnames}")
        
        except Exception as e:
            logger.error(f"Error processing CSV content: {str(e)}")
            # Re-raise for proper error handling upstream
            raise
        
        return result
    
    async def process_text_content(self, text_content: str) -> Dict[str, str]:
        """
        Process raw text content using LLM to extract question-answer pairs.
        
        Args:
            text_content: Raw text containing questions and answers
            
        Returns:
            Dictionary of question-answer pairs
        """
        # Clean the text
        cleaned_text = clean_text(text_content)
        
        # Create prompt for LLM
        prompt = self._build_extraction_prompt(cleaned_text)
        
        # Generate JSON using LLM (CHANGED: removed await)
        raw_response = self.llm_service.generate_content(prompt)
        processed_response = self.llm_service.process_llm_response(raw_response)
        
        # Parse the JSON response
        result = await self._parse_json_response(processed_response)  # Kept await since this calls parse_json_from_llm
        
        return result
    
    def _build_extraction_prompt(self, text_content: str) -> str:
        """
        Build the prompt for LLM to extract question-answer pairs.
        
        Args:
            text_content: Cleaned text content
            
        Returns:
            Formatted prompt string
        """
        prompt = f"""Extract all question-answer pairs from the following text content. 
Return ONLY a valid JSON object where the keys are questions and the values are answers.

Text content:
{text_content}

Format the output as a valid JSON object with this structure:
{{
  "Question 1": "Answer 1",
  "Question 2": "Answer 2",
  "Question 3": "Answer 3"
}}

IMPORTANT: 
1. Extract ONLY clear question-answer pairs. Do not invent questions or answers.
2. Return ONLY the JSON object without any additional text or explanations.
3. Make sure the JSON is valid with proper escaping of special characters.
4. Do not include any text outside the JSON structure.
"""
        return prompt
    
    async def _parse_json_response(self, response: str) -> Dict[str, str]:  # Kept as async
        """
        Parse the JSON response from LLM.
        
        Args:
            response: JSON response from LLM
            
        Returns:
            Dictionary of question-answer pairs
        """
        try:
            # Use the existing LLM parsing utility from the codebase (KEPT: await since parse_json_from_llm is async)
            result = await parse_json_from_llm(response, {})
            
            # Ensure all keys and values are strings
            if isinstance(result, dict):
                return {str(k): str(v) for k, v in result.items()}
            else:
                logger.warning("Failed to extract valid JSON object from LLM response")
                
                # Fall back to regex-based extraction if needed
                qa_pattern = r'"([^"]+)"\s*:\s*"([^"]+)"'
                matches = re.findall(qa_pattern, response)
                
                if matches:
                    return {match[0]: match[1] for match in matches}
                return {}
                
        except Exception as e:
            logger.error(f"Error parsing JSON response: {str(e)}")
            return {}
    
    async def detect_and_process_input(self, input_content: str) -> Dict[str, str]:
        """
        Detect input type and process accordingly.
        
        Args:
            input_content: Raw input content (CSV or text)
            
        Returns:
            Dictionary of question-answer pairs
        """
        # Simple heuristic: if it contains commas and newlines, it's likely a CSV
        is_likely_csv = ',' in input_content and '\n' in input_content
        
        # Try to parse as CSV first if it looks like one
        if is_likely_csv:
            try:
                # Check if it has a header row with potential column names
                first_line = input_content.strip().split('\n')[0]
                if 'question' in first_line.lower() or 'answer' in first_line.lower():
                    result = await self.process_csv_content(input_content)
                    
                    # If we got results, return them
                    if result:
                        return result
                    
                    # If not, fall back to LLM processing
                    logger.warning("CSV detection failed to extract valid Q&A pairs, falling back to LLM processing")
            except Exception as e:
                logger.warning(f"CSV processing failed: {str(e)}, falling back to LLM processing")
        
        # If not CSV or CSV processing failed, use LLM to extract Q&A pairs
        return await self.process_text_content(input_content)
</file>

<file path="backend/src/utils/question_generation/text_utils.py">
# backend/src/utils/question_generation/text_utils.py
"""
Text utilities specifically for trivia question generation.
Leverages the document_processing utilities.
"""

import re
from typing import List
from ..document_processing.processors import clean_text, split_into_chunks
from ..llm.llm_parsing_utils import extract_bullet_list, format_as_bullet_list

def clean_trivia_text(text: str, remove_citations: bool = True) -> str:
    """
    Clean text specifically for trivia question content.
    
    Args:
        text: The input text to clean
        remove_citations: Whether to remove citation markers like [1], [2], etc.
        
    Returns:
        Cleaned text suitable for trivia
    """
    # Use clean_text from document_processing
    cleaned = clean_text(text, remove_extra_whitespace=True)
    
    # Additional cleaning specific to trivia content
    if remove_citations:
        # Remove citation markers like [1], [2], etc.
        cleaned = re.sub(r'\[\d+\]', '', cleaned)
    
    return cleaned

def chunk_trivia_content(content: str, difficulty: str) -> List[str]:
    """
    Split trivia content into appropriate chunks based on difficulty.
    
    Args:
        content: The content to split
        difficulty: Difficulty level affecting chunk size
        
    Returns:
        List of content chunks
    """
    # Adjust chunk size based on difficulty
    if difficulty.lower() == "easy":
        chunk_size = 800  # Smaller chunks for easy questions
    elif difficulty.lower() == "medium":
        chunk_size = 1200
    else:  # Hard or Expert
        chunk_size = 1600  # Larger chunks for hard/expert questions
    
    # Use split_into_chunks from document_processing
    return split_into_chunks(content, chunk_size=chunk_size, respect_sentences=True)
</file>

<file path="backend/src/utils/__init__.py">
# backend/src/utils/__init__.py
"""
Utilities module for the Trivia application.

This package contains utility functions and classes for various
application needs, including LLM integration and question generation.
"""

import uuid
import re
from typing import Union

# Update ensure_uuid to validate and return string UUIDs
def ensure_uuid(id_value: Union[str, uuid.UUID, bytes]) -> str:
    """
    Ensures the given value is a valid UUID and returns its string representation.
    
    Args:
        id_value: A string, UUID object, or bytes representing a UUID
        
    Returns:
        A string representation of the UUID
        
    Raises:
        ValueError: If the input cannot be converted to a UUID
    """
    # If already a string, validate it's a valid UUID format
    if isinstance(id_value, str):
        # Simple validation using regex pattern for UUID format
        uuid_pattern = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'
        if re.match(uuid_pattern, id_value.lower()):
            return id_value
        # If not matching the pattern, try to create a UUID to validate and get string
        return str(uuid.UUID(id_value))
    
    # If it's a UUID object, convert to string
    if isinstance(id_value, uuid.UUID):
        return str(id_value)
    
    # Otherwise try to create a UUID from the value
    return str(uuid.UUID(id_value))
</file>

<file path="backend/src/main.py">
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Depends, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
import logging
from contextlib import asynccontextmanager
from typing import Dict

# --- MODIFIED IMPORTS ---
from .api.routes import router as api_router
from .config.supabase_client import init_supabase_client, close_supabase_client
from .websocket_manager import ConnectionManager # Import the manager
from .utils import ensure_uuid # Import ensure_uuid
# --- END MODIFIED IMPORTS ---

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


# --- ADD Connection Manager Instance ---
# This instance will be shared across the application
connection_manager = ConnectionManager()
# --- END ADD ---


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Lifespan manager for FastAPI application.
    Initializes and closes resources when the application starts and shuts down.
    """
    # Initialize the Supabase client on startup
    logger.info("Initializing Supabase client...")
    supabase = await init_supabase_client()
    app.state.supabase = supabase

    # --- ADD Manager to App State ---
    # Make the manager instance available via app state for potential dependency injection
    app.state.connection_manager = connection_manager
    # --- END ADD ---

    logger.info("Application startup complete")
    yield

    # Close the Supabase client on shutdown
    logger.info("Closing Supabase client...")
    await close_supabase_client(app.state.supabase)
    logger.info("Application shutdown complete")

# Create FastAPI application
app = FastAPI(
    title="Trivia API",
    description="API for trivia pack and question generation",
    version="1.0.0",
    lifespan=lifespan,
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with specific origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include API routes
app.include_router(api_router, prefix="/api")

# --- ADD WebSocket Endpoint ---
@app.websocket("/ws/{game_id}/{user_id}")
async def websocket_endpoint(websocket: WebSocket, game_id: str, user_id: str):
    """WebSocket endpoint for real-time game communication."""
    try:
        # Basic validation (more robust validation might be needed depending on auth)
        game_id_uuid = ensure_uuid(game_id)
        user_id_uuid = ensure_uuid(user_id)
    except ValueError:
         logger.warning(f"WebSocket connection rejected: Invalid UUID format for game '{game_id}' or user '{user_id}'.")
         await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
         return

    # Use the global connection manager instance
    manager = app.state.connection_manager
    await manager.connect(websocket, game_id_uuid, user_id_uuid)

    # Example: Notify others that a user joined (moved this logic to GameService.join_game)
    # await manager.broadcast(
    #     {"type": "user_joined", "user_id": user_id_uuid, "game_id": game_id_uuid},
    #     game_id_uuid
    # )

    try:
        while True:
            # Keep connection open, listen for messages (optional)
            # If client sends messages, handle them here
            data = await websocket.receive_text()
            logger.debug(f"Received WebSocket message from {user_id_uuid} in {game_id_uuid}: {data}")
            # Example: Echo message back or handle specific commands
            # await manager.send_personal_message(f"You wrote: {data}", websocket)
    except WebSocketDisconnect:
        manager.disconnect(websocket, game_id_uuid, user_id_uuid)
        # Example: Notify others that a user left (move this logic to where disconnects are handled, e.g., GameService)
        # await manager.broadcast(
        #     {"type": "user_left", "user_id": user_id_uuid, "game_id": game_id_uuid},
        #     game_id_uuid
        # )
        logger.info(f"WebSocket disconnected cleanly for User {user_id_uuid} in Game {game_id_uuid}.")
    except Exception as e:
        # Log unexpected errors during WebSocket communication
        logger.error(f"WebSocket error for User {user_id_uuid} in Game {game_id_uuid}: {e}", exc_info=True)
        # Attempt to disconnect cleanly if possible
        manager.disconnect(websocket, game_id_uuid, user_id_uuid)
        # Optionally broadcast an error or disconnect message

# --- END ADD WebSocket Endpoint ---


@app.get("/")
async def root():
    """Root endpoint for health check."""
    return {"status": "ok", "message": "Trivia API is running"}

# Removed uvicorn runner - use run_api_server.py instead
# if __name__ == "__main__":
#     import uvicorn
#     uvicorn.run("src.main:app", host="0.0.0.0", port=8000, reload=True)
</file>

<file path="backend/src/websocket_manager.py">
# backend/src/websocket_manager.py
import asyncio
import json
import logging
from typing import Dict, List, Set, Optional
from fastapi import WebSocket

logger = logging.getLogger(__name__)

class ConnectionManager:
    """Manages active WebSocket connections for game rooms."""

    def __init__(self):
        # Structure: {game_id: {user_id: WebSocket}}
        self.active_connections: Dict[str, Dict[str, WebSocket]] = {}
        logger.info("ConnectionManager initialized.")

    async def connect(self, websocket: WebSocket, game_id: str, user_id: str):
        """Accepts and stores a new WebSocket connection."""
        await websocket.accept()
        if game_id not in self.active_connections:
            self.active_connections[game_id] = {}
        self.active_connections[game_id][user_id] = websocket
        logger.info(f"WebSocket connected: User {user_id} in Game {game_id}. Total in game: {len(self.active_connections[game_id])}")
        # Optionally send a welcome message or current state upon connection
        # await self.send_personal_message({"type": "status", "message": "Connected"}, websocket)

    def disconnect(self, websocket: WebSocket, game_id: str, user_id: str):
        """Removes a WebSocket connection."""
        if game_id in self.active_connections:
            if user_id in self.active_connections[game_id]:
                # Ensure the websocket object matches before deleting, though user_id should be unique per game
                if self.active_connections[game_id][user_id] == websocket:
                    del self.active_connections[game_id][user_id]
                    logger.info(f"WebSocket disconnected: User {user_id} from Game {game_id}.")
                    if not self.active_connections[game_id]:
                        del self.active_connections[game_id]
                        logger.info(f"Game room {game_id} empty, removed.")
            else:
                 logger.warning(f"User {user_id} not found in game {game_id} during disconnect.")
        else:
             logger.warning(f"Game room {game_id} not found during disconnect for user {user_id}.")


    async def send_personal_message(self, message: dict, websocket: WebSocket):
        """Sends a JSON message to a specific WebSocket client."""
        try:
            await websocket.send_json(message)
        except Exception as e:
            # Log error, connection might be closed unexpectedly
            logger.error(f"Failed to send personal message: {e}", exc_info=False) # Avoid full tb for send errors usually

    async def broadcast(self, message: dict, game_id: str):
        """Broadcasts a JSON message to all clients in a specific game room."""
        if game_id in self.active_connections:
            connections = list(self.active_connections[game_id].values()) # Create list to avoid issues if dict changes during iteration
            message_json = json.dumps(message) # Serialize once
            logger.debug(f"Broadcasting to {len(connections)} clients in game {game_id}: {message_json}")

            # Use asyncio.gather for concurrent sending
            results = await asyncio.gather(
                *[conn.send_text(message_json) for conn in connections],
                return_exceptions=True
            )

            # Log any exceptions that occurred during sending
            for i, result in enumerate(results):
                if isinstance(result, Exception):
                     # Find the user_id associated with the failed connection if possible
                     failed_user_id = "unknown"
                     for uid, ws in self.active_connections.get(game_id, {}).items():
                         if ws == connections[i]:
                             failed_user_id = uid
                             break
                     logger.error(f"Failed to broadcast to user {failed_user_id} in game {game_id}: {result}", exc_info=False)
                     # Consider removing the problematic connection here if appropriate
                     # self.disconnect(connections[i], game_id, failed_user_id)
        else:
            logger.warning(f"Attempted to broadcast to non-existent game room: {game_id}")

    async def broadcast_to_others(self, message: dict, game_id: str, sender_user_id: str):
        """Broadcasts a JSON message to all clients in a room EXCEPT the sender."""
        if game_id in self.active_connections:
            message_json = json.dumps(message)
            tasks = []
            count = 0
            for user_id, websocket in self.active_connections[game_id].items():
                if user_id != sender_user_id:
                    tasks.append(websocket.send_text(message_json))
                    count += 1

            logger.debug(f"Broadcasting to {count} others in game {game_id} (excluding {sender_user_id}): {message_json}")
            results = await asyncio.gather(*tasks, return_exceptions=True)

            # Log any exceptions
            # (Error logging similar to broadcast can be added here if needed)


    def get_connected_user_ids(self, game_id: str) -> List[str]:
         """Returns a list of user IDs currently connected in a game room."""
         if game_id in self.active_connections:
             return list(self.active_connections[game_id].keys())
         return []
</file>

<file path="backend/tests/test_api.py">
import requests
import json
import sys
import time
import argparse
from typing import Dict, List, Any, Optional
from enum import Enum
import uuid
import os # Added os
from pathlib import Path # Added Path

# --- ADD THIS BLOCK ---
# Add the project root (backend/) to the Python path
# This allows importing 'src' even when running this script directly from tests/
script_path = Path(__file__).resolve() # Gets the path of the current script
project_root = script_path.parent.parent # Go up two levels (tests/ -> backend/)
sys.path.insert(0, str(project_root))
# --- END ADDED BLOCK ---

# Imports from src should now work
# e.g., if you needed to import something from src: from src.models import Pack

# API base URL
BASE_URL = "http://localhost:8000/api"

# ANSI color codes for terminal output
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# Test case result type
class ResultType(Enum):
    SUCCESS = "SUCCESS"
    FAIL = "FAIL"
    SKIP = "SKIP"

class APITester:
    def __init__(self, base_url: str = BASE_URL, verbose: bool = False):
        """Initialize the API tester."""
        self.base_url = base_url
        self.verbose = verbose
        self.pack_id = None
        self.results = []

    def log(self, message: str, end="\n") -> None:
        """Log a message if verbose mode is enabled."""
        if self.verbose:
            print(message, end=end)

    def print_json(self, data: Any) -> None:
        """Pretty print JSON data."""
        if self.verbose:
            print(json.dumps(data, indent=2))

    def record_result(self, test_name: str, result_type: ResultType, message: str = "", data: Any = None) -> None:
        """Record the test result."""
        self.results.append({
            "test_name": test_name,
            "result_type": result_type,
            "message": message,
            "data": data
        })

        # Print result to console
        color = Colors.GREEN if result_type == ResultType.SUCCESS else \
                Colors.WARNING if result_type == ResultType.SKIP else Colors.FAIL

        result_str = f"{color}{result_type.value}{Colors.ENDC}"
        message_str = f" - {message}" if message else ""

        print(f"{test_name}: {result_str}{message_str}")

        if data and self.verbose:
            self.print_json(data)

    def run_test(self, test_func, test_name: str, skip_condition: bool = False) -> Any:
        """Run a test function and record the result."""
        if skip_condition:
            self.record_result(test_name, ResultType.SKIP, "Test skipped due to dependency failure")
            return None

        try:
            print(f"{Colors.BOLD}Running test: {test_name}{Colors.ENDC}")
            result = test_func()
            return result
        except Exception as e:
            self.record_result(test_name, ResultType.FAIL, f"Exception: {str(e)}")
            if self.verbose:
                import traceback
                traceback.print_exc()
            return None

    def test_pack_creation(self) -> str:
        """Test creating a new pack."""
        test_name = "Create Pack"

        # Generate a unique pack name to avoid conflicts
        pack_name = f"Test Pack {uuid.uuid4().hex[:8]}"

        data = {
            "name": pack_name,
            "description": "A test pack for API testing",
            "price": 0.0,
            "creator_type": "system"
        }

        self.log(f"Creating pack with name: {pack_name}")
        response = requests.post(f"{self.base_url}/packs/", json=data)

        if response.status_code == 201:
            response_data = response.json()
            pack_id = response_data.get("id")
            self.pack_id = pack_id
            self.record_result(test_name, ResultType.SUCCESS, f"Created pack: {pack_name}", response_data)
            return pack_id
        else:
            self.record_result(test_name, ResultType.FAIL, f"Failed with status code: {response.status_code}", response.json())
            return None

    def test_generate_topics(self) -> List[str]:
        """Test generating topics for a pack."""
        test_name = "Generate Topics"

        if not self.pack_id:
            self.record_result(test_name, ResultType.SKIP, "No pack ID available")
            return None

        # --- MODIFIED: Removed creation_name ---
        data = {
            "num_topics": 5
            # "creation_name": "Test Pack" # Removed
        }
        # --- END MODIFIED ---

        self.log(f"Generating topics for pack ID: {self.pack_id}")
        response = requests.post(f"{self.base_url}/packs/{self.pack_id}/topics/", json=data)

        if response.status_code == 200:
            response_data = response.json()
            topics = response_data.get("topics", [])
            self.record_result(test_name, ResultType.SUCCESS, f"Generated {len(topics)} topics", response_data)
            return topics
        else:
            self.record_result(test_name, ResultType.FAIL, f"Failed with status code: {response.status_code}", response.json())
            return None

    def test_get_topics(self) -> List[str]:
        """Test retrieving topics for a pack."""
        test_name = "Get Topics"

        if not self.pack_id:
            self.record_result(test_name, ResultType.SKIP, "No pack ID available")
            return None

        self.log(f"Getting topics for pack ID: {self.pack_id}")
        response = requests.get(f"{self.base_url}/packs/{self.pack_id}/topics/")

        if response.status_code == 200:
            response_data = response.json()
            topics = response_data.get("topics", [])
            self.record_result(test_name, ResultType.SUCCESS, f"Retrieved {len(topics)} topics", response_data)
            return topics
        else:
            self.record_result(test_name, ResultType.FAIL, f"Failed with status code: {response.status_code}", response.json())
            return None

    def test_generate_difficulties(self) -> Dict[str, Any]:
        """Test generating difficulty descriptions for a pack."""
        test_name = "Generate Difficulties"

        if not self.pack_id:
            self.record_result(test_name, ResultType.SKIP, "No pack ID available")
            return None

        # --- MODIFIED: Removed creation_name ---
        data = {
            # "creation_name": "Test Pack", # Removed
            "force_regenerate": True
        }
        # --- END MODIFIED ---

        self.log(f"Generating difficulty descriptions for pack ID: {self.pack_id}")
        response = requests.post(f"{self.base_url}/packs/{self.pack_id}/difficulties/", json=data)

        if response.status_code == 200:
            response_data = response.json()
            descriptions = response_data.get("descriptions", {})
            self.record_result(test_name, ResultType.SUCCESS, f"Generated difficulty descriptions", response_data)
            return descriptions
        else:
            self.record_result(test_name, ResultType.FAIL, f"Failed with status code: {response.status_code}", response.json())
            return None

    def test_get_difficulties(self) -> Dict[str, Any]:
        """Test retrieving difficulty descriptions for a pack."""
        test_name = "Get Difficulties"

        if not self.pack_id:
            self.record_result(test_name, ResultType.SKIP, "No pack ID available")
            return None

        self.log(f"Getting difficulty descriptions for pack ID: {self.pack_id}")
        response = requests.get(f"{self.base_url}/packs/{self.pack_id}/difficulties/")

        if response.status_code == 200:
            response_data = response.json()
            descriptions = response_data.get("descriptions", {})
            self.record_result(test_name, ResultType.SUCCESS, f"Retrieved difficulty descriptions", response_data)
            return descriptions
        else:
            self.record_result(test_name, ResultType.FAIL, f"Failed with status code: {response.status_code}", response.json())
            return None

    def test_store_seed_questions(self) -> Dict[str, str]:
        """Test storing seed questions for a pack."""
        test_name = "Store Seed Questions"

        if not self.pack_id:
            self.record_result(test_name, ResultType.SKIP, "No pack ID available")
            return None

        data = {
            "seed_questions": {
                "What is the capital of France?": "Paris",
                "Who wrote 'Romeo and Juliet'?": "William Shakespeare",
                "What is the chemical symbol for gold?": "Au"
            }
        }

        self.log(f"Storing seed questions for pack ID: {self.pack_id}")
        response = requests.post(f"{self.base_url}/packs/{self.pack_id}/questions/seed", json=data)

        if response.status_code == 200:
            response_data = response.json()
            seed_questions = response_data.get("seed_questions", {})
            self.record_result(test_name, ResultType.SUCCESS, f"Stored {len(seed_questions)} seed questions", response_data)
            return seed_questions
        else:
            self.record_result(test_name, ResultType.FAIL, f"Failed with status code: {response.status_code}", response.json())
            return None

    def test_extract_seed_questions(self) -> Dict[str, str]:
        """Test extracting seed questions from text."""
        test_name = "Extract Seed Questions"

        if not self.pack_id:
            self.record_result(test_name, ResultType.SKIP, "No pack ID available")
            return None

        data = {
            "text_content": """
            Q: What is the largest planet in our solar system?
            A: Jupiter

            Question: How many continents are there on Earth?
            Answer: Seven

            Q: Who painted the Mona Lisa?
            A: Leonardo da Vinci
            """
        }

        self.log(f"Extracting seed questions for pack ID: {self.pack_id}")
        response = requests.post(f"{self.base_url}/packs/{self.pack_id}/questions/seed/extract", json=data)

        if response.status_code == 200:
            response_data = response.json()
            seed_questions = response_data.get("seed_questions", {})
            self.record_result(test_name, ResultType.SUCCESS, f"Extracted {len(seed_questions)} seed questions", response_data)
            return seed_questions
        else:
            self.record_result(test_name, ResultType.FAIL, f"Failed with status code: {response.status_code}", response.json())
            return None

    def test_get_seed_questions(self) -> Dict[str, str]:
        """Test retrieving seed questions for a pack."""
        test_name = "Get Seed Questions"

        if not self.pack_id:
            self.record_result(test_name, ResultType.SKIP, "No pack ID available")
            return None

        self.log(f"Getting seed questions for pack ID: {self.pack_id}")
        response = requests.get(f"{self.base_url}/packs/{self.pack_id}/questions/seed")

        if response.status_code == 200:
            response_data = response.json()
            seed_questions = response_data.get("seed_questions", {})
            self.record_result(test_name, ResultType.SUCCESS, f"Retrieved {len(seed_questions)} seed questions", response_data)
            return seed_questions
        else:
            self.record_result(test_name, ResultType.FAIL, f"Failed with status code: {response.status_code}", response.json())
            return None

    def test_generate_questions(self, topic: str = None) -> List[Dict[str, Any]]:
        """Test generating questions for a pack."""
        test_name = "Generate Questions"

        if not self.pack_id:
            self.record_result(test_name, ResultType.SKIP, "No pack ID available")
            return None

        # Get topics if not provided
        if not topic:
            topics = self.test_get_topics()
            if topics and len(topics) > 0:
                topic = topics[0]
            else:
                self.record_result(test_name, ResultType.SKIP, "No topics available")
                return None

        data = {
            "pack_topic": topic,
            "difficulty": "medium",
            "num_questions": 3,
            "debug_mode": self.verbose
        }

        self.log(f"Generating questions for pack ID: {self.pack_id}, topic: {topic}")
        response = requests.post(f"{self.base_url}/packs/{self.pack_id}/questions/", json=data)

        if response.status_code == 200:
            response_data = response.json()
            questions = response_data.get("questions", [])
            self.record_result(test_name, ResultType.SUCCESS, f"Generated {len(questions)} questions", response_data)
            return questions
        else:
            self.record_result(test_name, ResultType.FAIL, f"Failed with status code: {response.status_code}", response.json())
            return None

    def test_get_questions(self) -> List[Dict[str, Any]]:
        """Test retrieving questions for a pack."""
        test_name = "Get Questions"

        if not self.pack_id:
            self.record_result(test_name, ResultType.SKIP, "No pack ID available")
            return None

        self.log(f"Getting questions for pack ID: {self.pack_id}")
        response = requests.get(f"{self.base_url}/packs/{self.pack_id}/questions/")

        if response.status_code == 200:
            response_data = response.json()
            questions = response_data.get("questions", [])
            self.record_result(test_name, ResultType.SUCCESS, f"Retrieved {len(questions)} questions", response_data)
            return questions
        else:
            self.record_result(test_name, ResultType.FAIL, f"Failed with status code: {response.status_code}", response.json())
            return None

    def run_all_tests(self) -> None:
        """Run all API tests in sequence."""
        print(f"{Colors.HEADER}Starting API Tests{Colors.ENDC}")
        print(f"Base URL: {self.base_url}")

        # Test creating a pack
        pack_id = self.run_test(self.test_pack_creation, "Create Pack")

        # Don't continue if pack creation failed
        if not pack_id:
            print(f"{Colors.FAIL}Pack creation failed. Stopping tests.{Colors.ENDC}")
            return

        # Test generating topics
        topics = self.run_test(self.test_generate_topics, "Generate Topics")

        # Test retrieving topics
        topics = self.run_test(self.test_get_topics, "Get Topics")

        # Test generating difficulties (only if we have topics)
        difficulties = self.run_test(self.test_generate_difficulties, "Generate Difficulties",
                                    skip_condition=not topics or len(topics) == 0)

        # Test retrieving difficulties
        difficulties = self.run_test(self.test_get_difficulties, "Get Difficulties")

        # Test storing seed questions
        seed_questions = self.run_test(self.test_store_seed_questions, "Store Seed Questions")

        # Test extracting seed questions
        extracted_questions = self.run_test(self.test_extract_seed_questions, "Extract Seed Questions")

        # Test retrieving seed questions
        seed_questions = self.run_test(self.test_get_seed_questions, "Get Seed Questions")

        # Test generating questions
        selected_topic = topics[0] if topics and len(topics) > 0 else None
        questions = self.run_test(
            lambda: self.test_generate_questions(selected_topic),
            "Generate Questions",
            skip_condition=not selected_topic
        )

        # Test retrieving questions
        questions = self.run_test(self.test_get_questions, "Get Questions")

        # Print summary
        self.print_summary()

    def print_summary(self) -> None:
        """Print a summary of all test results."""
        total = len(self.results)
        success_count = sum(1 for r in self.results if r["result_type"] == ResultType.SUCCESS)
        fail_count = sum(1 for r in self.results if r["result_type"] == ResultType.FAIL)
        skip_count = sum(1 for r in self.results if r["result_type"] == ResultType.SKIP)

        print("\n" + "=" * 50)
        print(f"{Colors.HEADER}Test Summary{Colors.ENDC}")
        print(f"Total tests: {total}")
        print(f"Successful: {Colors.GREEN}{success_count}{Colors.ENDC}")
        print(f"Failed: {Colors.FAIL}{fail_count}{Colors.ENDC}")
        print(f"Skipped: {Colors.WARNING}{skip_count}{Colors.ENDC}")
        print("=" * 50)

        if self.pack_id:
            print(f"\nPack ID: {self.pack_id}")
            print(f"You can continue testing this pack in the Swagger UI: {Colors.BLUE}http://localhost:8000/docs{Colors.ENDC}")

def main():
    parser = argparse.ArgumentParser(description="Test the Trivia API endpoints")
    parser.add_argument("--base-url", default=BASE_URL, help="Base URL for the API")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output")
    parser.add_argument("--pack-id", help="Use an existing pack ID instead of creating a new one")
    args = parser.parse_args()

    tester = APITester(base_url=args.base_url, verbose=args.verbose)

    if args.pack_id:
        tester.pack_id = args.pack_id
        print(f"Using existing pack ID: {tester.pack_id}")

    tester.run_all_tests()

if __name__ == "__main__":
    main()
</file>

<file path="backend/tests/test_batch_generator.py">
#!/usr/bin/env python
# Example (topics provided, auto-instructions per topic):
# python3 tests/test_batch_generator.py -p "World Geography Batch" -t "Capital Cities" "Major Rivers" -n 4 --difficulty easy medium -v
# Example (topics generated, auto-instructions per topic):
# python3 tests/test_batch_generator.py -p "Random History Batch" --num-generated-topics 3 -n 5 --difficulty medium hard -v
# Example (disable auto-instructions):
# python3 tests/test_batch_generator.py -p "SciFi Books Batch" --num-generated-topics 2 -n 3 --no-auto-instructions --difficulty easy hard expert -v

import requests
import json
import argparse
import sys
import uuid
import time
from typing import Dict, List, Any, Optional
import os
import traceback
import asyncio
from pathlib import Path # Added Path

# --- ADD THIS BLOCK ---
# Add the project root (backend/) to the Python path
script_path = Path(__file__).resolve()
project_root = script_path.parent.parent
sys.path.insert(0, str(project_root))
# --- END ADDED BLOCK ---

# Imports from src should now work (if any were needed)

# API base URL
BASE_URL = "http://localhost:8000/api"

# ANSI color codes
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# --- Helper Functions (print_step, print_json, make_request, create_or_get_pack, add_provided_topics_to_pack, generate_api_topics, generate_difficulties, process_seed_questions) ---
# (These helpers remain largely unchanged)

def print_step(message: str):
    print(f"\n{Colors.HEADER}--- {message} ---{Colors.ENDC}")

def print_json(data: Any) -> None:
    """Pretty print JSON data."""
    try:
        print(json.dumps(data, indent=2))
    except TypeError:
        print(str(data))

def make_request(method: str, endpoint: str, json_data: Optional[Dict] = None, params: Optional[Dict] = None, timeout: int = 300) -> Optional[requests.Response]:
    """Helper function to make API requests and handle basic errors."""
    url = f"{BASE_URL}{endpoint}"
    print(f"{Colors.CYAN}Requesting: {method.upper()} {url}{Colors.ENDC}")
    if params:
        print(f"Params: {params}")
    if json_data:
        print(f"Data:")
        print_json(json_data)

    try:
        response = requests.request(method, url, json=json_data, params=params, timeout=timeout)
        print(f"Response Status: {response.status_code}")
        global args # Access global args
        if response.status_code >= 400 or (args and args.verbose):
             print(f"{Colors.WARNING if response.status_code >= 400 else Colors.CYAN}Response Content:{Colors.ENDC}")
             try:
                 print_json(response.json())
             except json.JSONDecodeError:
                 print(response.text[:500] + "..." if len(response.text) > 500 else response.text)
        return response
    except requests.exceptions.RequestException as e:
        print(f"{Colors.FAIL}API request failed: {e}{Colors.ENDC}")
        return None

def create_or_get_pack(pack_name: str) -> Optional[str]:
    """Create a new pack or get ID if it exists."""
    print_step(f"Ensuring pack '{pack_name}' exists")
    list_response = make_request("GET", "/packs/")
    if list_response and list_response.status_code == 200:
        packs = list_response.json().get("packs", [])
        for p in packs:
            if p['name'].lower() == pack_name.lower():
                pack_id = p['id']
                print(f"{Colors.GREEN}Found existing pack '{pack_name}' with ID: {pack_id}{Colors.ENDC}")
                return pack_id

    data = {"name": pack_name, "description": f"Test pack for batch generation", "price": 0.0, "creator_type": "system"}
    create_response = make_request("POST", "/packs/", json_data=data)
    if create_response and create_response.status_code == 201:
        pack_id = create_response.json().get("id")
        print(f"{Colors.GREEN}Successfully created pack '{pack_name}' with ID: {pack_id}{Colors.ENDC}")
        return pack_id
    else:
        print(f"{Colors.FAIL}Failed to create or find pack '{pack_name}'. Status: {create_response.status_code if create_response else 'N/A'}{Colors.ENDC}")
        return None

def add_provided_topics_to_pack(pack_id: str, topics: List[str]) -> bool:
    """Adds multiple specific topics (provided by user) to a pack."""
    print_step(f"Adding {len(topics)} user-provided topics to pack {pack_id}")
    if not topics:
        print(f"{Colors.WARNING}No topics provided to add.{Colors.ENDC}")
        return False

    all_added = True
    current_topics = []

    # Get existing topics first
    get_response = make_request("GET", f"/packs/{pack_id}/topics/")
    if get_response and get_response.status_code == 200:
        current_topics = get_response.json().get("topics", [])
        print(f"  Existing topics: {current_topics}")

    topics_to_add = [t for t in topics if t not in current_topics]
    if not topics_to_add:
        print(f"{Colors.GREEN}All specified topics already exist in the pack.{Colors.ENDC}")
        return True

    # Add the first *new* topic using the main endpoint if no topics existed before
    start_index = 0
    if not current_topics and topics_to_add:
        first_new_topic = topics_to_add[0]
        print(f"  Adding first new topic: '{first_new_topic}' using /topics/")
        data = {"predefined_topic": first_new_topic}
        response = make_request("POST", f"/packs/{pack_id}/topics/", json_data=data)
        if response and response.status_code == 200:
            current_topics = response.json().get("topics", []) # Update current topics
            if first_new_topic not in current_topics:
                print(f"{Colors.FAIL}  Failed to add first new topic '{first_new_topic}'{Colors.ENDC}")
                all_added = False
            else:
                 print(f"{Colors.GREEN}  Added '{first_new_topic}'. Current topics: {current_topics}{Colors.ENDC}")
        else:
            print(f"{Colors.FAIL}  Failed initial topic add request for '{first_new_topic}'{Colors.ENDC}")
            all_added = False
        start_index = 1 # Move to the next topic

    # Add remaining new topics using the additional endpoint
    for topic in topics_to_add[start_index:]:
        print(f"  Adding additional topic: '{topic}' using /topics/additional")
        data = {"predefined_topic": topic}
        response = make_request("POST", f"/packs/{pack_id}/topics/additional", json_data=data)
        if response and response.status_code == 200:
             current_topics = response.json().get("topics", []) # Update current topics
             if topic not in current_topics:
                 print(f"{Colors.FAIL}  Failed to add additional topic '{topic}'{Colors.ENDC}")
                 all_added = False
             else:
                  print(f"{Colors.GREEN}  Added '{topic}'. Current topics: {current_topics}{Colors.ENDC}")
        else:
            print(f"{Colors.FAIL}  Failed additional topic add request for '{topic}'{Colors.ENDC}")
            all_added = False
        time.sleep(0.2) # Slight delay between API calls

    return all_added

def generate_api_topics(pack_id: str, num_topics: int) -> Optional[List[str]]:
    """Generates topics using the API endpoint."""
    print_step(f"Generating {num_topics} topics via API for pack {pack_id}")
    data = {"num_topics": num_topics}
    response = make_request("POST", f"/packs/{pack_id}/topics/", json_data=data)
    if response and response.status_code == 200:
        generated_topics = response.json().get("topics", [])
        if generated_topics:
            print(f"{Colors.GREEN}Successfully generated {len(generated_topics)} topics via API:{Colors.ENDC}")
            for t in generated_topics: print(f"  - {t}")
            return generated_topics
    print(f"{Colors.FAIL}Failed to generate topics via API.{Colors.ENDC}")
    return None

def generate_difficulties(pack_id: str) -> bool:
    """Generate difficulty descriptions for a pack."""
    print_step(f"Generating/Ensuring difficulty descriptions for pack {pack_id}")
    data = {"force_regenerate": False} # Don't force unless needed
    response = make_request("POST", f"/packs/{pack_id}/difficulties/", json_data=data)
    if response and response.status_code == 200:
        print(f"{Colors.GREEN}Successfully generated/ensured difficulty descriptions{Colors.ENDC}")
        return True
    print(f"{Colors.FAIL}Failed to generate difficulty descriptions.{Colors.ENDC}")
    return False

def process_seed_questions(pack_id: str, seed_questions_file: Optional[str]) -> bool:
    """Process seed questions from a file, if provided."""
    if not seed_questions_file:
        print(f"{Colors.CYAN}No seed questions file provided, skipping.{Colors.ENDC}")
        return True

    if not os.path.exists(seed_questions_file):
        print(f"{Colors.FAIL}Seed questions file not found: {seed_questions_file}{Colors.ENDC}")
        return False

    print_step(f"Processing seed questions from {seed_questions_file}")
    try:
        # Construct the correct path relative to the script location
        script_dir = Path(__file__).parent
        absolute_seed_path = script_dir.parent / seed_questions_file # Assumes seed file is in backend/
        if not absolute_seed_path.exists():
             print(f"{Colors.FAIL}Seed file not found at expected location: {absolute_seed_path}{Colors.ENDC}")
             return False

        with open(absolute_seed_path, 'r') as f: seed_content = f.read()
        data = {"text_content": seed_content}
        response = make_request("POST", f"/packs/{pack_id}/questions/seed/extract", json_data=data)
        if response and response.status_code == 200:
            count = response.json().get("count", 0)
            print(f"{Colors.GREEN}Successfully extracted and stored {count} seed questions{Colors.ENDC}")
            return True
    except Exception as e:
        print(f"{Colors.FAIL}Error processing seed questions file: {str(e)}{Colors.ENDC}")
        print(traceback.format_exc())

    print(f"{Colors.FAIL}Failed to extract/store seed questions.{Colors.ENDC}")
    return False


def trigger_batch_question_generation(pack_id: str, topic_configs: List[Dict], regenerate_instructions: bool, debug_mode: bool) -> Optional[Dict[str, Any]]:
    """Trigger the batch question generation and incorrect answer process."""
    num_configs = sum(len(tc.get("difficulty_configs", [])) for tc in topic_configs)
    print_step(f"Triggering batch question generation for {len(topic_configs)} topics across {num_configs} difficulty configs")
    data = {
        "topic_configs": topic_configs,
        "regenerate_instructions": regenerate_instructions,
        "debug_mode": debug_mode
        }
    response = make_request("POST", f"/packs/{pack_id}/questions/batch-generate", json_data=data, timeout=900)
    if response and response.status_code == 200:
        result = response.json()
        print(f"{Colors.GREEN}Batch generation request completed.{Colors.ENDC}")
        print(f"  Status: {result.get('status', 'UNKNOWN')}")
        print(f"  Topics Processed (>=1 success): {len(result.get('topics_processed', []))}")
        print(f"  Total Questions Generated: {result.get('total_questions_generated', 0)}")
        if result.get('errors'): print(f"{Colors.WARNING}  Errors occurred for topics (>=1 failure): {result['errors']}{Colors.ENDC}")
        return result
    print(f"{Colors.FAIL}Batch generation request failed. Status: {response.status_code if response else 'N/A'}{Colors.ENDC}")
    return None

def verify_questions_exist(pack_id: str, expected_topics: List[str], expected_total_questions: int, batch_result: Optional[Dict]) -> bool:
    """Verify if questions were created, considering the batch status."""
    if not batch_result:
        print_step(f"Verifying question creation for pack {pack_id} (Batch Request Failed)")
        print(f"{Colors.FAIL}Verification skipped as batch request failed.{Colors.ENDC}")
        return False

    batch_status = batch_result.get('status', 'failed')
    actual_generated_count = batch_result.get('total_questions_generated', 0)
    processed_topics = batch_result.get('topics_processed', [])
    failed_topics_reported = batch_result.get('errors')

    print_step(f"Verifying question creation for pack {pack_id} (Batch Status: {batch_status})")

    # Fetch questions from API to double-check
    params = {"limit": expected_total_questions + 50}
    response = make_request("GET", f"/packs/{pack_id}/questions/", params=params)
    api_found_questions = []
    api_found_topics = set()
    api_found_count = 0
    if response and response.status_code == 200:
        api_found_questions = response.json().get("questions", [])
        api_found_count = len(api_found_questions)
        api_found_topics = {q.get("pack_topics_item") for q in api_found_questions if q.get("pack_topics_item")}
        print(f"  API check found {api_found_count} questions in total.")
        print(f"  API check found topics: {api_found_topics}")
    else:
        print(f"{Colors.WARNING}  API check failed to retrieve questions. Relying solely on batch response.{Colors.ENDC}")

    # Verification Logic
    success = True
    expected_topics_lower = {t.lower() for t in expected_topics}
    processed_topics_lower = {t.lower() for t in processed_topics}
    failed_topics_reported_lower = set()
    if failed_topics_reported is not None:
        failed_topics_reported_lower = {t.lower() for t in failed_topics_reported}

    if batch_status == "completed":
        print("  Checking 'completed' status...")
        if actual_generated_count < expected_total_questions:
            success = False
            print(f"{Colors.FAIL}  Mismatch: Status 'completed' but batch reported fewer questions ({actual_generated_count}) than expected ({expected_total_questions}).{Colors.ENDC}")
        if api_found_count != actual_generated_count:
             print(f"{Colors.WARNING}  API Count Mismatch: Batch reported {actual_generated_count} generated, but API found {api_found_count}.{Colors.ENDC}")

        missing_processed = expected_topics_lower - processed_topics_lower
        if missing_processed:
            success = False
            print(f"{Colors.FAIL}  Mismatch: Status 'completed' but expected topics missing from 'topics_processed': {missing_processed}{Colors.ENDC}")

        if failed_topics_reported is not None:
            success = False
            print(f"{Colors.FAIL}  Mismatch: Status 'completed' but 'errors' list is not null/empty: {failed_topics_reported}{Colors.ENDC}")

    elif batch_status == "partial_failure":
        print("  Checking 'partial_failure' status...")
        if actual_generated_count == 0 and expected_total_questions > 0:
            print(f"{Colors.WARNING}  Status 'partial_failure' but 0 questions generated by batch.{Colors.ENDC}")
        elif actual_generated_count >= expected_total_questions:
             print(f"{Colors.WARNING}  Status 'partial_failure' but batch reported generating all/more ({actual_generated_count}) questions than expected ({expected_total_questions}).{Colors.ENDC}")

        if failed_topics_reported is None:
             print(f"{Colors.WARNING}  Mismatch: Status 'partial_failure' but 'errors' list is null/missing.{Colors.ENDC}")
        if not processed_topics and actual_generated_count > 0:
             print(f"{Colors.WARNING}  Mismatch: Status 'partial_failure' with questions generated ({actual_generated_count}), but 'topics_processed' list is empty.{Colors.ENDC}")

        if api_found_count != actual_generated_count:
            print(f"{Colors.WARNING}  API Count Mismatch: Batch reported {actual_generated_count} generated, but API found {api_found_count}.{Colors.ENDC}")

    elif batch_status == "failed":
        print("  Checking 'failed' status...")
        if actual_generated_count > 0:
            success = False
            print(f"{Colors.FAIL}  Mismatch: Status 'failed' but batch reported {actual_generated_count} questions generated.{Colors.ENDC}")
        if api_found_count > 0:
             print(f"{Colors.WARNING}  API Count Mismatch: Status 'failed' but API found {api_found_count} questions.{Colors.ENDC}")
        if processed_topics:
            success = False
            print(f"{Colors.FAIL}  Mismatch: Status 'failed' but 'topics_processed' is not empty: {processed_topics}{Colors.ENDC}")
    else:
        success = False
        print(f"{Colors.FAIL}  Unknown batch status reported: '{batch_status}'. Verification failed.{Colors.ENDC}")

    if success:
        print(f"{Colors.GREEN}Verification check passed for batch status '{batch_status}'.{Colors.ENDC}")
    else:
        print(f"{Colors.FAIL}Verification check failed for batch status '{batch_status}'.{Colors.ENDC}")

    return success

# Main Test Flow
def run_batch_test_flow(args: argparse.Namespace):
    """Orchestrate the batch test steps."""
    pack_id = create_or_get_pack(args.pack_name)
    if not pack_id: return

    topics_to_use = []
    if args.topics:
        print(f"{Colors.CYAN}Using provided topics: {args.topics}{Colors.ENDC}")
        if not add_provided_topics_to_pack(pack_id, args.topics): print(f"{Colors.FAIL}Stopping test: provided topics not added.{Colors.ENDC}"); return
        topics_to_use = args.topics
    else:
        print(f"{Colors.CYAN}No topics provided, generating {args.num_generated_topics} via API...{Colors.ENDC}")
        generated_topics = generate_api_topics(pack_id, args.num_generated_topics)
        if not generated_topics: print(f"{Colors.FAIL}Stopping test: API topic generation failed.{Colors.ENDC}"); return
        topics_to_use = generated_topics
    if not topics_to_use: print(f"{Colors.FAIL}No topics available. Exiting.{Colors.ENDC}"); return

    if not generate_difficulties(pack_id): print(f"{Colors.WARNING}Failed generating difficulties, continuing cautiously...{Colors.ENDC}")
    process_seed_questions(pack_id, args.seed_questions)

    # Prepare topic configurations for the batch request
    topic_configs = []
    expected_total_questions = 0
    for topic in topics_to_use:
        difficulty_configs = []
        for diff_level in args.difficulty:
            difficulty_configs.append({"difficulty": diff_level, "num_questions": args.num_questions_per_difficulty})
            expected_total_questions += args.num_questions_per_difficulty
        topic_configs.append({"topic": topic, "difficulty_configs": difficulty_configs})

    # Trigger batch generation
    batch_result = trigger_batch_question_generation(
        pack_id,
        topic_configs,
        args.regenerate_instructions,
        args.debug
        )

    # Verify results based on batch status
    verification_passed = verify_questions_exist(pack_id, topics_to_use, expected_total_questions, batch_result)

    # Final Summary
    print("\n" + "="*30 + " Batch Test Flow Summary " + "="*30)
    final_outcome = Colors.FAIL + "FAILED" + Colors.ENDC
    if batch_result:
        status = batch_result.get("status", "failed").lower()
        if status == "completed" and verification_passed:
            final_outcome = Colors.GREEN + "SUCCESS" + Colors.ENDC
        elif status == "partial_failure" and verification_passed:
             final_outcome = Colors.WARNING + "PARTIAL SUCCESS (Verification OK)" + Colors.ENDC
        elif status == "failed" and verification_passed:
             final_outcome = Colors.GREEN + "SUCCESS (Failed status verified)" + Colors.ENDC
        elif not verification_passed:
             final_outcome = Colors.FAIL + f"FAILED (Verification Mismatch for Status '{status}')" + Colors.ENDC
    else:
         final_outcome = Colors.FAIL + "FAILED (Batch Request Error)" + Colors.ENDC

    print(f"Overall Test Result: {final_outcome}")
    print(f"  Pack ID: {pack_id}")
    print(f"  Topics Used: {topics_to_use}")
    print(f"  Difficulties Tested per Topic: {args.difficulty}")
    print(f"  Expected Total Questions: {expected_total_questions}")
    print(f"  Custom Instructions: {'Generated within batch call' if args.auto_generate_instructions else 'Disabled'}")
    print(f"    Forced Regeneration: {'YES' if args.regenerate_instructions else 'NO'}")
    if batch_result:
        print(f"  Batch Request Status: {batch_result.get('status', 'N/A')}")
        print(f"  Reported Questions Generated: {batch_result.get('total_questions_generated', 'N/A')}")
        print(f"  Reported Success Topics: {batch_result.get('topics_processed', [])}")
        if batch_result.get('errors'): print(f"  Reported Failed Topics: {batch_result['errors']}")
    print(f"  Final Verification Check Passed: {verification_passed}")
    print("="*80)

def main():
    parser = argparse.ArgumentParser(description="Test Multi-Difficulty Batch Trivia Question Generation API")
    parser.add_argument("--pack-name", "-p", required=True, help="Name for the trivia pack (will create if not found)")
    parser.add_argument("--topics", "-t", nargs='*', help="List of topics. If omitted, topics will be generated.")
    parser.add_argument("--num-generated-topics", type=int, default=2, help="Number of topics to generate if --topics is omitted.")
    parser.add_argument("--difficulty", "-d", nargs='*', choices=["easy", "medium", "hard", "expert", "mixed"],
                      default=["medium"], help="List of difficulty levels to generate for EACH topic (default: medium)")
    parser.add_argument("--num-questions-per-difficulty", "-n", type=int, default=3,
                      help="Number of questions per difficulty level per topic")
    parser.add_argument("--seed-questions", "-s", help="Path to a file containing seed questions")
    parser.add_argument("--no-auto-instructions", action="store_false", dest="auto_generate_instructions",
                        help="Disable automatic generation of custom instructions per topic (default: ON within batch call)")
    parser.add_argument("--regenerate-instructions", action="store_true",
                        help="Force regeneration of custom instructions during the batch call, even if they exist.")
    parser.set_defaults(auto_generate_instructions=True, regenerate_instructions=False)
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output for API calls")
    parser.add_argument("--debug", action="store_true", help="Enable debug mode in the API request payload")

    global args
    args = parser.parse_args()

    if not args.topics and args.num_generated_topics <= 0: parser.error("If --topics not provided, --num-generated-topics must be > 0.")
    if not args.difficulty: args.difficulty = ["medium"]

    # --- Modified: Path handling for seed file ---
    seed_file_path = None
    if args.seed_questions:
         # Assume the seed file path is relative to the 'backend' directory
         backend_dir = Path(__file__).resolve().parent.parent
         seed_file_path = backend_dir / args.seed_questions
         if not seed_file_path.exists():
             print(f"{Colors.FAIL}Seed questions file not found at: {seed_file_path}{Colors.ENDC}")
             sys.exit(1)
         args.seed_questions = str(seed_file_path) # Use the absolute path
    # --- End Modified ---

    run_batch_test_flow(args)

if __name__ == "__main__":
    main()
</file>

<file path="backend/tests/test_game.py">
#!/usr/bin/env python
# python3 tests/test_game.py --pack-name "World History" --questions 10

import requests
import json
import argparse
import sys
import time
import random
import string
from typing import Dict, List, Any, Optional, Tuple
import os
import uuid
from pathlib import Path # Added Path

# --- ADD THIS BLOCK ---
# Add the project root (backend/) to the Python path
script_path = Path(__file__).resolve()
project_root = script_path.parent.parent
sys.path.insert(0, str(project_root))
# --- END ADDED BLOCK ---

# Imports from src should now work (if any were needed)

# API base URL
BASE_URL = "http://localhost:8000/api"

# ANSI color codes for prettier output
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def print_json(data: Any) -> None:
    """Pretty print JSON data."""
    try:
        print(json.dumps(data, indent=2))
    except TypeError:
        print(str(data))

def generate_random_name(prefix: str = "Player") -> str:
    """Generate a random name for a player or session."""
    random_suffix = ''.join(random.choice(string.ascii_lowercase) for _ in range(4))
    return f"{prefix}_{random_suffix}"

def create_temporary_user(display_name: Optional[str] = None, is_temporary: bool = True) -> Optional[Dict[str, Any]]:
    """Create a temporary user for testing."""
    if not display_name:
        display_name = generate_random_name("User")

    data = {
        "displayname": display_name,
        "is_temporary": is_temporary,
        "email": None,
        "auth_provider": None,
        "auth_id": None
    }

    print(f"{Colors.HEADER}Creating temporary user: {display_name}{Colors.ENDC}")
    response = requests.post(f"{BASE_URL}/users/", json=data)

    if response.status_code == 201:
        user_data = response.json()
        print(f"{Colors.GREEN}Successfully created user with ID: {user_data['id']}{Colors.ENDC}")
        return user_data
    else:
        print(f"{Colors.FAIL}Failed to create user: {response.status_code}{Colors.ENDC}")
        try:
            error_data = response.json()
            print_json(error_data)
        except json.JSONDecodeError:
            print(f"Raw error response: {response.text}")
        return None

def create_or_get_pack(pack_id: Optional[str] = None, pack_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
    """Create a new pack or get an existing one."""
    if pack_id:
        print(f"{Colors.HEADER}Getting existing pack with ID: {pack_id}{Colors.ENDC}")
        response = requests.get(f"{BASE_URL}/packs/{pack_id}")

        if response.status_code == 200:
            pack_data = response.json()
            print(f"{Colors.GREEN}Successfully retrieved pack: {pack_data['name']}{Colors.ENDC}")
            return pack_data
        else:
            print(f"{Colors.FAIL}Failed to get pack with ID {pack_id}: {response.status_code}{Colors.ENDC}")
            try:
                error_data = response.json()
                print_json(error_data)
            except json.JSONDecodeError:
                print(f"Raw error response: {response.text}")
            return None

    if pack_name:
        data = {
            "name": pack_name,
            "description": f"Test pack created for game testing",
            "price": 0.0,
            "creator_type": "system"
        }

        print(f"{Colors.HEADER}Creating pack: {pack_name}{Colors.ENDC}")
        response = requests.post(f"{BASE_URL}/packs/", json=data)

        if response.status_code == 201:
            pack_data = response.json()
            print(f"{Colors.GREEN}Successfully created pack with ID: {pack_data['id']}{Colors.ENDC}")
            return pack_data
        elif response.status_code == 400:
             print(f"{Colors.WARNING}Pack '{pack_name}' might already exist. Trying to fetch it.{Colors.ENDC}")
             list_response = requests.get(f"{BASE_URL}/packs/")
             if list_response.status_code == 200:
                 packs = list_response.json().get("packs", [])
                 for p in packs:
                     if p['name'].lower() == pack_name.lower():
                         print(f"{Colors.GREEN}Found existing pack with ID: {p['id']}{Colors.ENDC}")
                         return p
                 print(f"{Colors.FAIL}Could not find pack '{pack_name}' after creation attempt failed.{Colors.ENDC}")
                 return None
             else:
                print(f"{Colors.FAIL}Failed to list packs to find existing one: {list_response.status_code}{Colors.ENDC}")
                return None
        else:
            print(f"{Colors.FAIL}Failed to create pack: {response.status_code}{Colors.ENDC}")
            try:
                error_data = response.json()
                print_json(error_data)
            except json.JSONDecodeError:
                print(f"Raw error response: {response.text}")
            return None

    print(f"{Colors.FAIL}Either pack_id or pack_name must be provided{Colors.ENDC}")
    return None

def generate_pack_content(pack_id: str, topic: Optional[str] = None) -> bool:
    """Generate topics, difficulty descriptions, and questions for a pack."""
    if not topic:
        topic = "General Knowledge"

    print(f"{Colors.HEADER}Adding topic '{topic}' to pack...{Colors.ENDC}")
    topic_data = {
        "predefined_topic": topic
    }
    topic_response = requests.post(f"{BASE_URL}/packs/{pack_id}/topics/", json=topic_data)

    if topic_response.status_code != 200:
        print(f"{Colors.FAIL}Failed to add topic: {topic_response.status_code}{Colors.ENDC}")
        try: print_json(topic_response.json())
        except json.JSONDecodeError: print(f"Raw error: {topic_response.text}")
        return False

    print(f"{Colors.HEADER}Generating difficulty descriptions...{Colors.ENDC}")
    difficulty_data = { "force_regenerate": True }
    difficulty_response = requests.post(f"{BASE_URL}/packs/{pack_id}/difficulties/", json=difficulty_data)

    if difficulty_response.status_code != 200:
        print(f"{Colors.FAIL}Failed to generate difficulties: {difficulty_response.status_code}{Colors.ENDC}")
        try: print_json(difficulty_response.json())
        except json.JSONDecodeError: print(f"Raw error: {difficulty_response.text}")
        return False

    print(f"{Colors.HEADER}Generating questions for topic '{topic}'...{Colors.ENDC}")
    question_data = {
        "pack_topic": topic,
        "difficulty": "mixed",
        "num_questions": 3,
        "debug_mode": False
    }
    question_response = requests.post(f"{BASE_URL}/packs/{pack_id}/questions/", json=question_data)

    if question_response.status_code == 200:
        result = question_response.json()
        print(f"{Colors.GREEN}Successfully generated {result.get('total', 0)} questions{Colors.ENDC}")

        print(f"{Colors.HEADER}Generating incorrect answers...{Colors.ENDC}")
        incorrect_response = requests.post(f"{BASE_URL}/packs/{pack_id}/questions/incorrect-answers/batch?num_answers=3")

        if incorrect_response.status_code == 200:
            print(f"{Colors.GREEN}Successfully generated incorrect answers{Colors.ENDC}")
            return True
        else:
            print(f"{Colors.WARNING}Failed to generate incorrect answers: {incorrect_response.status_code}{Colors.ENDC}")
            try: print_json(incorrect_response.json())
            except json.JSONDecodeError: print(f"Raw error: {incorrect_response.text}")
            return True
    else:
        print(f"{Colors.FAIL}Failed to generate questions: {question_response.status_code}{Colors.ENDC}")
        try: print_json(question_response.json())
        except json.JSONDecodeError: print(f"Raw error: {question_response.text}")
        return False

def check_questions(pack_id: str) -> bool:
    """Check if a pack has questions."""
    print(f"{Colors.HEADER}Checking if pack has questions...{Colors.ENDC}")
    response = requests.get(f"{BASE_URL}/packs/{pack_id}/questions/")

    if response.status_code == 200:
        result = response.json()
        questions = result.get("questions", [])
        question_count = len(questions)
        if question_count > 0:
            print(f"{Colors.GREEN}Pack has {question_count} questions{Colors.ENDC}")
            return True
        else:
            print(f"{Colors.WARNING}Pack has no questions.{Colors.ENDC}")
            return False
    else:
        print(f"{Colors.FAIL}Failed to check questions: {response.status_code}{Colors.ENDC}")
        try: print_json(response.json())
        except json.JSONDecodeError: print(f"Raw error response: {response.text}")
        return False

def create_game_session(pack_id: str, host_id: str, max_participants: int = 10,
                        question_count: int = 5, time_limit: int = 30) -> Optional[Dict[str, Any]]:
    """Create a new game session."""
    data = {
        "pack_id": pack_id,
        "max_participants": max_participants,
        "question_count": question_count,
        "time_limit_seconds": time_limit
    }
    print(f"{Colors.HEADER}Creating game session for pack ID: {pack_id}{Colors.ENDC}")
    response = requests.post(f"{BASE_URL}/games/create?user_id={host_id}", json=data)

    if response.status_code == 200:
        game_data = response.json()
        game_id = game_data.get("id")
        game_code = game_data.get("code")
        print(f"{Colors.GREEN}Successfully created game session with ID: {game_id}{Colors.ENDC}")
        print(f"{Colors.GREEN}Game code: {game_code}{Colors.ENDC}")
        return game_data
    else:
        print(f"{Colors.FAIL}Failed to create game session: {response.status_code}{Colors.ENDC}")
        try: print_json(response.json())
        except json.JSONDecodeError: print(f"Raw error response: {response.text}")
        return None

def join_game(game_code: str, user_id: str, display_name: str) -> Optional[Dict[str, Any]]:
    """Join an existing game session."""
    data = { "game_code": game_code, "display_name": display_name }
    print(f"{Colors.HEADER}Player '{display_name}' joining game with code: {game_code}{Colors.ENDC}")
    response = requests.post(f"{BASE_URL}/games/join?user_id={user_id}", json=data)

    if response.status_code == 200:
        result = response.json()
        print(f"{Colors.GREEN}Successfully joined game. Player count: {result.get('participant_count', 0)}{Colors.ENDC}")
        return result
    else:
        print(f"{Colors.FAIL}Failed to join game: {response.status_code}{Colors.ENDC}")
        try: print_json(response.json())
        except json.JSONDecodeError: print(f"Raw error response: {response.text}")
        return None

def get_participants(game_id: str) -> List[Dict[str, Any]]:
    """Get the list of participants for a game."""
    print(f"{Colors.HEADER}Getting participants for game ID: {game_id}{Colors.ENDC}")
    response = requests.get(f"{BASE_URL}/games/{game_id}/participants")

    if response.status_code == 200:
        result = response.json()
        participants = result.get("participants", [])
        print(f"{Colors.GREEN}Game has {len(participants)} participants{Colors.ENDC}")
        for i, participant in enumerate(participants, 1):
            print(f"  {i}. {participant['display_name']} (Host: {participant['is_host']}) ID: {participant['id']}")
        return participants
    else:
        print(f"{Colors.FAIL}Failed to get participants: {response.status_code}{Colors.ENDC}")
        try: print_json(response.json())
        except json.JSONDecodeError: print(f"Raw error response: {response.text}")
        return []

def start_game(game_id: str, host_id: str) -> Optional[Dict[str, Any]]:
    """Start a game session."""
    print(f"{Colors.HEADER}Starting game with ID: {game_id}{Colors.ENDC}")
    response = requests.post(f"{BASE_URL}/games/{game_id}/start?user_id={host_id}")

    if response.status_code == 200:
        result = response.json()
        print(f"{Colors.GREEN}Successfully started game{Colors.ENDC}")
        question = result.get("current_question", {})
        print(f"\n{Colors.CYAN}Question {question.get('index', 0) + 1}:{Colors.ENDC}")
        print(f"{Colors.BLUE}{question.get('question_text', '')}{Colors.ENDC}")
        options = question.get("options", [])
        for i, option in enumerate(options): print(f"  {i + 1}. {option}")
        return result
    else:
        print(f"{Colors.FAIL}Failed to start game: {response.status_code}{Colors.ENDC}")
        try: print_json(response.json())
        except json.JSONDecodeError: print(f"Raw error response: {response.text}")
        return None

def submit_answer(game_id: str, participant_id: str, question_index: int, answer: str) -> Optional[Dict[str, Any]]:
    """Submit an answer for a question."""
    data = { "question_index": question_index, "answer": answer }
    print(f"{Colors.HEADER}Submitting answer for question {question_index + 1}: '{answer}' (Participant: {participant_id}){Colors.ENDC}")
    response = requests.post(f"{BASE_URL}/games/{game_id}/submit?participant_id={participant_id}", json=data)

    if response.status_code == 200:
        result = response.json()
        is_correct = result.get("is_correct", False)
        score = result.get("score", 0)
        total_score = result.get("total_score", "N/A")
        if is_correct: print(f"{Colors.GREEN}Correct answer! +{score} points. Total: {total_score}{Colors.ENDC}")
        else: print(f"{Colors.WARNING}Incorrect answer. Correct: {result.get('correct_answer', '')}. Total: {total_score}{Colors.ENDC}")
        return result
    else:
        print(f"{Colors.FAIL}Failed to submit answer: {response.status_code}{Colors.ENDC}")
        try: print_json(response.json())
        except json.JSONDecodeError: print(f"Raw error response: {response.text}")
        return None

def next_question(game_id: str, host_id: str) -> Optional[Dict[str, Any]]:
    """Move to the next question or end the game."""
    print(f"{Colors.HEADER}Moving to next question (Host action)...{Colors.ENDC}")
    response = requests.post(f"{BASE_URL}/games/{game_id}/next?user_id={host_id}")

    if response.status_code == 200:
        result = response.json()
        if result.get("game_complete", False):
            print(f"{Colors.GREEN}Game completed! Final results available.{Colors.ENDC}")
            return result
        question = result.get("next_question")
        if question:
             print(f"\n{Colors.CYAN}Question {question.get('index', 0) + 1}:{Colors.ENDC}")
             print(f"{Colors.BLUE}{question.get('question_text', '')}{Colors.ENDC}")
             options = question.get("options", [])
             for i, option in enumerate(options): print(f"  {i + 1}. {option}")
        else:
             print(f"{Colors.WARNING}No next question data found in response.{Colors.ENDC}")
             print_json(result)
        return result
    else:
        print(f"{Colors.FAIL}Failed to move to next question: {response.status_code}{Colors.ENDC}")
        try: print_json(response.json())
        except json.JSONDecodeError: print(f"Raw error response: {response.text}")
        return None

def get_game_results(game_id: str) -> Optional[Dict[str, Any]]:
    """Get the final results of a completed game."""
    print(f"{Colors.HEADER}Getting final results for game ID: {game_id}{Colors.ENDC}")
    response = requests.get(f"{BASE_URL}/games/{game_id}/results")

    if response.status_code == 200:
        results = response.json()
        print(f"{Colors.GREEN}Successfully retrieved game results{Colors.ENDC}")
        participants = results.get("participants", [])
        print(f"\n{Colors.CYAN}Final Rankings:{Colors.ENDC}")
        sorted_participants = sorted(participants, key=lambda p: p.get("score", 0), reverse=True)
        for i, participant in enumerate(sorted_participants, 1):
            print(f"{i}. {participant.get('display_name', 'Unknown')}: {participant.get('score', 0)} points")
        return results
    else:
        print(f"{Colors.FAIL}Failed to get game results: {response.status_code}{Colors.ENDC}")
        try: print_json(response.json())
        except json.JSONDecodeError: print(f"Raw error response: {response.text}")
        return None

def simulate_game_flow(
    pack_id: str,
    num_players: int = 3,
    question_count: int = 5,
    time_limit: int = 30,
    host_id: Optional[str] = None,
    simulated_answers: bool = True,
    topic: Optional[str] = None
) -> None:
    """Simulate a complete game flow from creation to completion."""
    # Step 1: Create users
    host_user = None
    if not host_id:
        host_user = create_temporary_user("Host")
        if not host_user: print(f"{Colors.FAIL}Failed to create host user. Exiting.{Colors.ENDC}"); return
        host_id = host_user["id"]
        print(f"{Colors.CYAN}Created host user with ID: {host_id}{Colors.ENDC}")
    player_users = []
    for i in range(num_players - 1):
        player_name = generate_random_name()
        player_user = create_temporary_user(player_name)
        if player_user:
            player_users.append(player_user)
            print(f"{Colors.CYAN}Created player user: {player_name} with ID: {player_user['id']}{Colors.ENDC}")
    if len(player_users) < (num_players - 1): print(f"{Colors.WARNING}Only created {len(player_users)} player users instead of {num_players - 1}{Colors.ENDC}")

    # Step 2: Check/Generate Pack Content
    if not check_questions(pack_id):
        print(f"{Colors.CYAN}Pack has no questions. Generating content...{Colors.ENDC}")
        if not generate_pack_content(pack_id, topic): print(f"{Colors.FAIL}Failed to generate pack content. Exiting.{Colors.ENDC}"); return
    if not check_questions(pack_id): print(f"{Colors.FAIL}Cannot create game: Pack still has no questions{Colors.ENDC}"); return

    # Step 3: Create Game Session
    game_session = create_game_session( pack_id=pack_id, host_id=host_id, max_participants=max(num_players, 2), question_count=question_count, time_limit=time_limit )
    if not game_session: return
    game_id = game_session["id"]
    game_code = game_session["code"]

    # Step 4: Join Game
    all_display_names = ["Host"] + [p["displayname"] for p in player_users]
    for player_user in player_users: join_game(game_code, player_user["id"], player_user["displayname"]); time.sleep(0.2)

    # Get Participant IDs
    participants = get_participants(game_id)
    if len(participants) != num_players: print(f"{Colors.WARNING}Expected {num_players} participants, but found {len(participants)}. Continuing cautiously...{Colors.ENDC}")
    participant_map = {p["display_name"]: p["id"] for p in participants}
    ordered_participant_ids = []
    host_participant_id = None
    for name in all_display_names:
        p_id = participant_map.get(name)
        if p_id:
            ordered_participant_ids.append(p_id)
            host_participant_data = next((p for p in participants if p["id"] == p_id and p["is_host"]), None)
            if host_participant_data: host_participant_id = p_id
        else: print(f"{Colors.WARNING}Could not find participant ID for {name}{Colors.ENDC}")
    if len(ordered_participant_ids) != num_players: print(f"{Colors.FAIL}Could not correctly map all participants. Exiting.{Colors.ENDC}"); return
    if not host_participant_id:
         host_participant_data = next((p for p in participants if p["is_host"]), None)
         if host_participant_data: host_participant_id = host_participant_data["id"]; print(f"{Colors.WARNING}Could not map host by name, found host participant ID: {host_participant_id} by flag.{Colors.ENDC}")
         else: print(f"{Colors.FAIL}Could not determine host participant ID. Exiting.{Colors.ENDC}"); return
    print(f"{Colors.CYAN}All {len(ordered_participant_ids)} players ready.{Colors.ENDC}")

    # Step 5: Start Game
    start_result = start_game(game_id, host_id)
    if not start_result: return
    current_question = start_result.get("current_question", {})
    question_index = current_question.get("index", 0)
    options = current_question.get("options", [])

    # Step 6: Play Loop
    game_ended = False
    while not game_ended:
        print(f"\n--- Question {question_index + 1} ---")
        for i, participant_id in enumerate(ordered_participant_ids):
            player_name = all_display_names[i]
            time.sleep(0.3 + random.random() * 0.5)
            if simulated_answers and options:
                random_answer = random.choice(options)
                print(f"  {player_name} chooses '{random_answer}'")
                submit_answer(game_id, participant_id, question_index, random_answer)
            elif not simulated_answers and options:
                print(f"\n{Colors.HEADER}Enter answer for {player_name}:{Colors.ENDC}")
                for j, option in enumerate(options, 1): print(f"{j}. {option}")
                try:
                    choice = int(input(f"Select option (1-{len(options)}): ")) - 1
                    chosen_answer = options[choice] if 0 <= choice < len(options) else options[0]
                except (ValueError, IndexError): print(f"{Colors.WARNING}Invalid input. Selecting first option.{Colors.ENDC}"); chosen_answer = options[0]
                submit_answer(game_id, participant_id, question_index, chosen_answer)
            else: print(f"{Colors.WARNING}No options available for question {question_index + 1}, cannot submit.{Colors.ENDC}")

        print("\nHost advancing to next question...")
        time.sleep(1)
        next_result = next_question(game_id, host_id)
        if not next_result: print(f"{Colors.FAIL}Failed to move to next question. Exiting simulation.{Colors.ENDC}"); return
        if next_result.get("game_complete", False): game_ended = True; print(f"{Colors.GREEN}Game ending signal received.{Colors.ENDC}")
        else:
            next_q_data = next_result.get("next_question")
            if next_q_data: question_index = next_q_data.get("index", question_index + 1); options = next_q_data.get("options", [])
            else: print(f"{Colors.FAIL}Error: No 'next_question' data in response but game not complete. Exiting.{Colors.ENDC}"); print_json(next_result); return

    # Step 7: Get Final Results
    get_game_results(game_id)
    print(f"\n{Colors.GREEN}Game simulation finished successfully!{Colors.ENDC}")

def main():
    parser = argparse.ArgumentParser(description="Test the game APIs")
    parser.add_argument("--pack-id", "-p", help="ID of an existing pack to use")
    parser.add_argument("--pack-name", "-n", help="Name for a new pack (if pack-id not provided)")
    parser.add_argument("--topic", "-t", help="Topic for question generation", default="World History")
    parser.add_argument("--host-id", "-H", help="ID of the host user (generated if not provided)")
    parser.add_argument("--players", "-P", type=int, default=3, help="Number of players to simulate")
    parser.add_argument("--questions", "-q", type=int, default=5, help="Number of questions per game")
    parser.add_argument("--time-limit", "-T", type=int, default=30, help="Time limit per question in seconds")
    parser.add_argument("--manual", "-m", action="store_true", help="Manually input answers instead of simulating")
    args = parser.parse_args()

    if not args.pack_id and not args.pack_name: print(f"{Colors.FAIL}Error: Either --pack-id or --pack-name must be provided{Colors.ENDC}"); parser.print_help(); return
    pack = create_or_get_pack(pack_id=args.pack_id) if args.pack_id else create_or_get_pack(pack_name=args.pack_name)
    if not pack: print(f"{Colors.FAIL}Failed to get or create a pack. Exiting.{Colors.ENDC}"); return

    simulate_game_flow( pack_id=pack["id"], num_players=args.players, question_count=args.questions, time_limit=args.time_limit, host_id=args.host_id, simulated_answers=not args.manual, topic=args.topic )

if __name__ == "__main__":
    main()
</file>

<file path="backend/tests/test_generator.py">
# python3 tests/test_generator.py --pack-name "Book Title Adjectives" --topic "Book Title Adjectives" --seed-questions seed_questions.txt -a -g generated_instruction.txt -v
# python3 tests/test_generator.py --pack-name "Physics Concepts" --topic "Quantum Mechanics" -n 10 -d hard -a

#!/usr/bin/env python
import requests
import json
import argparse
import sys
from typing import Dict, List, Any, Optional
import os
import traceback
from pathlib import Path # Added Path

# --- ADD THIS BLOCK ---
# Add the project root (backend/) to the Python path
script_path = Path(__file__).resolve()
project_root = script_path.parent.parent
sys.path.insert(0, str(project_root))
# --- END ADDED BLOCK ---

# Imports from src should now work (if any were needed)

# API base URL
BASE_URL = "http://localhost:8000/api"

# ANSI color codes for prettier output
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def print_json(data: Any) -> None:
    """Pretty print JSON data."""
    try:
        print(json.dumps(data, indent=2))
    except TypeError:
        print(str(data))

def print_step(message: str):
    print(f"\n{Colors.HEADER}--- {message} ---{Colors.ENDC}")

def make_request(method: str, endpoint: str, json_data: Optional[Dict] = None, params: Optional[Dict] = None, timeout: int = 300) -> Optional[requests.Response]:
    """Helper function to make API requests and handle basic errors."""
    url = f"{BASE_URL}{endpoint}"
    print(f"{Colors.CYAN}Requesting: {method.upper()} {url}{Colors.ENDC}")
    if params:
        print(f"Params: {params}")
    if json_data:
        print(f"Data:")
        print_json(json_data)

    try:
        response = requests.request(method, url, json=json_data, params=params, timeout=timeout)
        print(f"Response Status: {response.status_code}")
        global args
        if response.status_code >= 400 or (args and args.verbose):
             print(f"{Colors.WARNING if response.status_code >= 400 else Colors.CYAN}Response Content:{Colors.ENDC}")
             try:
                 print_json(response.json())
             except json.JSONDecodeError:
                 print(response.text[:500] + "..." if len(response.text) > 500 else response.text)
        return response
    except requests.exceptions.RequestException as e:
        print(f"{Colors.FAIL}API request failed: {e}{Colors.ENDC}")
        return None

def create_pack(name: str, description: str = None) -> Optional[str]:
    """Create a new pack and return its ID."""
    data = {
        "name": name,
        "description": description or f"Custom pack created for testing",
        "price": 0.0,
        "creator_type": "system"
    }
    print_step(f"Creating pack: {name}")
    response = make_request("POST", "/packs/", json_data=data)

    if response and response.status_code == 201:
        pack_data = response.json()
        pack_id = pack_data.get("id")
        print(f"{Colors.GREEN}Successfully created pack with ID: {pack_id}{Colors.ENDC}")
        return pack_id
    elif response and response.status_code == 400:
         print(f"{Colors.WARNING}Pack '{name}' might already exist. Trying to fetch it.{Colors.ENDC}")
         list_response = make_request("GET", "/packs/")
         if list_response and list_response.status_code == 200:
             packs = list_response.json().get("packs", [])
             for p in packs:
                 if p['name'].lower() == name.lower():
                     print(f"{Colors.GREEN}Found existing pack with ID: {p['id']}{Colors.ENDC}")
                     return p['id']
             print(f"{Colors.FAIL}Could not find pack '{name}' after creation attempt failed.{Colors.ENDC}")
             return None
         else:
             print(f"{Colors.FAIL}Failed to list packs to find existing one.{Colors.ENDC}")
             return None
    else:
        print(f"{Colors.FAIL}Failed to create or find pack '{name}'. Status: {response.status_code if response else 'N/A'}{Colors.ENDC}")
        return None

def add_topic(pack_id: str, custom_topic: str) -> bool:
    """Add a specific topic to a pack."""
    data = { "predefined_topic": custom_topic }
    print_step(f"Adding custom topic '{custom_topic}' to pack ID: {pack_id}")
    response = make_request("POST", f"/packs/{pack_id}/topics/", json_data=data)

    if response and response.status_code == 200:
        result = response.json()
        topics = result.get("topics", [])
        print(f"{Colors.GREEN}Successfully added topic. All topics:{Colors.ENDC}")
        for i, topic in enumerate(topics, 1): print(f"  {i}. {topic}")
        if custom_topic in topics: return True
        else: print(f"{Colors.WARNING}Custom topic '{custom_topic}' not found in response topics list.{Colors.ENDC}"); return False
    else:
        print(f"{Colors.FAIL}Failed to add custom topic: {response.status_code if response else 'N/A'}{Colors.ENDC}")
        return False

def generate_difficulties(pack_id: str) -> bool:
    """Generate difficulty descriptions for a pack."""
    data = { "force_regenerate": False }
    print_step(f"Generating/Ensuring difficulty descriptions for pack ID: {pack_id}")
    response = make_request("POST", f"/packs/{pack_id}/difficulties/", json_data=data)
    if response and response.status_code == 200:
        print(f"{Colors.GREEN}Successfully generated/ensured difficulty descriptions{Colors.ENDC}")
        return True
    else:
        print(f"{Colors.FAIL}Failed to generate difficulties: {response.status_code if response else 'N/A'}{Colors.ENDC}")
        return False

def process_seed_questions(pack_id: str, seed_questions_file: Optional[str]) -> Dict[str, str]:
    """Process seed questions from a file."""
    if not seed_questions_file:
        print(f"{Colors.CYAN}No seed questions file provided, skipping.{Colors.ENDC}")
        return {}

    # --- MODIFIED: Correct path construction ---
    script_dir = Path(__file__).parent
    absolute_seed_path = script_dir.parent / seed_questions_file # Assumes seed file is in backend/
    if not absolute_seed_path.exists():
        print(f"{Colors.FAIL}Seed questions file not found at expected location: {absolute_seed_path}{Colors.ENDC}")
        return {}
    # --- END MODIFIED ---

    print_step(f"Processing seed questions from {absolute_seed_path}")
    try:
        with open(absolute_seed_path, 'r') as f:
            seed_content = f.read()

        data = {"text_content": seed_content}
        print(f"{Colors.CYAN}Extracting seed questions using LLM for pack ID: {pack_id}{Colors.ENDC}")
        response = make_request("POST", f"/packs/{pack_id}/questions/seed/extract", json_data=data)

        if response and response.status_code == 200:
            result = response.json()
            seed_questions = result.get("seed_questions", {})
            count = result.get("count", 0)
            print(f"{Colors.GREEN}Successfully extracted and stored {count} seed questions{Colors.ENDC}")
            return seed_questions
        else:
            print(f"{Colors.FAIL}Failed to extract seed questions: {response.status_code if response else 'N/A'}{Colors.ENDC}")
            return {}
    except Exception as e:
        print(f"{Colors.FAIL}Error processing seed questions file: {str(e)}{Colors.ENDC}")
        print(traceback.format_exc())
        return {}

def generate_custom_instructions(pack_id: str, topic: str) -> Optional[str]:
    """Generate custom instructions for a specific topic using the LLM."""
    data = {"pack_topic": topic}
    print_step(f"Auto-generating custom instructions for topic '{topic}'")
    response = make_request("POST", f"/packs/{pack_id}/questions/custom-instructions/generate", json_data=data)

    if response and response.status_code == 200:
        result = response.json()
        custom_instructions = result.get("custom_instructions")
        if custom_instructions:
             print(f"{Colors.GREEN}Successfully generated custom instructions:{Colors.ENDC}")
             print(f"{Colors.CYAN}{custom_instructions}{Colors.ENDC}")
        else:
             print(f"{Colors.WARNING}API returned success but no custom instructions content.{Colors.ENDC}")
        return custom_instructions
    else:
        print(f"{Colors.FAIL}Failed to auto-generate custom instructions: {response.status_code if response else 'N/A'}{Colors.ENDC}")
        return None

def generate_questions(
    pack_id: str,
    topic: str,
    difficulty: str = "medium",
    num_questions: int = 5,
    debug_mode: bool = False
) -> List[Dict[str, Any]]:
    """Generate questions for a pack. Service handles instruction fetching."""
    data = {
        "pack_topic": topic,
        "difficulty": difficulty,
        "num_questions": num_questions,
        "debug_mode": debug_mode
    }
    print_step(f"Generating {num_questions} questions for topic '{topic}' with difficulty '{difficulty}'")
    response = make_request("POST", f"/packs/{pack_id}/questions/", json_data=data)

    if response and response.status_code == 200:
        result = response.json()
        questions = result.get("questions", [])
        print(f"{Colors.GREEN}Successfully generated {len(questions)} questions{Colors.ENDC}")
        return questions
    else:
        print(f"{Colors.FAIL}Failed to generate questions: {response.status_code if response else 'N/A'}{Colors.ENDC}")
        return []

def display_questions(questions: List[Dict[str, Any]]) -> None:
    """Display questions with answers and metadata."""
    if not questions: print(f"{Colors.WARNING}No questions to display{Colors.ENDC}"); return
    print(f"\n{Colors.HEADER}Generated Questions:{Colors.ENDC}")
    for i, q in enumerate(questions, 1):
        print(f"\n{Colors.BOLD}Question {i}:{Colors.ENDC}")
        print(f"  ID: {q.get('id', 'N/A')}")
        print(f"  {Colors.BLUE}Q: {q['question']}{Colors.ENDC}")
        print(f"  {Colors.GREEN}A: {q['answer']}{Colors.ENDC}")
        print(f"  {Colors.CYAN}Topic: {q.get('pack_topics_item', 'N/A')}{Colors.ENDC}")
        print(f"  {Colors.CYAN}Difficulty: {q.get('difficulty_current', 'N/A')}{Colors.ENDC}")

def save_to_file(content: str, filename: str) -> bool:
    """Save content to a file."""
    try:
        # --- MODIFIED: Save relative to script's parent (backend/) ---
        script_dir = Path(__file__).parent
        absolute_save_path = script_dir.parent / filename
        with open(absolute_save_path, 'w') as f:
            f.write(content)
        print(f"{Colors.GREEN}Successfully saved to {absolute_save_path}{Colors.ENDC}")
        # --- END MODIFIED ---
        return True
    except Exception as e:
        print(f"{Colors.FAIL}Error saving to file: {str(e)}{Colors.ENDC}")
        return False

def run_generator(args: argparse.Namespace) -> None:
    """Run the full question generation pipeline."""
    pack_id = create_pack(args.pack_name)
    if not pack_id: return
    if not add_topic(pack_id, args.topic): print(f"{Colors.FAIL}Stopping test: Failed to add custom topic.{Colors.ENDC}"); return
    generate_difficulties(pack_id)
    seed_questions = process_seed_questions(pack_id, args.seed_questions)

    custom_instructions = None
    if args.auto_generate_instructions:
        custom_instructions = generate_custom_instructions(pack_id, args.topic)
        if custom_instructions and args.save_generated_instructions:
            save_to_file(custom_instructions, args.save_generated_instructions)

    questions = generate_questions( pack_id=pack_id, topic=args.topic, difficulty=args.difficulty, num_questions=args.num_questions, debug_mode=args.debug )
    display_questions(questions)

    print(f"\n{Colors.HEADER}Summary:{Colors.ENDC}")
    print(f"  Pack ID: {pack_id}")
    print(f"  Pack Name: {args.pack_name}")
    print(f"  Topic Tested: {args.topic}")
    print(f"  Seed Questions Used: {'Yes' if seed_questions else 'No'} ({len(seed_questions)})")
    print(f"  Auto-Generated Instructions: {'Yes' if args.auto_generate_instructions else 'No'}")
    print(f"    Generated/Used Instructions: {'Yes' if custom_instructions else 'No'}")
    if args.save_generated_instructions and custom_instructions: print(f"    Saved To: {args.save_generated_instructions}")
    print(f"  Difficulty: {args.difficulty}")
    print(f"  Questions Generated: {len(questions)}")
    print(f"\n{Colors.CYAN}You can use this pack ID for future testing: {pack_id}{Colors.ENDC}")

def main():
    parser = argparse.ArgumentParser(description="Test Trivia Question Generation API with per-topic instructions")
    parser.add_argument("--pack-name", "-p", required=True, help="Name for the trivia pack")
    parser.add_argument("--topic", "-t", required=True, help="Custom topic to use for questions")
    parser.add_argument("--seed-questions", "-s", help="Path to a file containing seed questions (relative to backend/)")
    parser.add_argument("--auto-generate-instructions", "-a", action="store_true", help="Auto-generate custom instructions for the specified topic using LLM")
    parser.add_argument("--save-generated-instructions", "-g", help="Save the auto-generated instructions to this file (relative to backend/)")
    parser.add_argument("--difficulty", "-d", choices=["easy", "medium", "hard", "expert", "mixed"], default="mixed", help="Difficulty level for questions")
    parser.add_argument("--num-questions", "-n", type=int, default=5, help="Number of questions to generate")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output for API calls")
    parser.add_argument("--debug", action="store_true", help="Enable debug mode in the API request payload")

    global args
    args = parser.parse_args()

    run_generator(args)

if __name__ == "__main__":
    main()
</file>

<file path="backend/tests/test_incorrect_answers.py">
# test_incorrect_answers.py
#!/usr/bin/env python
# Example (topic provided): python3 tests/test_incorrect_answers.py --pack-name "Science Facts" --topic "Physics" -n 3 -v
# Example (topic generated): python3 tests/test_incorrect_answers.py --pack-name "Random Facts" -n 3 -v

import requests
import json
import argparse
import sys
import uuid
import time
from typing import Dict, List, Any, Optional
import os
import traceback
import random
from pathlib import Path # Added Path

# --- ADD THIS BLOCK ---
# Add the project root (backend/) to the Python path
script_path = Path(__file__).resolve()
project_root = script_path.parent.parent
sys.path.insert(0, str(project_root))
# --- END ADDED BLOCK ---

# Imports from src should now work (if any were needed)

# API base URL
BASE_URL = "http://localhost:8000/api"

# ANSI color codes
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# Helper Functions (print_step, print_json, make_request)
def print_step(message: str):
    print(f"\n{Colors.HEADER}--- {message} ---{Colors.ENDC}")

def print_json(data: Any) -> None:
    """Pretty print JSON data."""
    try:
        print(json.dumps(data, indent=2))
    except TypeError:
        print(str(data))

def make_request(method: str, endpoint: str, json_data: Optional[Dict] = None, params: Optional[Dict] = None) -> Optional[requests.Response]:
    """Helper function to make API requests and handle basic errors."""
    url = f"{BASE_URL}{endpoint}"
    print(f"{Colors.CYAN}Requesting: {method.upper()} {url}{Colors.ENDC}")
    if params: print(f"Params: {params}")
    if json_data: print(f"Data:"); print_json(json_data)

    try:
        response = requests.request(method, url, json=json_data, params=params, timeout=120)
        print(f"Response Status: {response.status_code}")
        if response.status_code >= 400:
            print(f"{Colors.WARNING}Response Content:{Colors.ENDC}")
            try: print_json(response.json())
            except json.JSONDecodeError: print(response.text[:500] + "..." if len(response.text) > 500 else response.text)
        return response
    except requests.exceptions.RequestException as e:
        print(f"{Colors.FAIL}API request failed: {e}{Colors.ENDC}")
        return None

def create_or_get_pack(pack_name: str) -> Optional[str]:
    """Create a new pack or get ID if it exists."""
    print_step(f"Ensuring pack '{pack_name}' exists")
    list_response = make_request("GET", "/packs/")
    if list_response and list_response.status_code == 200:
        packs = list_response.json().get("packs", [])
        for p in packs:
            if p['name'].lower() == pack_name.lower():
                pack_id = p['id']
                print(f"{Colors.GREEN}Found existing pack '{pack_name}' with ID: {pack_id}{Colors.ENDC}")
                return pack_id
    data = {"name": pack_name, "description": "Test pack for incorrect answer generation", "price": 0.0, "creator_type": "system"}
    create_response = make_request("POST", "/packs/", json_data=data)
    if create_response and create_response.status_code == 201:
        pack_id = create_response.json().get("id")
        print(f"{Colors.GREEN}Successfully created pack '{pack_name}' with ID: {pack_id}{Colors.ENDC}")
        return pack_id
    else:
        print(f"{Colors.FAIL}Failed to create or find pack '{pack_name}'{Colors.ENDC}")
        return None

def generate_and_select_topic(pack_id: str) -> Optional[str]:
    """Generates topics for the pack and selects the first one."""
    print_step(f"Generating topics for pack {pack_id}")
    data = {"num_topics": 1}
    response = make_request("POST", f"/packs/{pack_id}/topics/", json_data=data)
    if response and response.status_code == 200:
        topics = response.json().get("topics", [])
        if topics:
            selected_topic = topics[0]
            print(f"{Colors.GREEN}Successfully generated topics. Selected: '{selected_topic}'{Colors.ENDC}")
            return selected_topic
        else:
            print(f"{Colors.WARNING}Topic generation returned no topics.{Colors.ENDC}")
            return None
    else:
        print(f"{Colors.FAIL}Failed to generate topics.{Colors.ENDC}")
        return None

def add_topic_to_pack(pack_id: str, topic_name: str) -> bool:
    """Add a topic to the pack. Appends if topics exist."""
    print_step(f"Ensuring topic '{topic_name}' is in pack {pack_id}")
    get_response = make_request("GET", f"/packs/{pack_id}/topics/")
    existing_topics = []
    if get_response and get_response.status_code == 200:
        existing_topics = get_response.json().get("topics", [])
        print(f"Existing topics: {existing_topics}")
    if topic_name in existing_topics: print(f"Topic '{topic_name}' already exists in the pack. Skipping add."); return True
    endpoint = "/topics/"
    data = {"predefined_topic": topic_name}
    if existing_topics: print("Adding new topic to existing list using /additional endpoint."); endpoint = "/topics/additional"
    add_response = make_request("POST", f"/packs/{pack_id}{endpoint}", json_data=data)
    if add_response and add_response.status_code == 200:
        final_topics = add_response.json().get("topics", [])
        if topic_name in final_topics: print(f"{Colors.GREEN}Successfully added/confirmed topic '{topic_name}'{Colors.ENDC}"); return True
        else: print(f"{Colors.FAIL}Topic '{topic_name}' was not found in the final list after add attempt.{Colors.ENDC}"); return False
    else: print(f"{Colors.FAIL}Failed to add topic '{topic_name}'{Colors.ENDC}"); return False

def generate_pack_questions(pack_id: str, topic: str, num_questions: int, difficulty: str = "mixed") -> List[str]:
    """Generate questions for the specified topic."""
    print_step(f"Generating {num_questions} '{difficulty}' questions for topic '{topic}' in pack {pack_id}")
    data = {"pack_topic": topic, "difficulty": difficulty, "num_questions": num_questions, "debug_mode": False}
    response = make_request("POST", f"/packs/{pack_id}/questions/", json_data=data)
    if response and response.status_code == 200:
        questions_data = response.json().get("questions", [])
        question_ids = [q['id'] for q in questions_data]
        print(f"{Colors.GREEN}Successfully generated {len(questions_data)} questions.{Colors.ENDC}")
        global args # Access global args for verbose
        if args.verbose: print("Generated Questions:"); print_json(questions_data)
        return question_ids
    else:
        print(f"{Colors.FAIL}Failed to generate questions.{Colors.ENDC}")
        return []

def generate_incorrect_answers(pack_id: str, num_questions_generated: int) -> bool:
    """Trigger the batch generation of incorrect answers."""
    print_step(f"Triggering batch incorrect answer generation for pack {pack_id}")
    global args # Access global args for verbose
    params = {"num_answers": 3, "batch_size": 5, "debug_mode": args.verbose}
    response = make_request("POST", f"/packs/{pack_id}/questions/incorrect-answers/batch", params=params)
    if response and response.status_code == 200:
        result = response.json()
        processed_count = result.get("questions_processed", 0)
        status = result.get("status", "unknown")
        print(f"{Colors.GREEN}Batch incorrect answer generation completed.{Colors.ENDC}")
        print(f"  Status: {status}")
        print(f"  Questions Processed: {processed_count}")
        if processed_count >= num_questions_generated: print(f"{Colors.GREEN}Processed count matches or exceeds generated questions count.{Colors.ENDC}"); return True
        else: print(f"{Colors.WARNING}Processed count ({processed_count}) is less than generated questions ({num_questions_generated}). Check logs.{Colors.ENDC}"); return False
    else:
        print(f"{Colors.FAIL}Failed to generate incorrect answers in batch.{Colors.ENDC}")
        return False

def run_test_flow(args: argparse.Namespace):
    """Orchestrate the test steps."""
    pack_id = create_or_get_pack(args.pack_name)
    if not pack_id: return
    topic_to_use = args.topic
    if not topic_to_use:
        print(f"{Colors.CYAN}No topic provided, generating one...{Colors.ENDC}")
        topic_to_use = generate_and_select_topic(pack_id)
        if not topic_to_use: print(f"{Colors.FAIL}Stopping test because topic generation failed.{Colors.ENDC}"); return
    if not add_topic_to_pack(pack_id, topic_to_use): print(f"{Colors.FAIL}Stopping test because topic could not be added/confirmed.{Colors.ENDC}"); return
    print_step("Ensuring difficulty descriptions exist (generating if needed)")
    diff_resp = make_request("POST", f"/packs/{pack_id}/difficulties/", json_data={"force_regenerate": False})
    if not diff_resp or diff_resp.status_code != 200: print(f"{Colors.WARNING}Could not ensure difficulty descriptions exist. Question generation might use defaults.{Colors.ENDC}")
    generated_question_ids = generate_pack_questions(pack_id, topic_to_use, args.num_questions)
    if not generated_question_ids: print(f"{Colors.FAIL}Stopping test because question generation failed.{Colors.ENDC}"); return
    success = generate_incorrect_answers(pack_id, len(generated_question_ids))
    print("\n" + "="*30 + " Test Flow Summary " + "="*30)
    if success: print(f"{Colors.GREEN}Incorrect Answer Generation Test Flow Completed Successfully for pack '{args.pack_name}' (ID: {pack_id}) using topic '{topic_to_use}'.{Colors.ENDC}")
    else: print(f"{Colors.FAIL}Incorrect Answer Generation Test Flow Failed for pack '{args.pack_name}' (ID: {pack_id}) using topic '{topic_to_use}'.{Colors.ENDC}")
    print("="*80)

def main(args_parsed: argparse.Namespace):
    """Main execution function."""
    print(f"{Colors.BOLD}Starting Incorrect Answer Generation Test{Colors.ENDC}")
    print(f"Target API: {BASE_URL}")
    print(f"Pack Name: {args_parsed.pack_name}")
    if args_parsed.topic: print(f"Provided Topic: {args_parsed.topic}")
    else: print("Topic: Will be generated")
    print(f"Questions to Generate: {args_parsed.num_questions}")
    print("-" * 50)
    run_test_flow(args_parsed)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Test Incorrect Answer Batch Generation API")
    parser.add_argument("--pack-name", "-p", required=True, help="Name for the trivia pack (will create if not found)")
    parser.add_argument("--topic", "-t", help="Optional: Topic to generate questions for. If omitted, a topic will be generated.")
    parser.add_argument("--num-questions", "-n", type=int, default=3, help="Number of questions to generate before testing incorrect answers")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output")
    # Define args globally AFTER parsing
    args = parser.parse_args()
    main(args)
</file>

<file path="backend/tests/test_supabase_integration.py">
# test_supabase_async.py
import asyncio
import sys
import os
from pathlib import Path

# --- ADD THIS BLOCK ---
# Add the project root (backend/) to the Python path
script_path = Path(__file__).resolve()
project_root = script_path.parent.parent
sys.path.insert(0, str(project_root))
# --- END ADDED BLOCK ---

# Imports should now work
from src.config.config import SupabaseConfig
from src.config.supabase_client import init_supabase_client, close_supabase_client
from src.repositories.user_repository import UserRepository
from src.repositories.pack_repository import PackRepository
import traceback

async def test_async_repositories():
    """Test async repository operations with Supabase."""
    print("\n=== Testing Async Repository Operations ===\n")

    # Initialize Supabase client
    print("Initializing Supabase client...")
    supabase = await init_supabase_client()

    try:
        # Initialize repositories
        print("Creating repositories...")
        user_repo = UserRepository(supabase)
        pack_repo = PackRepository(supabase)

        # Test User Repository
        print("\n--- Testing User Repository ---")
        users = await user_repo.get_all(limit=5)
        print(f"Retrieved {len(users)} users")

        # Test Pack Repository
        print("\n--- Testing Pack Repository ---")
        packs = await pack_repo.get_all(limit=5)
        print(f"Retrieved {len(packs)} packs")

        print("\nAsync repository tests completed successfully!")

    except Exception as e:
        print(f"Error during repository operations: {type(e).__name__}: {e}")
        traceback.print_exc()

    finally:
        # Close the Supabase client
        await close_supabase_client(supabase)
        print("Supabase client closed")

if __name__ == "__main__":
    print("Starting async Supabase repository tests...")
    config = SupabaseConfig()
    print(f"Supabase URL configured: {'Yes' if config.get_supabase_url() else 'No'}")
    print(f"Supabase Key configured: {'Yes' if config.get_supabase_key() else 'No'}")
    asyncio.run(test_async_repositories())
</file>

<file path="backend/tests/test_users.py">
# test_users.py
#!/usr/bin/env python
# python3 tests/test_users.py --verbose

import requests
import json
import argparse
import sys
import uuid
from typing import Dict, List, Any, Optional
import os
import traceback
from pathlib import Path # Added Path

# --- ADD THIS BLOCK ---
# Add the project root (backend/) to the Python path
script_path = Path(__file__).resolve()
project_root = script_path.parent.parent
sys.path.insert(0, str(project_root))
# --- END ADDED BLOCK ---

# Imports from src should now work (if any were needed)

# API base URL
BASE_URL = "http://localhost:8000/api"

# ANSI color codes
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# Test case result type
class ResultType:
    SUCCESS = "SUCCESS"
    FAIL = "FAIL"
    SKIP = "SKIP"

def print_json(data: Any) -> None:
    """Pretty print JSON data."""
    try: print(json.dumps(data, indent=2))
    except TypeError: print(str(data))

def generate_random_name(prefix: str = "TestUser") -> str:
    """Generate a random name."""
    return f"{prefix}_{uuid.uuid4().hex[:6]}"

def generate_random_email(domain: str = "example.com") -> str:
    """Generate a random email address."""
    return f"{uuid.uuid4().hex[:10]}@{domain}"

class UserTester:
    def __init__(self, base_url: str = BASE_URL, verbose: bool = False):
        """Initialize the User API tester."""
        self.base_url = base_url
        self.verbose = verbose
        self.results = []
        self.permanent_user_id: Optional[str] = None
        self.permanent_user_email: Optional[str] = None
        self.temp_user_id: Optional[str] = None
        self.auth_user_id: Optional[str] = None
        self.converted_temp_user_id: Optional[str] = None

    def log(self, message: str, end="\n") -> None:
        """Log a message if verbose mode is enabled."""
        if self.verbose: print(message, end=end)

    def record_result(self, test_name: str, result_type: str, message: str = "", data: Any = None, detail: str = None) -> None:
        """Record the test result."""
        self.results.append({"test_name": test_name, "result_type": result_type, "message": message, "data": data, "detail": detail})
        color = Colors.GREEN if result_type == ResultType.SUCCESS else Colors.WARNING if result_type == ResultType.SKIP else Colors.FAIL
        result_str = f"{color}{result_type}{Colors.ENDC}"
        message_str = f" - {message}" if message else ""
        print(f"{test_name}: {result_str}{message_str}")
        if result_type == ResultType.FAIL and detail: print(f"  {Colors.FAIL}Detail: {detail}{Colors.ENDC}")
        if data and self.verbose: print("  Response Data:"); print_json(data)

    def run_test(self, test_func, test_name: str, skip_condition: bool = False) -> Any:
        """Run a test function and record the result."""
        if skip_condition: self.record_result(test_name, ResultType.SKIP, "Test skipped due to dependency failure"); return None
        try:
            print(f"\n{Colors.BOLD}Running test: {test_name}{Colors.ENDC}")
            return test_func()
        except requests.exceptions.ConnectionError as e:
                self.record_result(test_name, ResultType.FAIL, f"Connection Error: Could not connect to API at {self.base_url}. Is the server running?", detail=str(e))
                raise SystemExit("API Connection Failed") from e
        except Exception as e:
            tb_str = traceback.format_exc()
            self.record_result(test_name, ResultType.FAIL, f"Exception: {type(e).__name__}", detail=tb_str if self.verbose else str(e))
            return None

    def _handle_api_error(self, test_name: str, response: requests.Response):
        """Helper to record API errors."""
        message = f"Failed with status code: {response.status_code}"
        response_data, detail = None, None
        try:
            response_data = response.json()
            if isinstance(response_data, dict) and 'detail' in response_data:
                detail = response_data['detail']
                if isinstance(detail, list): detail_str = json.dumps(detail); detail = detail_str[:300] + "..." if len(detail_str) > 300 else detail_str
                elif isinstance(detail, str) and len(detail) > 300: detail = detail[:300] + "..."
        except json.JSONDecodeError: response_data = response.text; detail = response.text[:300] + "..." if len(response.text) > 300 else response.text
        self.record_result(test_name, ResultType.FAIL, message, response_data, detail=detail)

    # --- Test Methods ---
    def test_create_permanent_user(self) -> Optional[str]:
        test_name = "Create Permanent User"
        user_email = generate_random_email(); user_name = generate_random_name("Perm")
        data = {"displayname": user_name, "email": user_email, "is_temporary": False, "auth_provider": None, "auth_id": None}
        self.log(f"Creating permanent user: {user_name} ({user_email})"); self.log(f"Request Data: {json.dumps(data)}")
        response = requests.post(f"{self.base_url}/users/", json=data)
        if response.status_code == 201:
            response_data = response.json(); user_id = response_data.get("id")
            self.permanent_user_id = user_id; self.permanent_user_email = user_email
            self.record_result(test_name, ResultType.SUCCESS, f"Created user ID: {user_id}", response_data); return user_id
        else: self._handle_api_error(test_name, response); return None

    def test_create_temporary_user(self) -> Optional[str]:
        test_name = "Create Temporary User"; user_name = generate_random_name("Temp")
        data = {"displayname": user_name, "is_temporary": True, "email": None, "auth_provider": None, "auth_id": None}
        self.log(f"Creating temporary user: {user_name}"); self.log(f"Request Data: {json.dumps(data)}")
        response = requests.post(f"{self.base_url}/users/", json=data)
        if response.status_code == 201:
            response_data = response.json(); user_id = response_data.get("id")
            self.temp_user_id = user_id
            self.record_result(test_name, ResultType.SUCCESS, f"Created temp user ID: {user_id}", response_data); return user_id
        else: self._handle_api_error(test_name, response); return None

    def test_get_user_by_id(self) -> Optional[Dict]:
        test_name = "Get User by ID"; user_id_to_get = self.permanent_user_id
        if not user_id_to_get: self.record_result(test_name, ResultType.SKIP, "No permanent user ID available"); return None
        self.log(f"Getting user with ID: {user_id_to_get}")
        response = requests.get(f"{self.base_url}/users/{user_id_to_get}")
        if response.status_code == 200:
            response_data = response.json(); self.record_result(test_name, ResultType.SUCCESS, "Retrieved user data", response_data); return response_data
        else: self._handle_api_error(test_name, response); return None

    def test_get_user_by_email(self) -> Optional[Dict]:
        test_name = "Get User by Email"; user_email_to_get = self.permanent_user_email
        if not user_email_to_get: self.record_result(test_name, ResultType.SKIP, "No permanent user email available"); return None
        self.log(f"Getting user with email: {user_email_to_get}")
        response = requests.get(f"{self.base_url}/users/email/{user_email_to_get}")
        if response.status_code == 200:
            response_data = response.json()
            if response_data.get("id") == self.permanent_user_id: self.record_result(test_name, ResultType.SUCCESS, "Retrieved user data", response_data)
            else: self.record_result(test_name, ResultType.FAIL, f"Retrieved user ID {response_data.get('id')} does not match expected {self.permanent_user_id}", response_data)
            return response_data
        else: self._handle_api_error(test_name, response); return None

    def test_update_user(self) -> Optional[Dict]:
        test_name = "Update User"; user_id_to_update = self.permanent_user_id; new_name = generate_random_name("Updated")
        if not user_id_to_update: self.record_result(test_name, ResultType.SKIP, "No permanent user ID available to update"); return None
        data = {"displayname": new_name}
        self.log(f"Updating user {user_id_to_update} with new name: {new_name}"); self.log(f"Request Data: {json.dumps(data)}")
        response = requests.put(f"{self.base_url}/users/{user_id_to_update}", json=data)
        if response.status_code == 200:
            response_data = response.json()
            if response_data.get("displayname") == new_name: self.record_result(test_name, ResultType.SUCCESS, "User updated successfully", response_data)
            else: self.record_result(test_name, ResultType.FAIL, "User displayname did not update as expected", response_data)
            return response_data
        else: self._handle_api_error(test_name, response); return None

    def test_authenticate_user(self) -> Optional[str]:
        test_name = "Authenticate User (Get/Create)"; auth_provider = "test_provider"; auth_id = uuid.uuid4().hex
        user_name = generate_random_name("Auth"); user_email = generate_random_email()
        data = {"auth_provider": auth_provider, "auth_id": auth_id, "email": user_email, "displayname": user_name}
        self.log(f"Authenticating user via: {auth_provider}/{auth_id}"); self.log(f"Request Data: {json.dumps(data)}")
        response = requests.post(f"{self.base_url}/users/auth", json=data)
        if response.status_code == 200:
            response_data = response.json(); user_id = response_data.get("id")
            self.auth_user_id = user_id
            self.record_result(test_name, ResultType.SUCCESS, f"Authenticated/Created user ID: {user_id}", response_data); return user_id
        else: self._handle_api_error(test_name, response); return None

    def test_convert_temporary_user(self) -> Optional[Dict]:
        test_name = "Convert Temporary User"; user_id_to_convert = self.temp_user_id
        new_name = generate_random_name("Converted"); new_email = generate_random_email()
        auth_provider = "convert_provider"; auth_id = uuid.uuid4().hex
        if not user_id_to_convert: self.record_result(test_name, ResultType.SKIP, "No temporary user ID available to convert"); return None
        data = {"displayname": new_name, "email": new_email, "auth_provider": auth_provider, "auth_id": auth_id}
        self.log(f"Converting temporary user {user_id_to_convert} to permanent"); self.log(f"Request Data: {json.dumps(data)}")
        response = requests.post(f"{self.base_url}/users/convert/{user_id_to_convert}", json=data)
        if response.status_code == 200:
            response_data = response.json()
            if not response_data.get("is_temporary"):
                self.converted_temp_user_id = response_data.get("id")
                self.record_result(test_name, ResultType.SUCCESS, "User converted successfully", response_data)
            else: self.record_result(test_name, ResultType.FAIL, "User 'is_temporary' flag not updated", response_data)
            return response_data
        else: self._handle_api_error(test_name, response); return None

    def test_delete_user(self, user_id: Optional[str], user_desc: str) -> bool:
        test_name = f"Delete {user_desc} User"
        if not user_id: self.record_result(test_name, ResultType.SKIP, f"No {user_desc} user ID available to delete"); return False
        self.log(f"Deleting {user_desc} user with ID: {user_id}")
        response = requests.delete(f"{self.base_url}/users/{user_id}")
        if response.status_code == 200:
            response_data = response.json()
            if response_data.get("id") == user_id: self.record_result(test_name, ResultType.SUCCESS, "User deleted successfully", response_data); return True
            else: self.record_result(test_name, ResultType.FAIL, f"Deleted user ID {response_data.get('id')} does not match expected {user_id}", response_data); return False
        else: self._handle_api_error(test_name, response); return False

    def test_get_deleted_user(self, user_id: Optional[str], user_desc: str) -> bool:
        test_name = f"Get Deleted {user_desc} User (Should Fail)"
        if not user_id: self.record_result(test_name, ResultType.SKIP, f"No deleted {user_desc} user ID available to test"); return False
        self.log(f"Attempting to get deleted {user_desc} user with ID: {user_id}")
        response = requests.get(f"{self.base_url}/users/{user_id}")
        if response.status_code == 404:
            response_data = response.json(); self.record_result(test_name, ResultType.SUCCESS, "User not found as expected (404)", response_data); return True
        else: self._handle_api_error(test_name, response); return False

    # Orchestration and Summary
    def run_all_tests(self) -> None:
        """Run all user API tests."""
        print(f"{Colors.HEADER}Starting User API Tests{Colors.ENDC}"); print(f"Base URL: {self.base_url}")
        self.run_test(self.test_create_permanent_user, "Create Permanent User")
        self.run_test(self.test_create_temporary_user, "Create Temporary User")
        self.run_test(self.test_get_user_by_id, "Get User by ID", skip_condition=not self.permanent_user_id)
        self.run_test(self.test_get_user_by_email, "Get User by Email", skip_condition=not self.permanent_user_email)
        self.run_test(self.test_update_user, "Update User", skip_condition=not self.permanent_user_id)
        self.run_test(self.test_authenticate_user, "Authenticate User (Get/Create)")
        self.run_test(self.test_convert_temporary_user, "Convert Temporary User", skip_condition=not self.temp_user_id)
        print(f"\n{Colors.HEADER}--- Running Cleanup ---{Colors.ENDC}")
        perm_deleted = self.run_test(lambda: self.test_delete_user(self.permanent_user_id, "Permanent"), "Delete Permanent User")
        self.run_test(lambda: self.test_get_deleted_user(self.permanent_user_id, "Permanent"), "Get Deleted Permanent User", skip_condition=not perm_deleted)
        conv_deleted = self.run_test(lambda: self.test_delete_user(self.converted_temp_user_id, "Converted"), "Delete Converted User", skip_condition=not self.converted_temp_user_id)
        self.run_test(lambda: self.test_get_deleted_user(self.converted_temp_user_id, "Converted"), "Get Deleted Converted User", skip_condition=not conv_deleted)
        auth_deleted = self.run_test(lambda: self.test_delete_user(self.auth_user_id, "Authenticated"), "Delete Authenticated User", skip_condition=not self.auth_user_id)
        self.run_test(lambda: self.test_get_deleted_user(self.auth_user_id, "Authenticated"), "Get Deleted Authenticated User", skip_condition=not auth_deleted)
        self.print_summary()

    def print_summary(self) -> None:
        """Print test summary."""
        total, success_count, fail_count, skip_count = len(self.results), sum(1 for r in self.results if r["result_type"] == ResultType.SUCCESS), sum(1 for r in self.results if r["result_type"] == ResultType.FAIL), sum(1 for r in self.results if r["result_type"] == ResultType.SKIP)
        print("\n" + "=" * 50); print(f"{Colors.HEADER}User API Test Summary{Colors.ENDC}")
        print(f"Total tests: {total}"); print(f"Successful: {Colors.GREEN}{success_count}{Colors.ENDC}"); print(f"Failed: {Colors.FAIL}{fail_count}{Colors.ENDC}"); print(f"Skipped: {Colors.WARNING}{skip_count}{Colors.ENDC}")
        print("=" * 50)
        if fail_count > 0:
            print(f"\n{Colors.FAIL}Failed Tests Details:{Colors.ENDC}")
            for r in self.results:
                if r["result_type"] == ResultType.FAIL: print(f"- {Colors.BOLD}{r['test_name']}{Colors.ENDC}: {r['message']}"); print(f"  Detail: {r['detail']}") if r['detail'] else None

def main():
    parser = argparse.ArgumentParser(description="Test the User API endpoints")
    parser.add_argument("--base-url", default=BASE_URL, help="Base URL for the API")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output")
    args = parser.parse_args()
    tester = UserTester(base_url=args.base_url, verbose=args.verbose)
    tester.run_all_tests()

if __name__ == "__main__":
    main()
</file>

<file path="backend/.gitignore">
# Environment variables
.env
.env.*

# Python
__pycache__/
*.py[cod]
*$py.class
*.so

# Distribution / packaging
dist/
build/
*.egg-info/

# Virtual Environment
venv/
env/
ENV/

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS specific
.DS_Store
Thumbs.db
</file>

<file path="backend/conftest.py">
import pytest
import sys
import os

# Add the src directory to the Python path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), 'src')))
</file>

<file path="backend/custom_instructions.txt">
The example questions play with wordplay, allusions, and clever phrasing that ties to the topic without being too on-the-nose.  The questions we generate should follow the rules of the topic.  Think about the sample questions and use them as examples of how the rules work.
</file>

<file path="backend/pytest.ini">
# pytest.ini
[pytest]
asyncio_mode = strict
</file>

<file path="backend/requirements.txt">
fastapi>=0.100.0
uvicorn>=0.23.0
pydantic>=2.0.0
python-dotenv>=1.0.0
openai>=1.0.0
argparse>=1.4.0
numpy>=1.24.0
supabase>=1.0.0
anthropic>=0.5.0
typing-extensions>=4.5.0
python-multipart>=0.0.6
httpx>=0.24.0
pytest>=7.3.1
requests>=2.30.0
pyjwt>=2.6.0
google-generativeai>=0.3.0
email-validator>=2.0.0
pytest-asyncio>=0.19.0
</file>

<file path="backend/run_api_server.py">
import uvicorn
import sys
import os
from pathlib import Path

# Add backend/src to the Python path
current_dir = Path(os.getcwd())
sys.path.insert(0, str(current_dir))

if __name__ == "__main__":
    print("Starting Trivia API server...")
    print("API documentation will be available at http://localhost:8000/docs")
    uvicorn.run("src.main:app", host="0.0.0.0", port=8000, reload=True)
</file>

<file path="website/.vite/deps/_metadata.json">
{
  "hash": "48afd176",
  "configHash": "410a6217",
  "lockfileHash": "e3b0c442",
  "browserHash": "c136972d",
  "optimized": {},
  "chunks": {}
}
</file>

<file path="website/.vite/deps/package.json">
{
  "type": "module"
}
</file>

<file path="website/public/placeholder.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="1200" fill="none"><rect width="1200" height="1200" fill="#EAEAEA" rx="3"/><g opacity=".5"><g opacity=".5"><path fill="#FAFAFA" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/></g><path stroke="url(#a)" stroke-width="2.418" d="M0-1.209h553.581" transform="scale(1 -1) rotate(45 1163.11 91.165)"/><path stroke="url(#b)" stroke-width="2.418" d="M404.846 598.671h391.726"/><path stroke="url(#c)" stroke-width="2.418" d="M599.5 795.742V404.017"/><path stroke="url(#d)" stroke-width="2.418" d="m795.717 796.597-391.441-391.44"/><path fill="#fff" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/><g clip-path="url(#e)"><path fill="#666" fill-rule="evenodd" d="M616.426 586.58h-31.434v16.176l3.553-3.554.531-.531h9.068l.074-.074 8.463-8.463h2.565l7.18 7.181V586.58Zm-15.715 14.654 3.698 3.699 1.283 1.282-2.565 2.565-1.282-1.283-5.2-5.199h-6.066l-5.514 5.514-.073.073v2.876a2.418 2.418 0 0 0 2.418 2.418h26.598a2.418 2.418 0 0 0 2.418-2.418v-8.317l-8.463-8.463-7.181 7.181-.071.072Zm-19.347 5.442v4.085a6.045 6.045 0 0 0 6.046 6.045h26.598a6.044 6.044 0 0 0 6.045-6.045v-7.108l1.356-1.355-1.282-1.283-.074-.073v-17.989h-38.689v23.43l-.146.146.146.147Z" clip-rule="evenodd"/></g><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/></g><defs><linearGradient id="a" x1="554.061" x2="-.48" y1=".083" y2=".087" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="b" x1="796.912" x2="404.507" y1="599.963" y2="599.965" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="c" x1="600.792" x2="600.794" y1="403.677" y2="796.082" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="d" x1="404.85" x2="796.972" y1="403.903" y2="796.02" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><clipPath id="e"><path fill="#fff" d="M581.364 580.535h38.689v38.689h-38.689z"/></clipPath></defs></svg>
</file>

<file path="website/public/robots.txt">
User-agent: Googlebot
Allow: /

User-agent: Bingbot
Allow: /

User-agent: Twitterbot
Allow: /

User-agent: facebookexternalhit
Allow: /

User-agent: *
Allow: /
</file>

<file path="website/src/components/ui/accordion.tsx">
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="website/src/components/ui/alert-dialog.tsx">
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="website/src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="website/src/components/ui/aspect-ratio.tsx">
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }
</file>

<file path="website/src/components/ui/avatar.tsx">
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="website/src/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="website/src/components/ui/breadcrumb.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:size-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
</file>

<file path="website/src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="website/src/components/ui/calendar.tsx">
import * as React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { DayPicker } from "react-day-picker";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ..._props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ..._props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  );
}
Calendar.displayName = "Calendar";

export { Calendar };
</file>

<file path="website/src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="website/src/components/ui/carousel.tsx">
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="website/src/components/ui/chart.tsx">
import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item.dataKey || item.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
</file>

<file path="website/src/components/ui/checkbox.tsx">
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
</file>

<file path="website/src/components/ui/collapsible.tsx">
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
</file>

<file path="website/src/components/ui/command.tsx">
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="website/src/components/ui/context-menu.tsx">
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
</file>

<file path="website/src/components/ui/dialog.tsx">
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="website/src/components/ui/drawer.tsx">
import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
</file>

<file path="website/src/components/ui/dropdown-menu.tsx">
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="website/src/components/ui/form.tsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="website/src/components/ui/hover-card.tsx">
import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }
</file>

<file path="website/src/components/ui/input-otp.tsx">
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
</file>

<file path="website/src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="website/src/components/ui/label.tsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="website/src/components/ui/menubar.tsx">
import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const MenubarMenu = MenubarPrimitive.Menu

const MenubarGroup = MenubarPrimitive.Group

const MenubarPortal = MenubarPrimitive.Portal

const MenubarSub = MenubarPrimitive.Sub

const MenubarRadioGroup = MenubarPrimitive.RadioGroup

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}
</file>

<file path="website/src/components/ui/navigation-menu.tsx">
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
</file>

<file path="website/src/components/ui/pagination.tsx">
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}
</file>

<file path="website/src/components/ui/popover.tsx">
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="website/src/components/ui/progress.tsx">
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-gray-200",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
</file>

<file path="website/src/components/ui/radio-group.tsx">
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
</file>

<file path="website/src/components/ui/resizable.tsx">
import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
</file>

<file path="website/src/components/ui/scroll-area.tsx">
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</file>

<file path="website/src/components/ui/select.tsx">
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="website/src/components/ui/separator.tsx">
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="website/src/components/ui/sheet.tsx">
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
import * as React from "react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
  VariantProps<typeof sheetVariants> { }

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet, SheetClose,
  SheetContent, SheetDescription, SheetFooter, SheetHeader, SheetOverlay, SheetPortal, SheetTitle, SheetTrigger
}
</file>

<file path="website/src/components/ui/sidebar.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { Sheet, SheetContent } from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContext | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden md:block text-sidebar-foreground"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="website/src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="website/src/components/ui/slider.tsx">
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
</file>

<file path="website/src/components/ui/sonner.tsx">
// src/components/ui/sonner.tsx
// --- START OF FILE ---
import { useTheme } from "next-themes" // Keep this if you still want dark mode adaptation, though we override base colors below
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  // theme might not be directly needed now if we force the blue style,
  // but keeping it doesn't hurt if other elements might adapt.
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]} // Keep theme prop
      className="toaster group" // Keep base className
      toastOptions={{
        classNames: {
          // --- MODIFICATION START ---
          toast:
            "group toast group-[.toaster]:bg-blue-600 group-[.toaster]:text-white group-[.toaster]:border-blue-700 group-[.toaster]:shadow-lg", // Force blue background, white text, adjust border
          description: "group-[.toast]:text-blue-100", // Lighter text for description on blue bg
          actionButton:
            "group-[.toast]:bg-white group-[.toast]:text-blue-700 group-[.toast]:border-blue-200", // Example: White button with blue text
          cancelButton:
            "group-[.toast]:bg-blue-700 group-[.toast]:text-blue-100 group-[.toast]:border-blue-800", // Example: Darker blue button
          // --- MODIFICATION END ---
        },
      }}
      {...props}
    />
  )
}

export { Toaster }
// --- END OF FILE ---
</file>

<file path="website/src/components/ui/switch.tsx">
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
</file>

<file path="website/src/components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="website/src/components/ui/tabs.tsx">
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="website/src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="website/src/components/ui/toast.tsx">
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
</file>

<file path="website/src/components/ui/toaster.tsx">
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
</file>

<file path="website/src/components/ui/toggle-group.tsx">
import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }
</file>

<file path="website/src/components/ui/toggle.tsx">
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }
</file>

<file path="website/src/components/ui/tooltip.tsx">
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="website/src/components/AnswerButton.tsx">
// src/components/AnswerButton.tsx
// --- START OF FILE ---
import React from 'react';
import PirateButton from '@/components/PirateButton';

// Define and export the props interface
export interface AnswerButtonProps {
  onSubmit: () => void;
  disabled: boolean;
  isAnswered: boolean;
  isCorrect: boolean;
}

const AnswerButton: React.FC<AnswerButtonProps> = ({
  onSubmit,
  disabled,
  isAnswered,
  isCorrect
}) => {
  return (
    // REMOVED mt-4 from this div
    <div className="flex justify-center"> {/* Removed mt-4 */}
      <PirateButton
        onClick={onSubmit}
        disabled={disabled}
        // Updated line below - removed 'animate-bounce'
        className={`py-3 px-8 text-lg ${isAnswered ? (isCorrect ? '' : 'animate-shake') : ''}`}
        variant={isAnswered ? (isCorrect ? 'accent' : 'primary') : 'accent'}
      >
        {/* Dynamic button text based on state */}
        {isAnswered ? (isCorrect ? "Booty Secured! " : "Booty Lost! ") : "Secure the Booty"}
      </PirateButton>
    </div>
  );
};

export default AnswerButton;
// --- END OF FILE ---
</file>

<file path="website/src/components/AnswerItem.tsx">
// src/components/AnswerItem.tsx
import React from 'react';
import { Card } from '@/components/ui/card';
import PlayerAvatar from '@/components/PlayerAvatar';
import { Player, Answer } from '@/types/gameTypes';

interface AnswerItemProps {
  answer: Answer;
  isSelected: boolean;
  isCorrect: boolean;
  isRevealed: boolean; // Indicates if the correct/incorrect status should be shown
  onClick: () => void;
  playersWhoSelected: Player[];
  height: number | null; // For consistent height
}

const AnswerItem = React.forwardRef<HTMLDivElement, AnswerItemProps>(
  ({ answer, isSelected, isCorrect, isRevealed, onClick, playersWhoSelected, height }, ref) => {

    const revealedBgClass = isRevealed
      ? isCorrect ? 'bg-green-100' : isSelected ? 'bg-red-100' : ''
      : '';

    const selectionStyleClass = isSelected
        ? 'outline outline-4 outline-offset-[-1px] outline-pirate-gold border-transparent'
        : 'border border-pirate-navy/30';

    const showAvatars = isRevealed && playersWhoSelected && playersWhoSelected.length > 0;

    return (
      // REMOVED overflow-hidden from this Card
      <Card
        ref={ref}
        className={`p-4 cursor-pointer transition-all bg-pirate-parchment flex flex-col ${selectionStyleClass} ${revealedBgClass} hover:bg-pirate-navy/10 relative`} // Removed overflow-hidden
        onClick={onClick}
        style={height ? { height: `${height}px` } : {}}
      >
        {/* Answer Text Content */}
        <div className="flex items-start flex-grow">
          <div className="mr-3 flex-shrink-0 w-7 h-7 rounded-full bg-pirate-navy text-white flex items-center justify-center font-bold text-sm">
            {answer.letter}
          </div>
          <p className="font-medium text-lg break-words">{answer.text}</p>
        </div>

        {/* Player Avatars - Absolutely Positioned */}
        {showAvatars && (
          <div className="absolute bottom-0 right-4 transform translate-y-1/2 z-10">
            <div className="flex flex-row-reverse -space-x-2 space-x-reverse">
              {playersWhoSelected.map(player => (
                <PlayerAvatar
                  key={`${answer.id}-${player.id}`}
                  playerId={player.id}
                  name={player.name}
                  size="sm"
                  className="border-2 border-white bg-gray-300"
                />
              ))}
            </div>
          </div>
        )}
      </Card>
    );
  }
);

AnswerItem.displayName = 'AnswerItem';

export default AnswerItem;
</file>

<file path="website/src/components/GameHeader.tsx">
import React from 'react';
import { Link } from 'react-router-dom';
import { Anchor } from 'lucide-react';
import { useIsMobile } from '@/hooks/use-mobile';

const GameHeader: React.FC = () => {
  const isMobile = useIsMobile();
  
  return (
    <header className="w-full py-4 px-6">
      {!isMobile && (
        <Link to="/" className="flex items-center gap-2">
          <Anchor className="text-pirate-navy h-6 w-6" />
          <h1 className="font-pirate text-2xl md:text-3xl text-pirate-navy">Trivia Trove</h1>
        </Link>
      )}
    </header>
  );
};

export default GameHeader;
</file>

<file path="website/src/components/GameSettings.tsx">
// src/components/GameSettings.tsx
// --- START OF FILE ---
import React, { useState } from 'react';
import { Card } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Slider } from '@/components/ui/slider';
import PirateButton from '@/components/PirateButton';
import { Anchor } from 'lucide-react';

interface Category {
  title: string;
  icon: React.ReactNode;
  description: string;
  slug: string;
  focuses: string[];
}

interface GameSettingsProps {
  category: Category;
  onSubmit: (settings: {
    numberOfQuestions: number;
    timePerQuestion: number;
    focus: string;
  }) => void;
  mode: 'solo' | 'crew';
  role?: string;
}

const GameSettings: React.FC<GameSettingsProps> = ({
  category,
  onSubmit,
  mode,
  role
}) => {
  const [numberOfQuestions, setNumberOfQuestions] = useState(10);
  const [timePerQuestion, setTimePerQuestion] = useState(30);
  const focus = category.focuses[0] || 'General';

  const handleSubmit = () => {
    onSubmit({
      numberOfQuestions,
      timePerQuestion,
      focus
    });
  };

  return (
    <div className="space-y-8">
      <div className="flex items-center space-x-4">
        <div className="bg-pirate-navy/10 p-3 rounded-full">
          {category.icon}
        </div>
        <div>
          <h2 className="pirate-heading text-2xl">{category.title}</h2>
          <p className="text-pirate-navy/70">{category.description}</p>
        </div>
      </div>

      {/* Game settings card */}
      <Card className="p-6 space-y-6">
        <h3 className="pirate-heading text-xl mb-4">Game Settings</h3>

        <div className="space-y-2">
          <div className="flex justify-between">
            <Label htmlFor="questions">Number of Questions</Label>
            <span className="text-pirate-navy/70 text-sm font-mono">{numberOfQuestions}</span>
          </div>
          <Slider
            id="questions"
            min={5}
            max={30}
            step={5}
            value={[numberOfQuestions]}
            onValueChange={(value) => setNumberOfQuestions(value[0])}
            className="py-4"
          />
        </div>

        <div className="space-y-2">
          <div className="flex justify-between">
            <Label htmlFor="time">Time per Question (seconds)</Label>
            <span className="text-pirate-navy/70 text-sm font-mono">{timePerQuestion}s</span>
          </div>
          <Slider
            id="time"
            min={10}
            max={60}
            step={5}
            value={[timePerQuestion]}
            onValueChange={(value) => setTimePerQuestion(value[0])}
            className="py-4"
          />
        </div>
      </Card>

      {mode === 'crew' && role === 'captain' && (
        <div className="flex justify-center mt-8">
          {/* FIX: Added w-full class */}
          <PirateButton
            onClick={handleSubmit}
            className="px-8 py-3 text-lg w-full"
            variant="accent"
          >
            <Anchor className="h-5 w-5" />
            Gather the Crew
          </PirateButton>
        </div>
      )}

      {(mode === 'solo' || role !== 'captain') && (
        <div className="flex justify-center mt-8">
          {/* FIX: Added w-full class */}
          <PirateButton
            onClick={handleSubmit}
            className="px-8 py-3 text-lg w-full"
            variant="accent"
          >
            Start Adventure
          </PirateButton>
        </div>
      )}
    </div>
  );
};

export default GameSettings;
// --- END OF FILE ---
</file>

<file path="website/src/components/Header.tsx">
import React from 'react';
import { Link } from 'react-router-dom';
import { Anchor, Compass } from 'lucide-react';
import { Button } from '@/components/ui/button';

const Header: React.FC = () => {
  return (
    <header className="w-full py-4 px-6 flex justify-between items-center">
      <Link to="/" className="flex items-center gap-2">
        <Anchor className="text-pirate-navy h-6 w-6" />
        <h1 className="font-pirate text-2xl md:text-3xl text-pirate-navy">Trivia Trove</h1>
      </Link>

      <nav className="flex items-center gap-4">
        {/* Update link to point to /auth */}
        <Link to="/auth">
          <Button className="bg-pirate-black text-white hover:bg-pirate-navy rounded-full flex items-center gap-2">
            <span>Log In</span>
            <Compass className="h-4 w-4" />
          </Button>
        </Link>
      </nav>
    </header>
  );
};

export default Header;
</file>

<file path="website/src/components/PirateButton.tsx">
import React from 'react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';

interface PirateButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'accent';
  children: React.ReactNode;
  icon?: React.ReactNode;
}

const PirateButton: React.FC<PirateButtonProps> = ({
  variant = 'primary',
  children,
  icon,
  className,
  ...props
}) => {
  return (
    <Button
      className={cn(
        'rounded-full font-semibold py-6 flex items-center justify-center gap-2 text-base',
        variant === 'primary' 
          ? 'bg-pirate-navy text-white border-2 border-pirate-gold hover:bg-pirate-navy/90'
          : variant === 'secondary'
            ? 'bg-white text-pirate-navy border-2 border-pirate-navy hover:bg-gray-100'
            : 'bg-pirate-accent text-white border-2 border-pirate-gold hover:bg-pirate-accent/90',
        className
      )}
      {...props}
    >
      {children}
      {icon && <span className="ml-2">{icon}</span>}
    </Button>
  );
};

export default PirateButton;
</file>

<file path="website/src/components/PlayerAvatar.tsx">
import React from 'react';
import { Avatar, AvatarFallback } from "@/components/ui/avatar"; // No need for AvatarImage now
import { getEmojiForPlayerId } from '@/utils/gamePlayUtils'; // Import the helper

interface PlayerAvatarProps {
  name: string; // Keep name for accessibility/tooltips if needed later
  playerId: string; // Use playerId for consistent emoji generation
  size?: "sm" | "md" | "lg";
  className?: string;
}

const PlayerAvatar: React.FC<PlayerAvatarProps> = ({
  playerId, // Receive playerId
  // name is kept in props for potential future use, but not directly used for display now
  size = "md",
  className = ""
}) => {
  // Get the consistent emoji for this player ID
  const selectedEmoji = getEmojiForPlayerId(playerId);

  const sizeClasses = {
    // Adjust text size slightly for emojis if needed
    sm: "h-6 w-6 text-sm",
    md: "h-8 w-8 text-base",
    lg: "h-10 w-10 text-lg"
  };

  return (
    // Apply base classes and size-specific classes
    <Avatar className={`${sizeClasses[size]} ${className}`}>
      {/* Fallback always shows the selected emoji with a grey background */}
      {/* Use a neutral grey - adjust hex/tailwind class as desired */}
      <AvatarFallback className="bg-gray-300 text-gray-800 flex items-center justify-center">
        {selectedEmoji}
      </AvatarFallback>
    </Avatar>
  );
};

export default PlayerAvatar;
</file>

<file path="website/src/components/QuestionCard.tsx">
// src/components/QuestionCard.tsx
import React from 'react';
import { Card } from '@/components/ui/card';
import { Player, Answer } from '@/types/gameTypes';
import AnswerButton, { AnswerButtonProps } from './AnswerButton';
import AnswerItem from './AnswerItem';

interface QuestionCardProps {
  questionText: string;
  answers: Answer[];
  selectedAnswer: string | null;
  isAnswered: boolean; // Still needed to pass down as isRevealed
  correctAnswer: string;
  onAnswerSelect: (answerId: string) => void;
  playerSelectionsByAnswer: Record<string, Player[]>;
  maxHeight: number | null;
  questionTextClass: string;
  answerRefs: React.MutableRefObject<(HTMLDivElement | null)[]>;
  answerButtonProps: Omit<AnswerButtonProps, 'children'>;
}

const QuestionCard: React.FC<QuestionCardProps> = ({
  questionText,
  answers,
  selectedAnswer,
  isAnswered, // Used for isRevealed prop
  correctAnswer,
  onAnswerSelect,
  playerSelectionsByAnswer,
  maxHeight,
  questionTextClass,
  answerRefs,
  answerButtonProps
}) => {
  return (
    <Card className="bg-white p-6 shadow-lg w-full flex flex-col">
      <h2 className={`${questionTextClass} mb-8 mt-2 text-pirate-black text-center line-clamp-5 px-0 md:px-4`}>
        {questionText}
      </h2>

      {/* REMOVED mb-10 from this grid div */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8 flex-grow"> {/* Removed mb-10 */}
        {answers.map((answer, index) => (
          <AnswerItem
            key={answer.id}
            ref={el => answerRefs.current[index] = el} // Pass ref down
            answer={answer}
            isSelected={selectedAnswer === answer.id}
            isCorrect={answer.id === correctAnswer}
            isRevealed={isAnswered}
            onClick={() => onAnswerSelect(answer.id)}
            playersWhoSelected={playerSelectionsByAnswer[answer.id] || []}
            height={maxHeight}
          />
        ))}
      </div>

      {/* ADDED wrapper div with mt-6 */}
      <div className="mt-6"> {/* Added this wrapper */}
        <AnswerButton {...answerButtonProps} />
      </div>
    </Card>
  );
};

export default QuestionCard;
</file>

<file path="website/src/components/QuestionTimer.tsx">
import React from 'react';

interface QuestionTimerProps {
  timeRemaining: number;
  totalTime: number;
}

const QuestionTimer: React.FC<QuestionTimerProps> = ({ timeRemaining, totalTime }) => {
  const progressPercentage = (timeRemaining / totalTime) * 100;
  const displayTime = Math.max(0, Math.ceil(timeRemaining)).toString();

  return (
    <div className="mb-6">
      <div className="flex items-center justify-center mb-2">
        <div className="bg-gray-200 rounded-full w-full max-w-md h-3 overflow-hidden">
          <div 
            className={`h-full transition-all duration-300 ${
              progressPercentage > 66 ? 'bg-green-500' :
              progressPercentage > 33 ? 'bg-yellow-500' : 'bg-red-500'
            }`}
            style={{ width: `${progressPercentage}%` }}
          ></div>
        </div>
        <span className="text-lg font-medium ml-3">{displayTime}s</span>
      </div>
    </div>
  );
};

export default QuestionTimer;
</file>

<file path="website/src/hooks/use-mobile.tsx">
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
</file>

<file path="website/src/hooks/use-toast.ts">
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="website/src/hooks/useGameTimer.ts">
// src/hooks/useGameTimer.ts
import { useState, useEffect, useRef } from 'react';

/**
 * Custom hook to manage a countdown timer, now resettable via a key dependency.
 * @param timerId A unique identifier for the current timer session (e.g., question ID). Changes trigger reset.
 * @param initialTime The total time for the countdown in seconds.
 * @param isPaused Whether the timer should be paused.
 * @param onTimeout Callback function to execute when the timer reaches zero.
 * @returns The current time remaining in seconds.
 */
export const useGameTimer = (
  timerId: string | number, // <-- NEW: Add a unique ID for the timer instance (like question.id)
  initialTime: number,
  isPaused: boolean,
  onTimeout: () => void
): number => {
  const [timeRemaining, setTimeRemaining] = useState<number>(initialTime);
  const timeoutCallbackRef = useRef(onTimeout); // Use ref for stable callback

  // Update the ref if the onTimeout callback changes
  useEffect(() => {
    timeoutCallbackRef.current = onTimeout;
  }, [onTimeout]);

  // Effect to reset timer when timerId changes (new question) OR initialTime changes
  useEffect(() => {
    console.log(`useGameTimer Reset Effect: Triggered by timerId change to [${timerId}]. Setting time to ${initialTime}`);
    setTimeRemaining(initialTime);
    // This effect now runs whenever the `timerId` (e.g., question.id) changes,
    // forcing the state to reset to the `initialTime` for the new question.
  }, [timerId, initialTime]); // <-- ADD timerId as a dependency

  // Effect to handle the countdown logic
  useEffect(() => {
    if (isPaused) {
      if (timeRemaining <= 0) setTimeRemaining(0);
      return; // Do nothing if paused
    }

    if (timeRemaining <= 0) {
      setTimeRemaining(0);
      // Use a microtask or short timeout to ensure state update happens before callback
      queueMicrotask(() => {
        if (timeoutCallbackRef.current) { // Check ref existence
             console.log(`useGameTimer Countdown Effect: Time reached 0 for timerId [${timerId}]. Calling onTimeout.`);
             timeoutCallbackRef.current();
        } else {
             console.warn(`useGameTimer Countdown Effect: onTimeout ref is null when trying to call for timerId [${timerId}]`);
        }
      });
      return; // Stop the effect
    }

    // Set up the interval timer
    const intervalId = setInterval(() => {
      setTimeRemaining(prevTime => {
        const newTime = prevTime - 0.1;
        if (newTime <= 0) {
          clearInterval(intervalId); // Stop interval immediately
          return 0; // Set to exactly 0
        }
        return newTime;
      });
    }, 100); // Update every 100ms

    // Cleanup function
    return () => {
      clearInterval(intervalId);
    };

    // Depend on `isPaused` and `timeRemaining` for countdown logic.
    // Crucially, DO NOT depend on `timerId` here, as that would restart the interval unnecessarily.
  }, [timeRemaining, isPaused]);
    // --- Removed timerId from this effect's dependency array ---

  // Return the current time, ensuring it's not negative
  return Math.max(0, timeRemaining);
};
</file>

<file path="website/src/hooks/useQuestionManager.ts">
// src/hooks/useQuestionManager.ts
import { useState, useMemo, useCallback } from 'react';
import { Question } from '@/types/gameTypes';

interface UseQuestionManagerReturn {
  currentQuestion: Question | null;
  currentQuestionIndex: number;
  isLastQuestion: boolean;
  nextQuestion: () => void; // Advances to the next question
  totalQuestionsToPlay: number;
}

/**
 * Custom hook to manage the flow of questions in the game.
 * @param allQuestions Array of all available questions.
 * @param totalQuestions Desired number of questions for this game session.
 * @returns An object containing the current question, index, navigation function, etc.
 */
export const useQuestionManager = (
  allQuestions: Question[],
  totalQuestions: number
): UseQuestionManagerReturn => {
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState<number>(0);

  // Determine the actual number of questions to play (don't exceed available)
  const totalQuestionsToPlay = useMemo(() =>
      Math.min(allQuestions.length, totalQuestions),
    [allQuestions.length, totalQuestions]
  );

  // Get the current question object based on the index
  const currentQuestion = useMemo(() =>
      (currentQuestionIndex < totalQuestionsToPlay) ? allQuestions[currentQuestionIndex] : null,
    [allQuestions, currentQuestionIndex, totalQuestionsToPlay]
  );

  // Check if the current question is the last one for this game session
  const isLastQuestion = useMemo(() =>
      currentQuestionIndex >= totalQuestionsToPlay - 1,
    [currentQuestionIndex, totalQuestionsToPlay]
  );

  // Function to advance to the next question
  const nextQuestion = useCallback(() => {
    if (!isLastQuestion) {
      setCurrentQuestionIndex(prevIndex => prevIndex + 1);
    }
    // If it is the last question, calling this does nothing further.
    // The calling component should handle game end logic based on `isLastQuestion`.
  }, [isLastQuestion]); // Dependency: only needs to know if it *can* advance

  return {
    currentQuestion,
    currentQuestionIndex,
    isLastQuestion,
    nextQuestion,
    totalQuestionsToPlay // Expose the calculated number of questions
  };
};
</file>

<file path="website/src/hooks/useWebSocket.ts">
// website/src/hooks/useWebSocket.ts
import { useState, useEffect, useRef, useCallback } from 'react';
import { toast } from 'sonner';
import { IncomingWsMessage } from '@/types/websocketTypes'; // Import message types
import { API_BASE_URL } from '@/config';

// Define WebSocket connection states
type WebSocketStatus = 'connecting' | 'connected' | 'disconnected' | 'error';

interface UseWebSocketOptions {
  gameId: string | null;
  userId: string | null;
  onMessage: (message: IncomingWsMessage) => void; // Callback to handle received messages
  onError?: (event: Event) => void;
  onOpen?: () => void;
  onClose?: (event: CloseEvent) => void;
  retryInterval?: number; // Time in ms between reconnection attempts
  maxRetries?: number; // Max number of reconnection attempts (-1 for infinite)
}

const WS_BASE_URL = import.meta.env.VITE_WS_BASE_URL || API_BASE_URL.replace(/^http/, 'ws');
console.log("WebSocket Base URL:", WS_BASE_URL);


/**
 * Custom hook to manage a WebSocket connection for the game.
 * Handles connection, disconnection, message sending/receiving, and basic reconnection.
 */
export const useWebSocket = ({
  gameId,
  userId,
  onMessage,
  onError,
  onOpen,
  onClose,
  retryInterval = 5000, // Default 5 seconds
  maxRetries = 5,       // Default 5 retries
}: UseWebSocketOptions) => {
  const [status, setStatus] = useState<WebSocketStatus>('disconnected');
  const wsRef = useRef<WebSocket | null>(null);
  const retryCountRef = useRef<number>(0);
  const connectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const attemptingConnectionRef = useRef<boolean>(false); // Flag to prevent concurrent connection attempts

  // Stable callback refs
  const onMessageRef = useRef(onMessage);
  const onErrorRef = useRef(onError);
  const onOpenRef = useRef(onOpen);
  const onCloseRef = useRef(onClose);

  useEffect(() => { onMessageRef.current = onMessage; }, [onMessage]);
  useEffect(() => { onErrorRef.current = onError; }, [onError]);
  useEffect(() => { onOpenRef.current = onOpen; }, [onOpen]);
  useEffect(() => { onCloseRef.current = onClose; }, [onClose]);

  const connect = useCallback(() => {
    // Prevent connection if missing required IDs or already connecting/connected
    if (!gameId || !userId || attemptingConnectionRef.current || status === 'connected' || status === 'connecting') {
      if (!gameId || !userId) console.log("WebSocket connect skipped: Missing gameId or userId");
      else console.log(`WebSocket connect skipped: Status is ${status} or already attempting.`);
      return;
    }

    // Construct WebSocket URL
    const wsUrl = `${WS_BASE_URL}/ws/${gameId}/${userId}`;
    console.log(`Attempting WebSocket connection to: ${wsUrl}`);

    attemptingConnectionRef.current = true; // Set flag
    setStatus('connecting');
    retryCountRef.current = 0; // Reset retry count on new manual connect attempt

    try {
      wsRef.current = new WebSocket(wsUrl);

      wsRef.current.onopen = () => {
        console.log('WebSocket connection opened');
        setStatus('connected');
        retryCountRef.current = 0; // Reset retries on successful connection
        if (connectTimeoutRef.current) clearTimeout(connectTimeoutRef.current);
        attemptingConnectionRef.current = false; // Clear flag
        if (onOpenRef.current) onOpenRef.current();
      };

      wsRef.current.onmessage = (event) => {
        try {
          const message: IncomingWsMessage = JSON.parse(event.data);
          // console.log('WebSocket message received:', message); // Debug log
          if (onMessageRef.current) onMessageRef.current(message);
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error, 'Data:', event.data);
        }
      };

      wsRef.current.onerror = (event) => {
        console.error('WebSocket error:', event);
        setStatus('error');
        attemptingConnectionRef.current = false; // Clear flag on error too
        if (onErrorRef.current) onErrorRef.current(event);
        // Optionally trigger reconnection logic here as well
        handleClose(new CloseEvent('errorclose')); // Treat error as a close event for potential retry
      };

      wsRef.current.onclose = (event) => {
        console.log('WebSocket connection closed:', event.code, event.reason);
        handleClose(event);
      };

    } catch (error) {
        console.error("Error creating WebSocket:", error);
        setStatus('error');
        attemptingConnectionRef.current = false; // Clear flag
        // Handle creation error, maybe retry?
    }

  }, [gameId, userId, status]); // Depends on IDs and status to prevent multiple connects

  const handleClose = useCallback((event: CloseEvent) => {
      setStatus('disconnected');
      attemptingConnectionRef.current = false; // Clear flag
      wsRef.current = null; // Clear the ref
      if (onCloseRef.current) onCloseRef.current(event);

      // Reconnection logic
      if ((maxRetries === -1 || retryCountRef.current < maxRetries)) {
         retryCountRef.current++;
         console.log(`WebSocket closed. Attempting reconnect ${retryCountRef.current}/${maxRetries === -1 ? 'infinite' : maxRetries}...`);
         toast.info("Connection Lost", { description: `Attempting to reconnect (${retryCountRef.current})...`});
         if (connectTimeoutRef.current) clearTimeout(connectTimeoutRef.current); // Clear previous timeout
         connectTimeoutRef.current = setTimeout(connect, retryInterval);
      } else {
         console.log("WebSocket closed. Max retries reached or retries disabled.");
         toast.error("Connection Lost", { description: "Could not reconnect to the game server."});
      }
  }, [maxRetries, retryInterval, connect]); // Added `connect` to dependencies

  const disconnect = useCallback(() => {
    if (connectTimeoutRef.current) {
      clearTimeout(connectTimeoutRef.current); // Cancel any pending reconnection attempts
      connectTimeoutRef.current = null;
    }
    retryCountRef.current = maxRetries; // Prevent further retries after manual disconnect
    if (wsRef.current) {
      console.log('Manually closing WebSocket connection.');
      wsRef.current.close(1000, 'User disconnected'); // Use standard code 1000
      // wsRef.current = null; // Let onclose handle setting ref to null
      // setStatus('disconnected'); // Let onclose handle status update
    }
  }, [maxRetries]);

  // Effect to initiate connection when gameId and userId are available
  useEffect(() => {
    if (gameId && userId) {
      connect();
    } else {
      // If IDs become null/undefined, ensure disconnection
      disconnect();
    }

    // Cleanup on unmount or when IDs change significantly
    return () => {
      console.log("useWebSocket cleanup: Disconnecting...");
      disconnect();
    };
  }, [gameId, userId, connect, disconnect]); // Add connect/disconnect

  // Function to send messages (if needed later)
  // const sendMessage = useCallback((message: any) => {
  //   if (wsRef.current && status === 'connected') {
  //     try {
  //       wsRef.current.send(JSON.stringify(message));
  //     } catch (error) {
  //       console.error("Failed to send WebSocket message:", error);
  //     }
  //   } else {
  //     console.warn("WebSocket not connected. Cannot send message:", message);
  //   }
  // }, [status]);

  return { status }; // Expose status, maybe sendMessage later
};
</file>

<file path="website/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="website/src/pages/AuthScreen.tsx">
// src/pages/AuthScreen.tsx
import React from 'react';
import { Link } from 'react-router-dom';
import { ArrowLeft, Mail } from 'lucide-react';
import Header from '@/components/Header'; // Assuming you want the standard header

// Inline SVG for Google Logo (simple version)
const GoogleIcon = () => (
  <svg viewBox="0 0 48 48" width="24px" height="24px">
    <path fill="#EA4335" d="M24 9.5c3.49 0 6.6 1.2 9.01 3.19l6.89-6.89C35.76 2.34 30.2 0 24 0 14.9 0 7.09 5.44 4.12 13.09l7.64 5.94C13.64 13.08 18.44 9.5 24 9.5z"></path>
    <path fill="#4285F4" d="M46.17 24.98c0-1.66-.15-3.29-.43-4.88H24v9.32h12.48c-.54 3.03-2.09 5.58-4.58 7.31l7.39 5.72C43.36 37.88 46.17 31.91 46.17 24.98z"></path>
    <path fill="#FBBC05" d="M11.76 19.03c-.47-1.4-.74-2.89-.74-4.43s.27-3.03.74-4.43l-7.64-5.94C1.96 10.16 0 14.89 0 20c0 5.11 1.96 9.84 4.12 13.11l7.64-5.94z"></path>
    <path fill="#34A853" d="M24 48c6.2 0 11.76-2.07 15.68-5.58l-7.39-5.72c-2.04 1.37-4.65 2.19-7.29 2.19-5.56 0-10.36-3.58-12.24-8.41l-7.64 5.94C7.09 42.56 14.9 48 24 48z"></path>
    <path fill="none" d="M0 0h48v48H0z"></path>
  </svg>
);


const AuthScreen: React.FC = () => {

  const handleGoogleSignIn = () => {
    console.log("Attempting Google Sign In...");
    // Add actual Google Sign In logic here (e.g., using Firebase, Supabase, etc.)
    alert("Google Sign In (Not Implemented)");
  };

  const handleEmailSignIn = () => {
    console.log("Attempting Email Sign In...");
    // Add actual Email Sign In logic here
    alert("Email Sign In (Not Implemented)");
  };


  return (
    <div className="min-h-screen flex flex-col">
      {/* Use the standard header */}
      <Header />

      <main className="flex-1 container mx-auto px-4 py-8 flex flex-col items-center justify-center">

        {/* Back link (optional, depends on where user comes from) */}
         {/* <Link to="/" className="absolute top-24 left-6 flex items-center text-pirate-navy hover:text-pirate-accent mb-6">
           <ArrowLeft className="h-4 w-4 mr-2" />
           <span>Back</span>
         </Link> */}

        <div className="map-container p-6 md:p-10 mb-10 w-full max-w-md">
          <h1 className="pirate-heading text-3xl md:text-4xl mb-8 text-center">
            Sign Up or Log In
          </h1>

          <div className="flex flex-col items-center gap-4 w-full">
             {/* --- Google Button --- */}
             <button
              onClick={handleGoogleSignIn}
              className="w-full flex items-center justify-center gap-3 bg-white text-black border border-gray-300 rounded-full px-4 py-3 text-base font-medium hover:bg-gray-50 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-pirate-gold"
            >
              <GoogleIcon />
              Sign in with Google
            </button>

             {/* --- Email Button --- */}
             <button
               onClick={handleEmailSignIn}
               className="w-full flex items-center justify-center gap-3 bg-pirate-navy text-white rounded-full px-4 py-3 text-base font-medium hover:bg-pirate-navy/90 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-pirate-gold"
             >
               <Mail className="h-5 w-5" />
               Sign in with Email
             </button>

             {/* Optional: Divider */}
             {/* <div className="my-4 flex items-center w-full">
               <hr className="flex-grow border-t border-pirate-navy/20"/>
               <span className="mx-4 text-xs text-pirate-navy/60">OR</span>
               <hr className="flex-grow border-t border-pirate-navy/20"/>
             </div> */}

             {/* Optional: Link to traditional email/password form */}
             {/* <p className="text-sm text-pirate-navy/80">
               Use your <Link to="/login-email" className="underline hover:text-pirate-accent">email and password</Link>.
             </p> */}

          </div>
        </div>
      </main>

      <footer className="ocean-bg py-8">
        <div className="container mx-auto text-center text-white relative z-10">
          <p className="font-pirate text-xl mb-2">Join the Crew!</p>
          <p className="text-sm opacity-75"> 2023 Trivia Trove - All Rights Reserved</p>
        </div>
      </footer>
    </div>
  );
};

export default AuthScreen;
</file>

<file path="website/src/pages/CountdownScreen.tsx">
// website/src/pages/CountdownScreen.tsx
// --- START OF FULL MODIFIED FILE ---
import React, { useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom'; // Import useLocation
import GameHeader from '@/components/GameHeader';
import { toast } from 'sonner'; // Import toast for error feedback

const CountdownScreen: React.FC = () => {
  const [count, setCount] = useState(3);
  const navigate = useNavigate();
  const location = useLocation(); // Get location object
  const gameData = location.state as { gameId?: string, packName?: string, totalQuestions?: number } | undefined; // <-- Add packName to type

  // Add a check in case state is missing (e.g., direct navigation)
  useEffect(() => {
    // Check for gameId, packName is also important now
    if (!gameData?.gameId || !gameData?.packName) {
       console.error("CountdownScreen: Missing game data (gameId or packName) in location state!", gameData);
       toast.error("Navigation Error", { description: "Missing game information. Returning home."});
       navigate('/');
       return; // Stop if data is missing
    }
  }, [gameData, navigate]);

  useEffect(() => {
    // Ensure gameData is valid before starting the timer/navigation logic
    if (!gameData?.gameId || !gameData?.packName) {
      return; // Stop if gameData is invalid (already handled by the check above)
    }

    const timer = setInterval(() => {
      setCount((prevCount) => {
        if (prevCount <= 1) {
          clearInterval(timer);
          // Navigate to gameplay *with* the state (including packName)
          setTimeout(() => navigate('/gameplay', { state: gameData }), 1500); // Pass full gameData forward
          return 0;
        }
        return prevCount - 1;
      });
    }, 1000);

    return () => clearInterval(timer);
  // Add gameData dependency because it's checked at the start of the effect
  }, [navigate, gameData]); // Depend on gameData

  // Don't render the countdown if gameData is missing (optional, but prevents flicker)
  if (!gameData?.gameId || !gameData?.packName) {
      return (
        <div className="min-h-screen flex flex-col items-center justify-center">
             Loading or Redirecting... {/* Or a loading spinner */}
        </div>
      );
  }


  return (
    <div className="min-h-screen flex flex-col">
      <GameHeader />

      <main className="flex-1 flex flex-col items-center justify-center">
        <div className="text-center">
          <h1 className="font-pirate text-5xl mb-8 text-pirate-navy">
            Game Starting in...
          </h1>

          {count > 0 ? (
            <div className="animate-bounce">
              <span className="font-pirate text-8xl text-pirate-gold">{count}</span>
            </div>
          ) : (
            <div className="animate-scale-in">
              <span className="font-pirate text-8xl text-pirate-accent">Ahoy!</span>
            </div>
          )}

          <div className="mt-10">
            <div className="ship-animation">
              <div className="ship">
                <span role="img" aria-label="ship"></span>
              </div>
              <div className="waves">
                <span></span>
              </div>
            </div>
          </div>
        </div>
      </main>

      <style>
        {`
        .ship-animation {
          position: relative;
          height: 100px;
          width: 300px;
          margin: 0 auto;
        }

        .ship {
          position: absolute;
          top: 0;
          left: 0;
          font-size: 3rem;
          animation: sail 3s infinite linear;
        }

        .waves {
          position: absolute;
          bottom: 0;
          left: 0;
          font-size: 1.5rem;
          width: 100%;
          letter-spacing: -5px;
          animation: wave 2s infinite linear;
        }

        @keyframes sail {
          0% {
            transform: translateY(0) rotate(0deg);
          }
          25% {
            transform: translateY(-10px) rotate(5deg);
          }
          50% {
            transform: translateY(0) rotate(0deg);
          }
          75% {
            transform: translateY(-10px) rotate(-5deg);
          }
          100% {
            transform: translateY(0) rotate(0deg);
          }
        }

        @keyframes wave {
          0% {
            transform: translateX(0);
          }
          100% {
            transform: translateX(-20px);
          }
        }

        @keyframes scale-in {
           from { transform: scale(0.5); opacity: 0; }
           to { transform: scale(1); opacity: 1; }
         }
         .animate-scale-in { animation: scale-in 0.5s ease-out forwards; }
        `}
      </style>

      <footer className="ocean-bg py-8">
        <div className="container mx-auto text-center text-white relative z-10">
          <p className="font-pirate text-xl mb-2">Prepare to set sail!</p>
          <p className="text-sm opacity-75"> 2023 Trivia Trove - All Rights Reserved</p>
        </div>
      </footer>
    </div>
  );
};

export default CountdownScreen;
// --- END OF FULL MODIFIED FILE ---
</file>

<file path="website/src/pages/GameplayScreen.tsx">
// website/src/pages/GameplayScreen.tsx
// --- START OF FULL MODIFIED FILE ---
import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { useNavigate, useSearchParams, useLocation } from 'react-router-dom';
import GameHeader from '@/components/GameHeader';
import QuestionCard from '@/components/QuestionCard';
import QuestionTimer from '@/components/QuestionTimer'; // Import the timer component
import { Player, PlayerSelection, PlayerResult, Question, Answer } from '@/types/gameTypes';
import { getGamePlayQuestions, submitAnswer as submitAnswerApi, getGameParticipants } from '@/services/gameApi';
import { getPlayerById, getQuestionTextClass, getPirateNameForUserId, getEmojiForPlayerId } from '@/utils/gamePlayUtils';
import { useGameTimer } from '@/hooks/useGameTimer';
import { useQuestionManager } from '@/hooks/useQuestionManager';
import { toast } from 'sonner';
import { Loader2, AlertTriangle } from 'lucide-react';
import { Card } from '@/components/ui/card';
import PirateButton from '@/components/PirateButton';

// --- WebSocket Imports ---
import { useWebSocket } from '@/hooks/useWebSocket';
import { IncomingWsMessage } from '@/types/websocketTypes';
import { ApiParticipant, ApiGameSessionResponse, ApiGameSubmitAnswerRequest, ApiQuestionResultResponse } from '@/types/apiTypes'; // Added ApiQuestionResultResponse
// --- End WebSocket Imports ---

const GameplayScreen: React.FC = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();

  // --- Get Data from Navigation State ---
  const gameId = location.state?.gameId as string | undefined;
  const packId = location.state?.packId as string | undefined;
  const packName = location.state?.packName as string | undefined;
  const totalQuestionsSetting = location.state?.totalQuestions as number | undefined;
  const gameCode = searchParams.get('gameCode');
  const isSoloMode = !gameCode; // Determine mode based on gameCode presence

  // --- State for Fetched Questions and Loading/Error ---
  const [gameQuestions, setGameQuestions] = useState<Question[]>([]);
  const [isLoadingQuestions, setIsLoadingQuestions] = useState(true);
  const [questionFetchError, setQuestionFetchError] = useState<string | null>(null);

  // --- Fetch Game Questions ---
  useEffect(() => {
     if (!gameId || !packName) {
       console.error("GameplayScreen: Missing gameId or packName in location state!", location.state);
       toast.error("Game Error", { description: "Missing game/pack information. Returning home." });
       navigate('/');
       return;
     }
    const fetchQuestions = async () => {
      setIsLoadingQuestions(true);
      setQuestionFetchError(null);
      try {
        const response = await getGamePlayQuestions(gameId);
        const formattedQuestions: Question[] = response.questions.map((apiQ): Question => {
            const answersWithOptions: Answer[] = apiQ.options.map((optionText, optionIndex): Answer => ({
                id: `${apiQ.question_id}-${optionIndex}`, text: optionText, letter: String.fromCharCode(65 + optionIndex)
            }));
            const correctAnswerId = apiQ.correct_answer_id;
            if (!correctAnswerId) console.error(`Missing correct_answer_id for question ${apiQ.question_id}`);
            return { id: apiQ.question_id, text: apiQ.question_text, category: packId || 'Trivia', answers: answersWithOptions, correctAnswer: correctAnswerId, timeLimit: apiQ.time_limit, };
        });
        setGameQuestions(formattedQuestions);
      } catch (error) {
        console.error("Failed to fetch game questions:", error);
        const errorMsg = error instanceof Error ? error.message : "Could not load questions.";
        setQuestionFetchError(errorMsg);
        toast.error("Failed to Load Questions", { description: errorMsg });
      } finally {
        setIsLoadingQuestions(false);
      }
    };
    fetchQuestions();
  }, [gameId, navigate, packId, packName, location.state]);

  // --- State Managed by Hooks ---
  const {
    currentQuestion: question,
    currentQuestionIndex,
    isLastQuestion,
    nextQuestion,
    totalQuestionsToPlay
  } = useQuestionManager(gameQuestions, totalQuestionsSetting ?? gameQuestions.length);

  // --- Local State ---
  const [selectedAnswer, setSelectedAnswer] = useState<string | null>(null);
  const [isAnswered, setIsAnswered] = useState(false);
  const [isCorrect, setIsCorrect] = useState(false);
  const [score, setScore] = useState(0);
  const [playerSelections, setPlayerSelections] = useState<PlayerSelection[]>([]);
  const [maxHeight, setMaxHeight] = useState<number | null>(null);
  const answerRefs = useRef<(HTMLDivElement | null)[]>([]);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);
  const [currentUserDisplayName, setCurrentUserDisplayName] = useState<string | null>(null);
  const [currentParticipantId, setCurrentParticipantId] = useState<string | null>(null);


  // --- User Info Effect (Calls getGameParticipants) ---
  useEffect(() => {
    const storedUserId = localStorage.getItem('tempUserId');
    const storedName = localStorage.getItem('tempUserDisplayName');
    if (storedUserId) {
      setCurrentUserId(storedUserId);
      setCurrentUserDisplayName(storedName || getPirateNameForUserId(storedUserId));

      const fetchParticipantId = async () => {
           if (gameId && storedUserId) {
               try {
                   console.log(`Fetching participants in Gameplay to find participant ID for user ${storedUserId}...`);
                   const response = await getGameParticipants(gameId);
                   const currentUserParticipant = response.participants.find(p => p.user_id === storedUserId);
                   if (currentUserParticipant) {
                       setCurrentParticipantId(currentUserParticipant.id);
                       console.log(`Found participant ID: ${currentUserParticipant.id}`);
                   } else {
                       console.error(`Could not find participant record for user ${storedUserId} in game ${gameId}.`);
                       toast.error("Game Sync Error", { description: "Could not verify your participation. Submissions might fail." });
                   }
               } catch (error) {
                   console.error("Error fetching participant ID:", error);
                   toast.error("Game Sync Error", { description: "Could not verify participation." });
               }
           }
      };
      // Fetch participant ID only if it's *not* solo mode OR if needed for API submissions even in solo
      // Let's fetch it always for now, as submitAnswer API needs it.
      fetchParticipantId();

    } else {
      console.error("Gameplay: User ID not found!");
      toast.error("Session Error", { description: "User ID missing. Please restart." });
      navigate('/');
    }
  }, [navigate, gameId]);

  // --- WebSocket Message Handler (Only relevant for Crew mode) ---
  const handleWebSocketMessage = useCallback((message: IncomingWsMessage) => {
    // Skip handling if in solo mode
    if (isSoloMode) return;

    console.log("GameplayScreen Received WebSocket Message:", message.type, message.payload);
    switch (message.type) {
      case 'next_question': {
        const nextQuestionIndex = message.payload.index;
        console.log(`WS: Received next_question signal for index ${nextQuestionIndex}. Current index: ${currentQuestionIndexRef.current}`);
        if (nextQuestionIndex === currentQuestionIndexRef.current + 1) {
            console.log("WS: Advancing to next question based on WS message.");
            nextQuestionRef.current();
        } else {
            console.warn(`WS: Received next_question for index ${nextQuestionIndex}, but expected ${currentQuestionIndexRef.current + 1}. Ignoring.`);
        }
        break;
      }
      case 'game_over': {
        console.log("WS: Received game_over signal.");
        const resultsPayload = message.payload;
        const formattedResults: PlayerResult[] = resultsPayload.participants.map((p: ApiParticipant) => ({
             id: p.user_id, name: p.display_name, score: p.score,
             avatar: getEmojiForPlayerId(p.user_id)
        }));
        const resultsPath = gameCode ? `/results?gameCode=${gameCode}` : '/results';
        toast.info("Game Over!", { description: "Heading to the results..." });
        navigate(resultsPath, { state: { results: formattedResults } });
        break;
      }
       case 'game_cancelled': {
         toast.error("Game Cancelled", { description: "The Captain has cancelled the game." });
         navigate('/');
         break;
       }
       case 'error': {
         toast.error("Server Error", { description: message.payload.message });
         break;
       }
      // We don't need participant join/leave/name messages on the gameplay screen itself
      default: break;
    }
  }, [navigate, gameCode, isSoloMode]); // Added isSoloMode dependency

  // --- Refs for Stable Callbacks ---
  const nextQuestionRef = useRef(nextQuestion);
  const currentQuestionIndexRef = useRef(currentQuestionIndex);
  useEffect(() => { nextQuestionRef.current = nextQuestion; }, [nextQuestion]);
  useEffect(() => { currentQuestionIndexRef.current = currentQuestionIndex; }, [currentQuestionIndex]);

  // --- Initialize WebSocket Connection (Conditional) ---
  const { status: wsStatus } = useWebSocket({
    gameId: !isSoloMode ? gameId : null, // Pass null if solo
    userId: !isSoloMode ? currentUserId : null, // Pass null if solo
    onMessage: handleWebSocketMessage,
    onOpen: () => console.log("Gameplay WebSocket connected."),
    onClose: (event) => console.log("Gameplay WebSocket closed:", event.code),
    onError: (event) => {
        // Only show connection error toast in crew mode
        if (!isSoloMode) {
            toast.error("Connection Error", { description: "Lost connection during gameplay." })
        } else {
            console.log("Ignoring WS connection error in solo mode.");
        }
    },
  });
  // --- End WebSocket Initialization ---

  // --- handleSubmit ---
  const handleSubmit = useCallback(async () => {
    if (isAnswered || !question || !currentUserId || !gameId) {
       console.log("Submit prevented (GameplayScreen):", { isAnswered, question: !!question, currentUserId: !!currentUserId, gameId: !!gameId });
       return;
    }

    console.log(`Handling submit for Q Index: ${currentQuestionIndex}, Q ID: ${question.id}`);
    setIsAnswered(true);
    const answerIsCorrect = selectedAnswer === question.correctAnswer;
    setIsCorrect(answerIsCorrect);

    // Submit score/history via API (Required for both modes if tracking history/score on backend)
    let finalScoreAfterSubmit = score; // Start with current score
    if (selectedAnswer && currentParticipantId) {
       try {
           console.log(`${isSoloMode ? 'SOLO' : 'CREW'}: Submitting answer '${selectedAnswer}' via REST API (Participant: ${currentParticipantId})...`);
           const submitPayload: ApiGameSubmitAnswerRequest = { question_index: currentQuestionIndex, answer: selectedAnswer };
           const submitResult: ApiQuestionResultResponse = await submitAnswerApi(gameId, currentParticipantId, submitPayload);
           console.log(`${isSoloMode ? 'SOLO' : 'CREW'}: Answer submission API response:`, submitResult);
           if (submitResult?.total_score !== undefined) {
               finalScoreAfterSubmit = submitResult.total_score; // Update score based on API response
               setScore(finalScoreAfterSubmit);
           } else {
                console.warn("API submit response did not contain total_score.");
                // Simple local fallback score update if API fails/is weird
                if (answerIsCorrect) { finalScoreAfterSubmit = score + 1; setScore(finalScoreAfterSubmit); }
           }
       } catch (error) {
           console.error(`${isSoloMode ? 'SOLO' : 'CREW'}: Failed to submit answer via API:`, error);
           toast.error("Sync Failed", { description: "Could not record your answer." });
           // Simple local fallback score update if API fails
           if (answerIsCorrect) { finalScoreAfterSubmit = score + 1; setScore(finalScoreAfterSubmit); }
       }
    } else {
       console.log(`${isSoloMode ? 'SOLO' : 'CREW'}: No answer selected or participant ID missing, skipping API submit.`);
       // Keep finalScoreAfterSubmit as the current score
    }


    // *** ADDED SOLO Advancement Logic ***
    if (isSoloMode) {
        console.log("SOLO MODE: Triggering advancement locally.");
        // Use a short delay to allow the user to see the result feedback briefly
        setTimeout(() => {
            if (isLastQuestion) {
                console.log("SOLO MODE: Last question answered. Navigating to results.");
                // Prepare results locally for solo mode
                const finalResult: PlayerResult = {
                    id: currentUserId, // Use the actual user ID
                    name: currentUserDisplayName || 'Solo Player',
                    score: finalScoreAfterSubmit, // Use the score AFTER potential API update/fallback
                    avatar: getEmojiForPlayerId(currentUserId) // Assign avatar
                };
                navigate('/results', { state: { results: [finalResult] } }); // Pass single result
            } else {
                console.log("SOLO MODE: Advancing to next question locally.");
                nextQuestionRef.current(); // Use the ref to the hook's function
            }
        }, 1500); // 1.5 second delay
    } else {
         console.log("CREW MODE: Submit handled. Waiting for WebSocket signal to advance.");
         // In crew mode, advancement is handled by the 'next_question' or 'game_over' WS message
    }
  }, [
      isAnswered, question, currentUserId, gameId, selectedAnswer,
      currentQuestionIndex, currentParticipantId, isSoloMode, isLastQuestion,
      score, currentUserDisplayName, navigate // Keep dependencies
  ]);
  // --- End Solo Advancement Logic ---


  // --- Timer Hook ---
  const timeRemaining = useGameTimer(
    question?.id || `loading-${currentQuestionIndex}`,
    question?.timeLimit || 30,
    isAnswered,
    handleSubmit // Pass the potentially modified handleSubmit
  );

  // --- Effects (Reset, Height Calculation) ---
  useEffect(() => {
    if (question) {
      console.log(`Component State Reset Effect: New question loaded - ID: ${question.id}, Index: ${currentQuestionIndex}`);
      setSelectedAnswer(null);
      setIsAnswered(false);
      setIsCorrect(false);
      setPlayerSelections([]);
      setMaxHeight(null);
      answerRefs.current = [];
    }
  }, [question, currentQuestionIndex]);

  useEffect(() => {
     if (!question || !question.answers || maxHeight !== null || !answerRefs.current) return;
      answerRefs.current = answerRefs.current.slice(0, question.answers.length);
      let animationFrameId: number;
      const calculateHeight = () => {
          if (answerRefs.current.length === question.answers.length && answerRefs.current.every(Boolean)) {
              let highest = 0;
              answerRefs.current.forEach(ref => { if (ref) { const currentHeight = ref.getBoundingClientRect().height; if (currentHeight > highest) highest = currentHeight; } });
              if (highest > 0 && highest !== maxHeight) setMaxHeight(highest);
          }
      };
      const timeoutId = setTimeout(() => { animationFrameId = requestAnimationFrame(calculateHeight); }, 200);
      return () => { clearTimeout(timeoutId); if (animationFrameId) cancelAnimationFrame(animationFrameId); };
  }, [question, maxHeight]);

  // --- Event Handlers ---
  const handleAnswerSelect = (answerId: string) => { if (!isAnswered) { setSelectedAnswer(answerId); if (currentUserId) setPlayerSelections([{ playerId: currentUserId, answerId }]); } };

  // --- Derived Data ---
  const playerSelectionsByAnswer = useMemo(() => {
      // This is only relevant for crew mode display, safe to keep as is
      if (isSoloMode || !question) return {};
      const selections: Record<string, Player[]> = {};
      playerSelections.forEach(sel => {
          const player = getPlayerById([], sel.playerId); // Note: getPlayerById currently uses mock data
          if (player) { if (!selections[sel.answerId]) selections[sel.answerId] = []; selections[sel.answerId].push(player); }
      });
      return selections;
  }, [isSoloMode, question, playerSelections]);
  const questionTextClass = question ? getQuestionTextClass(question.text) : 'text-2xl md:text-3xl';

  // --- Loading and Error States ---
  if (isLoadingQuestions) { return (<div className="min-h-screen flex flex-col items-center justify-center"><Loader2 className="h-12 w-12 animate-spin text-pirate-navy mb-4" /><p className="text-pirate-navy/80">Shuffling the Deck...</p></div>); }
  if (questionFetchError) { return (<div className="min-h-screen flex flex-col items-center justify-center p-4"><Card className="p-6 text-center border-destructive bg-destructive/10"><AlertTriangle className="h-12 w-12 text-destructive mx-auto mb-4" /><h2 className="text-xl font-semibold text-destructive mb-2">Stormy Seas Ahead!</h2><p className="text-destructive/80 mb-4">{questionFetchError}</p><PirateButton onClick={() => navigate('/')} variant="secondary">Abandon Ship (Return Home)</PirateButton></Card></div>); }
  if (!question || !currentUserId || !packName) { if (!isLoadingQuestions && gameQuestions.length === 0) { return (<div className="min-h-screen flex flex-col items-center justify-center p-4"><Card className="p-6 text-center border-pirate-navy/20 bg-pirate-parchment"><AlertTriangle className="h-12 w-12 text-pirate-navy/50 mx-auto mb-4" /><h2 className="text-xl font-semibold text-pirate-navy mb-2">Empty Chest!</h2><p className="text-pirate-navy/80 mb-4">No questions found in this treasure map.</p><PirateButton onClick={() => navigate('/')} variant="secondary">Return Home</PirateButton></Card></div>); } return <div className="min-h-screen flex items-center justify-center">Chartin' the Course...</div>; }

  // --- Main Gameplay Render ---
  return (
    <div className="min-h-screen flex flex-col">
      <GameHeader />
      <main className="flex-1 container mx-auto px-4 py-6 flex flex-col">
        <div className="text-center mb-2">
          <h2 className="font-pirate text-3xl text-pirate-navy capitalize">{packName.replace(/-/g, ' ')}</h2>
          <p className="text-pirate-navy/80 font-medium">Question {currentQuestionIndex + 1} of {totalQuestionsToPlay}</p>
        </div>
        <QuestionTimer timeRemaining={timeRemaining} totalTime={question.timeLimit} />
        <div className="map-container p-0 mb-6 flex-1 flex">
          <QuestionCard
            questionText={question.text}
            answers={question.answers}
            selectedAnswer={selectedAnswer}
            isAnswered={isAnswered} // Pass down isAnswered state
            correctAnswer={question.correctAnswer}
            onAnswerSelect={handleAnswerSelect}
            playerSelectionsByAnswer={playerSelectionsByAnswer}
            maxHeight={maxHeight}
            questionTextClass={questionTextClass}
            answerRefs={answerRefs}
            answerButtonProps={{
              onSubmit: handleSubmit,
              disabled: !selectedAnswer && !isAnswered,
              isAnswered: isAnswered,
              isCorrect: isCorrect,
            }}
          />
        </div>
      </main>
      <style>{`@keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); } 20%, 40%, 60%, 80% { transform: translateX(5px); } } .animate-shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }`}</style>
      <footer className="ocean-bg py-8"><div className="container mx-auto text-center text-white relative z-10"><p className="font-pirate text-xl mb-2">Answer wisely, matey!</p><p className="text-sm opacity-75"> 2023 Trivia Trove - All Rights Reserved</p></div></footer>
    </div>
  );
};

export default GameplayScreen;
// --- END OF FULL MODIFIED FILE ---
</file>

<file path="website/src/pages/GameSelect.tsx">
// website/src/pages/GameSelect.tsx
// --- START OF FILE ---
import React, { useEffect, useState } from 'react';
import { Link, useParams, useSearchParams, useNavigate } from 'react-router-dom';
import {
  ArrowLeft, BookOpen, Globe, Lightbulb, Film, Dices, Users, Copy, Search, Music, Map, Trophy, Utensils, BriefcaseMedical, Building2, PenTool, Landmark, Languages, LucideIcon, Ship, BookText, Loader2, AlertCircle
} from 'lucide-react';
import Header from '@/components/Header';
import PirateButton from '@/components/PirateButton';
import { Card } from '@/components/ui/card';
import { toast } from 'sonner';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Input } from '@/components/ui/input';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Skeleton } from '@/components/ui/skeleton';
import GameSettings from '@/components/GameSettings';
import { createGameSession, startGame } from '@/services/gameApi'; // Added startGame
import { fetchPacks } from '@/services/packApi';
import { createTemporaryUser, updateUser } from '@/services/userApi';
import { getPirateNameForUserId } from '@/utils/gamePlayUtils';
import { ApiPackResponse, GameCreationPayload, ApiGameSessionResponse, ApiUserResponse } from '@/types/apiTypes';

// --- Icon Mapping ---
const getIconForPack = (packName: string): React.ReactNode => {
    const lowerName = packName.toLowerCase();
    if (lowerName.includes("history")) return <BookOpen className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("science")) return <Lightbulb className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("entertainment")) return <Film className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("music")) return <Music className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("geography")) return <Map className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("sport")) return <Trophy className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("food") || lowerName.includes("drink")) return <Utensils className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("medicine")) return <BriefcaseMedical className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("architecture")) return <Building2 className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("art")) return <PenTool className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("politic")) return <Landmark className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("language")) return <Languages className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("maritime") || lowerName.includes("ship") || lowerName.includes("pirate")) return <Ship className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("literature") || lowerName.includes("book")) return <BookText className="h-6 w-6 text-pirate-navy" />;
    if (lowerName.includes("random") || lowerName.includes("mix")) return <Dices className="h-6 w-6 text-pirate-navy" />;
    // Default icon
    return <Globe className="h-6 w-6 text-pirate-navy" />;
};
// --- END Icon Mapping ---

interface CategoryCardProps {
  title: string;
  icon: React.ReactNode;
  description: string;
  onClick: () => void;
}

const CategoryCard: React.FC<CategoryCardProps> = ({ title, icon, description, onClick }) => {
  return (
    <div onClick={onClick} className="cursor-pointer">
      <Card className="h-full border-pirate-navy/20 hover:border-pirate-gold transition-colors p-6 flex flex-col items-center text-center hover:shadow-md">
        <div className="bg-pirate-navy/10 p-3 rounded-full mb-4">
          {icon}
        </div>
        <h3 className="font-pirate text-xl text-pirate-navy mb-2">{title}</h3>
        <p className="text-pirate-navy/70 text-sm">{description || "Test your knowledge in this category!"}</p>
      </Card>
    </div>
  );
};


interface GameSelectProps {
  mode: 'solo' | 'crew';
}

const GameSelect: React.FC<GameSelectProps> = ({ mode }) => {
  const { role } = useParams<{ role?: string }>();
  const [searchParams] = useSearchParams();
  const gameCodeFromUrl = searchParams.get('gameCode');
  const navigate = useNavigate();
  const [searchQuery, setSearchQuery] = useState('');
  const [availablePacks, setAvailablePacks] = useState<ApiPackResponse[]>([]);
  const [selectedPack, setSelectedPack] = useState<ApiPackResponse | null>(null);
  const [isLoadingPacks, setIsLoadingPacks] = useState(true); // Start true initially
  const [fetchPacksError, setFetchPacksError] = useState<string | null>(null);
  const [isCreatingGame, setIsCreatingGame] = useState(false);

  const [hostUserId, setHostUserId] = useState<string | null>(null);
  // Add state for current user's display name, needed for solo user creation feedback
  const [currentUserDisplayName, setCurrentUserDisplayName] = useState<string | null>(null);

  // --- MODIFIED useEffect to handle user creation for SOLO mode ---
  useEffect(() => {
    const initializeUser = async () => {
      let storedUserId = localStorage.getItem('tempUserId');
      let storedName = localStorage.getItem('tempUserDisplayName');

      if (storedUserId) {
        // User ID already exists, just set the state
        setHostUserId(storedUserId);
        // Use stored name or assign one if missing for some reason
        const nameToUse = storedName || getPirateNameForUserId(storedUserId);
        setCurrentUserDisplayName(nameToUse);
        console.log("Retrieved existing temporary user ID:", storedUserId, "Name:", nameToUse);
      } else if (mode === 'solo') {
        // --- SOLO MODE: User ID missing, CREATE IT ---
        console.log("Solo mode: Temporary user ID not found, creating one...");
        setIsLoadingPacks(true); // Keep loading packs indicator on while creating user
        try {
          const user: ApiUserResponse = await createTemporaryUser(null); // Create user without name first
          if (!user?.id) {
            throw new Error("Failed to get valid ID after user creation.");
          }
          const userId = user.id;
          const assignedName = getPirateNameForUserId(userId); // Assign name based on ID

          console.log(`Solo mode: Created user ${userId}, assigned name '${assignedName}'. Storing locally.`);
          localStorage.setItem('tempUserId', userId);
          localStorage.setItem('tempUserDisplayName', assignedName);

          setHostUserId(userId); // Set state for this component instance
          setCurrentUserDisplayName(assignedName);

          // Attempt to update backend silently, don't block UI if it fails
          try {
              console.log(`Solo mode: Attempting to update backend user ${userId} with name '${assignedName}'...`);
              await updateUser(userId, { displayname: assignedName });
              console.log(`Solo mode: Backend update successful for user ${userId}.`);
          } catch (updateError) {
              console.warn(`Solo mode: Failed to update backend displayname for ${userId}:`, updateError);
              // Don't show toast here, it's less critical for solo setup
          }

        } catch (error) {
          console.error("Failed to create temporary user for solo mode:", error);
          toast.error("Initialization Failed", { description: "Could not prepare your solo session. Please try again." });
          navigate('/'); // Navigate home on creation failure
          return; // Stop further execution in this effect
        }
        // Note: setIsLoadingPacks(false) is NOT called here; the pack loading effect will handle it now that hostUserId is set.

      } else if (mode === 'crew') {
        // --- CREW MODE: User ID missing, this is an error ---
        console.error("Crew mode: Temporary user ID not found in localStorage!");
        toast.error("User session not found", { description: "Please select your role again." });
        navigate('/crew'); // Navigate back to role selection for crew
      }
    };

    initializeUser();

  }, [navigate, mode]); // Dependencies remain the same
  // --- END MODIFIED useEffect ---

    useEffect(() => {
    const loadPacks = async () => {
      // Don't set loading true here if it was already set by user creation
      // setIsLoadingPacks(true);
      setFetchPacksError(null);
      try {
        console.log("Fetching packs now that user ID is available:", hostUserId);
        const response = await fetchPacks();
        setAvailablePacks(response.packs);
      } catch (error) {
        console.error("Failed to fetch packs:", error);
        const errorMsg = error instanceof Error ? error.message : "Could not load categories.";
        setFetchPacksError(errorMsg);
        toast.error("Failed to Load Categories", { description: errorMsg });
      } finally {
        setIsLoadingPacks(false); // Set loading false *after* attempting to fetch packs
      }
    };
    // Trigger pack loading ONLY when hostUserId is available
    if (hostUserId) {
         loadPacks();
    } else {
        // If hostUserId is not yet set (e.g., still creating), keep loading state true
        // or handle appropriately based on your desired UX.
        // Setting it true here might cause a flash if user creation is fast.
        // Let's ensure it stays true if no hostUserId exists yet.
        if (!isLoadingPacks) {
            // This case shouldn't ideally happen if the logic flow is correct,
            // but as a safeguard, keep loading if ID isn't ready.
            setIsLoadingPacks(true);
        }
    }
  }, [hostUserId]); // Depends only on hostUserId

  useEffect(() => {
    if (mode === 'crew' && (!role || !gameCodeFromUrl)) {
        // Captains arriving at /crew/captain without a code yet IS allowed
        if (role !== 'captain') {
            navigate('/crew');
        }
    }
  }, [mode, role, gameCodeFromUrl, navigate]);

   const getPageTitle = () => {
    if (mode === 'solo') return 'Solo Journey';
    if (mode === 'crew' && role === 'captain') return 'Chart Your Course, Captain!';
    return '';
  };

  const getPageDescription = () => {
    if (mode === 'solo') return 'Test your knowledge on a solo adventure!';
    if (mode === 'crew' && role === 'captain') return 'Select a category and configure the rules for your crew.';
    return '';
  };

  const getBackLink = () => {
    if (mode === 'solo') return '/';
    if (role === 'captain') return '/crew';
    return '/crew';
  };

   const copyGameCodeToClipboard = () => {
    if (gameCodeFromUrl) {
      navigator.clipboard.writeText(gameCodeFromUrl)
        .then(() => {
          toast('Copied to clipboard', { description: 'Game code copied successfully!' });
        })
        .catch(() => {
          toast('Failed to copy', { description: 'Please try copying manually' });
        });
    }
  };


  const handlePackSelect = (pack: ApiPackResponse) => {
    setSelectedPack(pack);
  };

  const handleBackToCategories = () => {
    setSelectedPack(null);
  };

  // --- MODIFIED handleGameSettingsSubmit to include packName ---
  const handleGameSettingsSubmit = async (gameSettings: {
    numberOfQuestions: number;
    timePerQuestion: number;
    focus: string; // Keep focus even if not used in payload yet
  }) => {
    if (!selectedPack) {
      toast.error("No pack selected.");
      return;
    }
    if (!hostUserId) {
        toast.error("User session error", { description: "Could not identify the user. Please restart." });
        return;
    }

    setIsCreatingGame(true); // Indicate loading state

    const creationPayload: GameCreationPayload = {
      pack_id: selectedPack.id,
      max_participants: mode === 'solo' ? 1 : 10, // Use 1 for SOLO
      question_count: gameSettings.numberOfQuestions,
      time_limit_seconds: gameSettings.timePerQuestion,
    };

    try {
      // Step 1: Create the game session
      console.log(`Calling createGameSession for ${mode}:`, creationPayload, hostUserId);
      const createdGame: ApiGameSessionResponse = await createGameSession(creationPayload, hostUserId);
      console.log(`${mode} game session created successfully:`, createdGame);

      let targetPath: string;

      if (mode === 'solo') {
          // --- Step 2 (SOLO ONLY): START the solo game immediately ---
          console.log(`Calling startGame for solo game ID: ${createdGame.id} by host: ${hostUserId}`);
          const startResponse = await startGame(createdGame.id, hostUserId);
          console.log("Solo game started successfully (backend response):", startResponse);

          // Ensure the game status is indeed active after starting
          if (startResponse.status !== 'active') {
             throw new Error(`Game did not activate properly. Status: ${startResponse.status}`);
          }
          // --- End Step 2 (SOLO ONLY) ---

          // Step 3 (SOLO): Navigate to countdown
          targetPath = `/countdown`;
          navigate(targetPath, {
            state: {
              gameId: createdGame.id, // Use the ID from the created session
              packId: selectedPack.id,
              packName: selectedPack.name, // <-- ADD packName here
              totalQuestions: createdGame.question_count // Use count from created session
            }
          });
      } else { // Crew mode
          // Step 2 (CREW): Navigate to waiting room (start happens later)
          const newGameCode = createdGame.code;
          targetPath = `/crew/waiting/${role}?gameCode=${newGameCode}`;
          navigate(targetPath, {
            state: {
              gameSession: createdGame,
              packId: selectedPack.id, // Pass packId
              packName: selectedPack.name, // <-- ADD packName here
            }
          });
      }

    } catch (error) {
      console.error(`Failed to create or start ${mode} game:`, error);
      toast.error("Failed to Start Game", {
        description: error instanceof Error ? error.message : "An unknown error occurred.",
      });
    } finally {
        // Ensure loading state is turned off if an error occurred before navigation
         setIsCreatingGame(false);
    }
  };
  // --- END MODIFIED handleGameSettingsSubmit ---

   const filteredPacks = availablePacks.filter(pack =>
    pack.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    (pack.description && pack.description.toLowerCase().includes(searchQuery.toLowerCase()))
  );


  // JSX Rendering
  return (
    <div className="min-h-screen flex flex-col">
      <Header />

      <main className="flex-1 container mx-auto px-4 py-8">
        <div className="flex items-center justify-between mb-6">
          {/* Back button logic */}
          {!selectedPack ? (
            <Link to={getBackLink()} className="flex items-center text-pirate-navy hover:text-pirate-accent">
              <ArrowLeft className="h-4 w-4 mr-2" />
              <span>Back</span>
            </Link>
          ) : (
            <button
              onClick={handleBackToCategories}
              disabled={isCreatingGame}
              className="flex items-center text-pirate-navy hover:text-pirate-accent disabled:opacity-50"
            >
              <ArrowLeft className="h-4 w-4 mr-2" />
              <span>Back to Categories</span>
            </button>
          )}

          {/* Game Code Display */}
           {mode === 'crew' && gameCodeFromUrl && (
            <div className="flex items-center">
              <Users className="h-4 w-4 mr-2 text-pirate-navy" />
              <span className="text-sm font-mono bg-pirate-navy/10 px-2 py-1 rounded">
                {gameCodeFromUrl}
              </span>
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <button
                      onClick={copyGameCodeToClipboard}
                      className="ml-2 p-1 text-pirate-navy hover:text-pirate-gold transition-colors rounded-full hover:bg-pirate-navy/10"
                      aria-label="Copy game code"
                    >
                      <Copy className="h-4 w-4" />
                    </button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Copy game code</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
          )}
        </div>

        <div className="map-container p-6 md:p-8 mb-10 relative">
          {getPageTitle() && <h1 className="pirate-heading text-3xl md:text-4xl mb-3">{getPageTitle()}</h1>}
          {getPageDescription() && <p className="text-pirate-navy/80 mb-8">{getPageDescription()}</p>}

          {/* Conditional Rendering Logic */}
          {isLoadingPacks ? ( // Combined loading state
             <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 h-[calc(100vh-350px)]">
              {[...Array(6)].map((_, i) => (
                <Card key={i} className="p-6 flex flex-col items-center">
                  <Skeleton className="h-12 w-12 rounded-full mb-4 bg-pirate-navy/10" />
                  <Skeleton className="h-5 w-3/4 mb-2 bg-pirate-navy/10" />
                  <Skeleton className="h-4 w-full bg-pirate-navy/5" />
                  <Skeleton className="h-4 w-5/6 mt-1 bg-pirate-navy/5" />
                </Card>
              ))}
            </div>
          ) : fetchPacksError ? (
            <div className="text-center py-10 text-destructive">
                <AlertCircle className="h-12 w-12 mx-auto mb-4" />
                <h3 className="font-semibold text-lg mb-2">Failed to Load Categories</h3>
                <p className="text-sm">{fetchPacksError}</p>
                <PirateButton onClick={() => window.location.reload()} className="mt-4" variant="secondary">
                    Try Again
                </PirateButton>
            </div>
          ) : !selectedPack ? (
            // Category Selection View
            <>
              <div className="relative mb-6">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-pirate-navy/50" />
                <Input
                  placeholder="Search categories..."
                  className="pl-10 border-pirate-navy/20 focus-visible:ring-pirate-gold"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                />
              </div>
               <ScrollArea className="h-[calc(100vh-350px)] pr-4">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                  {filteredPacks.map((pack) => (
                    <CategoryCard
                      key={pack.id}
                      title={pack.name}
                      icon={getIconForPack(pack.name)}
                      description={pack.description || ""}
                      onClick={() => handlePackSelect(pack)}
                    />
                  ))}
                  {filteredPacks.length === 0 && availablePacks.length > 0 && !isLoadingPacks && (
                    <div className="col-span-full text-center py-10">
                      <p className="text-pirate-navy/60 text-lg">No categories match your search</p>
                      <p className="text-pirate-navy/40">Try a different search term</p>
                    </div>
                  )}
                   {availablePacks.length === 0 && !isLoadingPacks && !fetchPacksError && (
                        <div className="col-span-full text-center py-10">
                            <p className="text-pirate-navy/60 text-lg">No trivia packs available right now.</p>
                            <p className="text-pirate-navy/40">Check back later!</p>
                        </div>
                   )}
                </div>
              </ScrollArea>
            </>
          ) : (
             // Game Settings View
            <GameSettings
              category={{
                 title: selectedPack.name,
                 icon: getIconForPack(selectedPack.name),
                 description: selectedPack.description || '',
                 slug: selectedPack.name.toLowerCase().replace(/\s+/g, '-'),
                 focuses: [] // Focuses not currently used but needed by type
              }}
              onSubmit={handleGameSettingsSubmit}
              mode={mode}
              role={role} // Pass role here, although not directly used by GameSettings itself
            />
          )}

          {/* Loading Indicator for Game Creation */}
          {isCreatingGame && (
            <div className="absolute inset-0 bg-pirate-parchment/80 flex items-center justify-center rounded-xl z-20">
              <Loader2 className="h-8 w-8 animate-spin text-pirate-navy" />
              <span className="ml-2 font-semibold text-pirate-navy">
                {mode === 'solo' ? 'Starting Solo Game...' : 'Creating Crew Game...'}
              </span>
            </div>
          )}
        </div>
      </main>

      {/* Footer */}
       <footer className="ocean-bg py-8">
        <div className="container mx-auto text-center text-white relative z-10">
          <p className="font-pirate text-xl mb-2">Choose yer category, matey!</p>
          <p className="text-sm opacity-75"> 2023 Trivia Trove - All Rights Reserved</p>
        </div>
      </footer>
    </div>
  );
};

export default GameSelect;
// --- END OF FILE ---
</file>

<file path="website/src/pages/Index.tsx">
import React from 'react';
import { Link } from 'react-router-dom';
import { Anchor, Compass, Skull, MapPin } from 'lucide-react';
import Header from '@/components/Header';
import PirateButton from '@/components/PirateButton';

const Index = () => {
  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      
      <main className="flex-1 flex flex-col items-center justify-center p-6 relative">
        <div className="absolute inset-0 bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxnIGZpbGw9IiMwQTI0NjMiIGZpbGwtb3BhY2l0eT0iMC4wNSI+PHBhdGggZD0iTTM2IDM0di00aC0ydjRoLTR2Mmg0djRoMnYtNGg0di0yaC00em0wLTMwVjBoLTJ2NGgtNHYyaDR2NGgyVjZoNFY0aC00ek02IDM0di00SDR2NEgwdjJoNHY0aDJ2LTRoNHYtMkg2ek02IDRWMEg0djRIMHYyaDR2NGgyVjZoNFY0SDZ6Ii8+PC9nPjwvZz48L3N2Zz4=')] opacity-30 -z-10"></div>
        
        <div className="w-full max-w-4xl flex flex-col items-center">
          <div className="flex items-center justify-center mb-4 animate-float">
            <Anchor className="text-pirate-gold h-12 w-12 mr-2" />
            <Skull className="text-pirate-navy h-10 w-10" />
            <MapPin className="text-pirate-accent h-10 w-10 ml-2" />
          </div>
          
          <h1 className="pirate-heading text-5xl md:text-7xl text-center mb-4">
            Trivia Trove
          </h1>
          
          <p className="text-xl md:text-2xl text-center text-pirate-navy/80 mb-12 max-w-2xl">
            Test your knowledge solo or challenge your friends!
          </p>
          
          <div className="grid gap-6 w-full max-w-md">
            <Link to="/crew" className="w-full">
              <PirateButton 
                variant="primary" 
                className="w-full text-lg"
                icon={<Compass className="h-5 w-5" />}
              >
                Play with a Crew
              </PirateButton>
            </Link>
            
            <Link to="/solo" className="w-full">
              <PirateButton 
                variant="secondary" 
                className="w-full text-lg"
              >
                Solo Journey
              </PirateButton>
            </Link>
          </div>
        </div>
      </main>
      
      <footer className="ocean-bg py-8 mt-12">
        <div className="container mx-auto text-center text-white relative z-10">
          <p className="font-pirate text-xl mb-2">Ahoy, Trivia Seekers!</p>
          <p className="text-sm opacity-75"> 2023 Trivia Trove - All Rights Reserved</p>
        </div>
      </footer>
    </div>
  );
};

export default Index;
</file>

<file path="website/src/pages/NotFound.tsx">
import { useLocation } from "react-router-dom";
import { useEffect } from "react";

const NotFound = () => {
  const location = useLocation();

  useEffect(() => {
    console.error(
      "404 Error: User attempted to access non-existent route:",
      location.pathname
    );
  }, [location.pathname]);

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="text-center">
        <h1 className="text-4xl font-bold mb-4">404</h1>
        <p className="text-xl text-gray-600 mb-4">Oops! Page not found</p>
        <a href="/" className="text-blue-500 hover:text-blue-700 underline">
          Return to Home
        </a>
      </div>
    </div>
  );
};

export default NotFound;
</file>

<file path="website/src/pages/ResultsScreen.tsx">
// src/pages/ResultsScreen.tsx
import React, { useEffect, useState } from 'react';
import { useNavigate, useLocation, useParams, useSearchParams } from 'react-router-dom';
import { Trophy, RotateCcw, Home, Star } from 'lucide-react'; // Added Star
import Header from '@/components/Header';
import PirateButton from '@/components/PirateButton';
import { Card } from '@/components/ui/card';
import PlayerAvatar from '@/components/PlayerAvatar';
import { Player } from '@/types/gameTypes';
import confetti from 'canvas-confetti';

// Define result type extending Player
interface PlayerResult extends Player {
  score: number;
}

const ResultsScreen: React.FC = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { role } = useParams<{ role?: string }>();
  const [searchParams] = useSearchParams();
  const gameCode = searchParams.get('gameCode');
  const isSoloMode = !gameCode; // Determine mode based on gameCode presence
  const [playerResults, setPlayerResults] = useState<PlayerResult[]>([]);

  useEffect(() => {
    const results = location.state?.results as PlayerResult[] || [];
    console.log("Received results:", results); // Debug log

    // Sort players by score (highest first) - still useful for crew mode
    const sortedResults = [...results].sort((a, b) => b.score - a.score);
    setPlayerResults(sortedResults);

    // Launch confetti only if there's a winner with a positive score
    if (sortedResults.length > 0 && sortedResults[0].score > 0) {
      launchConfetti();
    }
  }, [location.state]);

  const launchConfetti = () => {
    confetti({
      particleCount: 100,
      spread: 70,
      origin: { y: 0.6 }
    });
  };

  const handlePlayAgain = () => {
    // Navigation logic remains the same
    const category = searchParams.get('category') || '';
    const questions = searchParams.get('questions') || '';
    const time = searchParams.get('time') || '';

    if (gameCode && role) { // Crew game
       if (role === 'captain') {
         navigate(`/crew/captain?gameCode=${gameCode}`);
       } else {
         navigate(`/crew/waiting/${role}?gameCode=${gameCode}&category=${category}&questions=${questions}&time=${time}`);
       }
    } else { // Solo game
       navigate('/solo');
    }
  };

  const handleReturnHome = () => {
    navigate('/');
  };

  const getPositionLabel = (index: number): string => {
    switch (index) {
      case 0: return '1st';
      case 1: return '2nd';
      case 2: return '3rd';
      default: return `${index + 1}th`;
    }
  };

  // Get the single player result for solo mode
  const soloPlayer = isSoloMode && playerResults.length > 0 ? playerResults[0] : null;
  console.log("Solo Player Data:", soloPlayer); // Debug log

  return (
    <div className="min-h-screen flex flex-col">
      <Header />

      <main className="flex-1 container mx-auto px-4 py-8">
        <div className="text-center mb-8">
          {/* *** MODIFICATION: Conditional Title *** */}
          <h1 className="font-pirate text-4xl md:text-5xl text-pirate-navy mb-2">
            Voyage Complete!
          </h1>
          {/* *** MODIFICATION: Conditional Description *** */}
          <p className="text-pirate-navy/80 font-medium">
            {isSoloMode
              ? "See how you stacked up against the challenges"
              : "See how your crew stacked up against the challenges"}
          </p>
        </div>

        <div className="map-container p-6 md:p-8 mb-8">
          <div className="mb-8">
             {/* *** MODIFICATION: Conditional Header *** */}
            <div className="flex items-center justify-center mb-6">
              {isSoloMode ? (
                 <Star className="h-8 w-8 text-pirate-gold mr-3" />
              ) : (
                 <Trophy className="h-8 w-8 text-pirate-gold mr-3" />
              )}
              <h2 className="font-pirate text-3xl text-pirate-navy">
                {isSoloMode ? "Final Score" : "Final Standings"}
              </h2>
            </div>

            {/* *** MODIFICATION: Conditional Result Display *** */}
            {isSoloMode ? (
              // Solo Mode Display
              soloPlayer ? (
                <Card className="p-6 flex flex-col items-center border-2 border-pirate-gold bg-pirate-gold/5">
                  <PlayerAvatar
                    playerId={soloPlayer.id}
                    name={soloPlayer.name} // Use the name from the result
                    size="lg"
                    className="mb-4 border-2 border-pirate-gold"
                  />
                  <p className="font-bold text-xl text-pirate-navy mb-2">
                    {soloPlayer.name} {/* Display the name */}
                  </p>
                  <div className="flex items-baseline bg-pirate-parchment px-6 py-3 rounded-full">
                    <span className="font-bold text-4xl text-pirate-navy">{soloPlayer.score}</span>
                    <span className="text-lg text-pirate-navy/70 ml-2">pts</span>
                  </div>
                </Card>
              ) : (
                 <p className="text-center text-pirate-navy/60 py-4">No score available.</p>
              )
            ) : (
              // Crew Mode Display (Existing Logic)
              <div className="grid gap-4">
                {playerResults.map((player, index) => (
                  <Card
                    key={player.id}
                    className={`p-4 flex items-center justify-between border-2 ${
                      index === 0 ? 'border-pirate-gold bg-pirate-gold/5' : 'border-pirate-navy/20'
                    }`}
                  >
                    <div className="flex items-center space-x-4">
                      <div className="flex-shrink-0 font-bold text-pirate-navy/70 w-8 text-center">
                        {getPositionLabel(index)}
                      </div>
                      <PlayerAvatar
                        playerId={player.id}
                        name={player.name} // Use name from result
                        size="lg"
                        className={index === 0 ? "border-2 border-pirate-gold" : ""}
                      />
                      <div>
                        <p className={`font-bold text-lg ${index === 0 ? 'text-pirate-navy' : 'text-pirate-navy/90'}`}>
                          {player.name} {/* Display name */}
                        </p>
                        {index === 0 && (
                          <p className="text-xs text-pirate-gold font-medium">Winner!</p>
                        )}
                      </div>
                    </div>
                    <div className="flex items-center bg-pirate-parchment px-4 py-2 rounded-full">
                      <span className="font-bold text-xl text-pirate-navy">{player.score}</span>
                      <span className="text-xs text-pirate-navy/70 ml-1">pts</span>
                    </div>
                  </Card>
                ))}
                 {playerResults.length === 0 && (
                     <p className="text-center text-pirate-navy/60 py-4">No results available.</p>
                 )}
              </div>
            )}
            {/* *** END MODIFICATION *** */}

          </div>

          {/* Buttons remain the same */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-8">
            <PirateButton
              onClick={handlePlayAgain}
              variant="primary"
              icon={<RotateCcw className="h-5 w-5" />}
            >
              {gameCode ? 'Same crew, new journey' : 'Play Again'}
            </PirateButton>

            <PirateButton
              onClick={handleReturnHome}
              variant="secondary"
              icon={<Home className="h-5 w-5" />}
            >
              Return Home
            </PirateButton>
          </div>
        </div>
      </main>

      {/* Footer remains the same */}
      <footer className="ocean-bg py-8">
        <div className="container mx-auto text-center text-white relative z-10">
          <p className="font-pirate text-xl mb-2">Adventure awaits, matey!</p>
          <p className="text-sm opacity-75"> 2023 Trivia Trove - All Rights Reserved</p>
        </div>
      </footer>
    </div>
  );
};

export default ResultsScreen;
</file>

<file path="website/src/pages/RoleSelect.tsx">
// src/pages/RoleSelect.tsx
// --- START OF MODIFIED FILE ---
import React, { useState, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { ArrowLeft, Anchor, User, UserPlus, Ship, Loader2 } from 'lucide-react';
import Header from '@/components/Header';
import PirateButton from '@/components/PirateButton';
import { Card } from '@/components/ui/card';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Input } from '@/components/ui/input';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { useForm } from 'react-hook-form';
import { toast } from 'sonner';
// --- IMPORT updateUser ---
import { createTemporaryUser, updateUser } from '@/services/userApi';
// --- END IMPORT updateUser ---
import { ApiUserResponse } from '@/types/apiTypes';
import { getPirateNameForUserId } from '@/utils/gamePlayUtils';

interface RoleFormValues {
  role: 'captain' | 'scallywag';
  gameCode?: string;
}

const RoleSelect: React.FC = () => {
  const navigate = useNavigate();
  const [isLoading, setIsLoading] = useState(false);

  const form = useForm<RoleFormValues>({
    defaultValues: {
      role: 'captain',
      gameCode: '',
    },
  });

  const selectedRole = form.watch('role');

  // --- MODIFIED onSubmit ---
  const onSubmit = async (data: RoleFormValues) => {
    setIsLoading(true);
    let user: ApiUserResponse | null = null;
    let userId: string | null = null;
    let assignedName: string | null = null;

    try {
      // --- Step 1: Create Temporary User (pass null for name) ---
      console.log(`Creating temporary user record...`);
      user = await createTemporaryUser(null); // Pass null for displayName initially
      console.log("Temporary user created (backend):", user);

      if (!user?.id) {
         throw new Error("Failed to get valid ID after user creation.");
      }
      userId = user.id; // Store the ID

      // --- Step 2: Assign and Store Name LOCALLY ---
      assignedName = getPirateNameForUserId(userId); // Assign name based on the retrieved ID
      console.log(`Assigned name '${assignedName}' to user ${userId}`);
      localStorage.setItem('tempUserId', userId);
      localStorage.setItem('tempUserDisplayName', assignedName); // Store the *assigned* name

      // --- Step 3: UPDATE User Record on BACKEND with the Assigned Name ---
      console.log(`Updating backend user record ${userId} with name '${assignedName}'...`);
      try {
          await updateUser(userId, { displayname: assignedName }); // Send update request
          console.log(`Successfully updated user ${userId} displayname on backend.`);
      } catch (updateError) {
          // Log the error but proceed - game creation might still work using fallback name
          console.error(`Failed to update user ${userId} displayname on backend:`, updateError);
          toast.warning("Name Update Failed", { description: "Could not save your pirate name to the server, using a default." });
      }

      // --- Step 4: Navigate Based on Role ---
      if (data.role === 'captain') {
        console.log("Navigating Captain to Game Select...");
        navigate(`/crew/captain`); // Proceed to game creation

      } else { // Scallywag Flow
        console.log("Validating game code and navigating Scallywag to Waiting Room...");
        if (!data.gameCode?.trim()) {
             toast.warning("Missing Game Code", { description: "Please provide the game code." });
             setIsLoading(false);
             return; // Stop execution
         }
         const gameCodeValue = data.gameCode.toUpperCase().trim();
         console.log(`Navigating Scallywag (User ID: ${userId}, Name: ${assignedName}) to Waiting Room for game code: ${gameCodeValue}`);
         // Scallywag will send their name during the join request anyway
         navigate(`/crew/waiting/scallywag?gameCode=${gameCodeValue}`);
      }

    } catch (error) {
      console.error("Error during role selection flow:", error);
      const action = data.role === 'captain' ? 'proceed' : 'continue';
      const baseMessage = `Failed to ${action}.`;
      let description = "An unknown error occurred.";
      if (error instanceof Error) {
          description = error.message.startsWith('Failed to')
              ? error.message
              : `${baseMessage} ${error.message}`;
      }
      toast.error("Action Failed", { description });
    } finally {
      setIsLoading(false);
    }
  };
  // --- END MODIFIED onSubmit ---

  // --- JSX (No changes needed from the previous version) ---
  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <main className="flex-1 container mx-auto px-4 py-8">
        <Link to="/" className="flex items-center text-pirate-navy hover:text-pirate-accent mb-6">
          <ArrowLeft className="h-4 w-4 mr-2" />
          <span>Back to Home</span>
        </Link>
        <div className="map-container p-6 md:p-8 mb-10 max-w-md mx-auto relative">
          <h1 className="pirate-heading text-3xl md:text-4xl mb-3 text-center">Join a Crew</h1>
          <p className="text-pirate-navy/80 mb-8 text-center">Choose your role in this voyage!</p>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Role Selection RadioGroup */}
              <FormField
                control={form.control}
                name="role"
                render={({ field }) => (
                  <FormItem className="space-y-3">
                    <FormControl>
                       <RadioGroup
                        onValueChange={field.onChange}
                        value={field.value}
                        className="grid grid-cols-1 gap-4"
                      >
                        {/* Captain Card */}
                        <FormLabel htmlFor="captain" className="cursor-pointer">
                            <Card className={`p-4 transition-all ${ field.value === 'captain' ? 'border-pirate-gold shadow-md bg-gradient-to-r from-pirate-navy to-pirate-navy/90 text-white' : 'border-pirate-navy/20 hover:border-pirate-navy/50' }`}>
                                <div className="flex items-start space-x-3">
                                    <RadioGroupItem value="captain" id="captain" className={`mt-1 ${field.value === 'captain' ? 'border-white text-white focus-visible:ring-pirate-gold' : 'focus-visible:ring-pirate-gold'}`}/>
                                    <div className="flex-1">
                                        <div className="flex items-center mb-1">
                                            <Anchor className={`h-5 w-5 mr-2 ${field.value === 'captain' ? 'text-pirate-gold' : 'text-pirate-navy'}`} />
                                            <span className="font-bold text-lg">Captain</span>
                                        </div>
                                        <p className={`text-sm ${field.value === 'captain' ? 'text-white/80' : 'text-pirate-navy/70'}`}> Start a new game and invite your crew. </p>
                                    </div>
                                </div>
                            </Card>
                        </FormLabel>
                        {/* Scallywag Card */}
                        <FormLabel htmlFor="scallywag" className="cursor-pointer">
                             <Card className={`p-4 transition-all ${ field.value === 'scallywag' ? 'border-pirate-gold shadow-md bg-gradient-to-r from-pirate-navy to-pirate-navy/90 text-white' : 'border-pirate-navy/20 hover:border-pirate-navy/50' }`}>
                               <div className="flex items-start space-x-3">
                                 <RadioGroupItem value="scallywag" id="scallywag" className={`mt-1 ${field.value === 'scallywag' ? 'border-white text-white focus-visible:ring-pirate-gold' : 'focus-visible:ring-pirate-gold'}`}/>
                                 <div className="flex-1">
                                   <div className="flex items-center mb-1">
                                     <User className={`h-5 w-5 mr-2 ${field.value === 'scallywag' ? 'text-pirate-gold' : 'text-pirate-navy'}`} />
                                     <span className="font-bold text-lg">Scallywag</span>
                                   </div>
                                   <p className={`text-sm ${field.value === 'scallywag' ? 'text-white/80' : 'text-pirate-navy/70'}`}> Join an existing game with a game code. </p>
                                 </div>
                               </div>
                             </Card>
                        </FormLabel>
                      </RadioGroup>
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              {/* Game Code Input (only for Scallywag) */}
              {selectedRole === 'scallywag' && (
                <div className="space-y-4 pt-2">
                  <FormField
                    control={form.control}
                    name="gameCode"
                    rules={{ required: "Need the Captain's code!", pattern: { value: /^[A-Z0-9]{6}$/, message: "Code must be 6 uppercase letters/numbers"} }}
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel htmlFor='gameCode' className="text-pirate-navy/90">Game Code</FormLabel>
                        <FormControl>
                           <Input id='gameCode' placeholder="Enter 6-character code" className="text-center uppercase tracking-widest border-pirate-navy/30 focus-visible:ring-pirate-gold font-mono" maxLength={6} {...field} onChange={(e) => field.onChange(e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, ''))} autoComplete="off" />
                        </FormControl>
                         <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>
              )}
              {/* Submit Button */}
              <div className="pt-4">
                <PirateButton type="submit" className="w-full" disabled={isLoading} icon={selectedRole === 'captain' ? <Anchor className="h-5 w-5" /> : <UserPlus className="h-5 w-5" />} >
                  {isLoading ? (selectedRole === 'captain' ? 'Setting Course...' : 'Joining Crew...') : (selectedRole === 'captain' ? 'Start New Game' : 'Join Crew')}
                </PirateButton>
              </div>
            </form>
          </Form>
           {/* Loading Overlay */}
            {isLoading && (
                <div className="absolute inset-0 bg-pirate-parchment/80 flex items-center justify-center rounded-xl z-20">
                    <Loader2 className="h-8 w-8 animate-spin text-pirate-navy" />
                    <span className="ml-2 font-semibold text-pirate-navy">
                      Setting up your identity...
                    </span>
                </div>
            )}
        </div>
      </main>
      {/* Footer */}
      <footer className="ocean-bg py-8">
        <div className="container mx-auto text-center text-white relative z-10">
          <p className="font-pirate text-xl mb-2">Choose yer role, matey!</p>
          <p className="text-sm opacity-75"> 2023 Trivia Trove - All Rights Reserved</p>
        </div>
      </footer>
    </div>
  );
};
export default RoleSelect;
// --- END OF MODIFIED FILE ---
</file>

<file path="website/src/pages/WaitingRoom.tsx">
// website/src/pages/WaitingRoom.tsx
// --- START OF FULL MODIFIED FILE ---
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useNavigate, useParams, useSearchParams, Link, useLocation } from 'react-router-dom';
import { Users, Copy, Anchor, ArrowLeft, ChevronDown, Settings, Loader2, RefreshCw, Pencil } from 'lucide-react';
import Header from '@/components/Header';
import PirateButton from '@/components/PirateButton';
import { Card } from '@/components/ui/card';
import { toast } from 'sonner';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible';
import PlayerAvatar from '@/components/PlayerAvatar';
import { Player } from '@/types/gameTypes'; // Keep this if used indirectly or needed later
// --- MODIFIED IMPORT: Added getGameParticipants ---
import { joinGameSession, getGameParticipants, startGame } from '@/services/gameApi';
import { updateUser } from '@/services/userApi';
import { getPirateNameForUserId } from '@/utils/gamePlayUtils';
import { ApiParticipant, ApiGameSessionResponse, ApiGameJoinRequest } from '@/types/apiTypes';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useForm } from "react-hook-form";
import { Form, FormControl, FormField, FormItem, FormMessage } from "@/components/ui/form";

// --- WebSocket Imports ---
import { useWebSocket } from '@/hooks/useWebSocket';
import { IncomingWsMessage } from '@/types/websocketTypes';
// --- End WebSocket Imports ---

interface EditNameFormValues {
  newName: string;
}

const WaitingRoom: React.FC = () => {
  const { role } = useParams<{ role?: string }>();
  const [searchParams] = useSearchParams();
  const location = useLocation();
  const gameCode = searchParams.get('gameCode');
  const navigate = useNavigate();

  // State
  const [gameSession, setGameSession] = useState<ApiGameSessionResponse | null>(null);
  const [crewMembers, setCrewMembers] = useState<ApiParticipant[]>([]);
  const [isVoyageDetailsOpen, setIsVoyageDetailsOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);
  const [currentUserDisplayName, setCurrentUserDisplayName] = useState<string | null>(null);
  const [joinAttempted, setJoinAttempted] = useState(false);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [isUpdatingName, setIsUpdatingName] = useState(false);
  const [packName, setPackName] = useState<string | null>(null);

  // Refs
  const gameSessionRef = useRef(gameSession);

  // Form Hook
  const editNameForm = useForm<EditNameFormValues>({ defaultValues: { newName: '' } });

  // --- NEW: Function to fetch participants ---
  const fetchParticipants = useCallback(async (currentGameId: string | undefined) => {
      if (!currentGameId) {
          console.warn("fetchParticipants called without a valid gameId.");
          return;
      }
      console.log(`Fetching participants for game ${currentGameId}...`);
      try {
          const response = await getGameParticipants(currentGameId);
          setCrewMembers(response.participants);
          console.log("Participants fetched:", response.participants);
      } catch (error) {
          console.error("Failed to fetch participants:", error);
          // Avoid showing error toast repeatedly if WS is trying to reconnect
          if (wsStatus === 'connected') {
               toast.error("Sync Error", { description: "Could not update participant list." });
          }
      }
  }, []); // Removed wsStatus dependency, fetching driven by connect/join now

  // --- WebSocket Message Handler ---
  const handleWebSocketMessage = useCallback((message: IncomingWsMessage) => {
    console.log("Received WebSocket Message:", message.type, message.payload);
    switch (message.type) {
      case 'participant_update': {
        const updatedParticipant = message.payload;
        setCrewMembers(prev => {
          const existingIndex = prev.findIndex(p => p.user_id === updatedParticipant.user_id);
          if (existingIndex > -1) {
            const newCrew = [...prev];
            newCrew[existingIndex] = { ...newCrew[existingIndex], ...updatedParticipant };
            return newCrew;
          } else {
            return [...prev, updatedParticipant];
          }
        });
        if (updatedParticipant.user_id === currentUserId && updatedParticipant.display_name !== currentUserDisplayName) {
          console.log(`Updating current user name via WS: ${updatedParticipant.display_name}`);
          setCurrentUserDisplayName(updatedParticipant.display_name);
          localStorage.setItem('tempUserDisplayName', updatedParticipant.display_name);
        }
        break;
      }
      case 'participant_left': {
        const { user_id, display_name } = message.payload; // Destructure display_name
        setCrewMembers(prev => prev.filter(p => p.user_id !== user_id));
        toast.info(`${display_name} left the crew.`); // Use display_name from payload
        break;
      }
      case 'user_name_updated': {
         const { user_id, new_display_name } = message.payload;
         setCrewMembers(prev => prev.map(p => p.user_id === user_id ? { ...p, display_name: new_display_name } : p));
         if (user_id === currentUserId) {
           setCurrentUserDisplayName(new_display_name);
           localStorage.setItem('tempUserDisplayName', new_display_name);
         }
         break;
      }
      case 'game_started': {
        const { game_id, total_questions } = message.payload;
        console.log(`Game ${game_id} started via WebSocket!`);
        toast.success("Game Started!", { description: "Get ready to answer!" });
        navigate(`/countdown`, {
          state: {
            gameId: game_id,
            packName: packName,
            totalQuestions: total_questions,
            gameSession: message.payload
          }
        });
        break;
      }
      case 'game_cancelled': {
        toast.error("Game Cancelled", { description: "The Captain has cancelled the game." });
        navigate(getBackLink());
        break;
      }
      case 'error': {
        toast.error("Server Error", { description: message.payload.message });
        break;
      }
      default:
        console.warn("Received unknown WebSocket message type:", message.type);
    }
  }, [currentUserId, currentUserDisplayName, navigate, packName]); // Include packName

  // --- Initialize WebSocket Connection ---
  const { status: wsStatus } = useWebSocket({
    gameId: gameSession?.id && !gameSession.id.startsWith('unknown') ? gameSession.id : null,
    userId: currentUserId,
    onMessage: handleWebSocketMessage,
    onOpen: () => {
        console.log("WebSocket connected callback triggered.");
        // --- Fetch initial participants on connect ---
        if (gameSessionRef.current?.id && !gameSessionRef.current.id.startsWith('unknown')) {
             fetchParticipants(gameSessionRef.current.id);
        }
        // --- End Fetch ---
    },
    onClose: (event) => console.log("WebSocket closed callback:", event.code),
    onError: (event) => toast.error("Connection Error", { description: "Lost connection to the game server." }),
  });

  // --- User Initialization Effect ---
  useEffect(() => {
    const storedUserId = localStorage.getItem('tempUserId');
    const storedName = localStorage.getItem('tempUserDisplayName');
    if (!storedUserId) {
      console.error("Waiting Room: tempUserId not found in localStorage!");
      toast.error("Session Error", { description: "Could not find your user ID. Please go back."});
      navigate('/crew');
    } else {
      setCurrentUserId(storedUserId);
      const nameToSet = storedName || getPirateNameForUserId(storedUserId);
      setCurrentUserDisplayName(nameToSet);
      editNameForm.setValue('newName', nameToSet);
    }
  }, [navigate, editNameForm]);

  // --- Initialize Captain/Solo state from location ---
  useEffect(() => {
      const stateFromNavigation = location.state as { gameSession?: ApiGameSessionResponse, packName?: string } | undefined;
      // --- Ensure we don't reset loading if it's already false (e.g., after user init) ---
      if (role === 'captain' && currentUserId && currentUserDisplayName && !gameSession && !isLoading) {
           setIsLoading(true); // Set loading specifically for captain initialization
      }

      if (role === 'captain' && currentUserId && currentUserDisplayName && !gameSession) {
          if (stateFromNavigation?.gameSession && stateFromNavigation.gameSession.code === gameCode) {
              console.log("Captain: Initializing with gameSession from navigation state:", stateFromNavigation);
              setGameSession(stateFromNavigation.gameSession);
              setPackName(stateFromNavigation.packName || 'Unknown Pack');
              // Set initial crew member for the host
              setCrewMembers([{ id: 'captain-participant-' + currentUserId, user_id: currentUserId, display_name: currentUserDisplayName, score: 0, is_host: true }]);
              // Fetch initial participants - now handled by WS onOpen
              // fetchParticipants(stateFromNavigation.gameSession.id);
              setIsLoading(false); // Finish loading after captain init
          } else {
              console.warn("Captain: gameSession missing/mismatched in navigation state.");
              toast.error("Game Error", { description: "Could not load game session details." });
              setIsLoading(false); // Ensure loading is false on error
              navigate('/crew');
          }
      } else if (role !== 'captain' && !gameSession && location.state?.packName && !packName) {
          setPackName(location.state.packName);
      } else if (isLoading && gameSession) {
           // If gameSession is now set but isLoading was true, set it to false
           setIsLoading(false);
      }
  }, [role, gameCode, currentUserId, currentUserDisplayName, gameSession, navigate, location.state, packName, isLoading]); // Added packName, isLoading


  // --- Scallywag Join Game Logic ---
  useEffect(() => {
      if (role === 'scallywag' && gameCode && currentUserId && currentUserDisplayName && !joinAttempted && !gameSession) {
          setJoinAttempted(true);
          const performJoin = async () => {
              setIsLoading(true);
              try {
                  const joinPayload: ApiGameJoinRequest = { game_code: gameCode, display_name: currentUserDisplayName };
                  const sessionData = await joinGameSession(joinPayload, currentUserId);
                  gameSessionRef.current = sessionData; // Update ref immediately
                  setGameSession(sessionData);
                  if (!packName && location.state?.packName) {
                     setPackName(location.state.packName);
                  } else if (!packName && sessionData.pack_id) {
                     console.warn("Scallywag joined, but pack name needs fetching (not implemented).");
                     setPackName("Pack Loading...");
                  }
                  // Initial fetch might be redundant if WS connects fast, but good fallback
                  fetchParticipants(sessionData.id);
              } catch (error) {
                  console.error("Failed to join game:", error);
                  const errorMsg = error instanceof Error ? error.message : "Could not join the game.";
                  toast.error("Join Failed", { description: errorMsg });
                  navigate('/crew');
              } finally {
                  setIsLoading(false);
              }
          };
          performJoin();
      }
  }, [role, gameCode, currentUserId, currentUserDisplayName, joinAttempted, navigate, gameSession, packName, location.state, fetchParticipants]); // Added fetchParticipants


  // --- Game Start Logic ---
  const handleStartGame = async () => {
    if (!gameSession?.id || !currentUserId || gameSession.id.startsWith('unknown')) {
      toast.error("Error", { description: "Cannot start game. Missing game or user information." });
      return;
    }
    if (gameCode && crewMembers.length < 2) {
        toast.error("Need More Crew!", { description: "At least one other pirate must join before you can set sail." });
        return;
    }

    setIsLoading(true);
    try {
        await startGame(gameSession.id, currentUserId);
        console.log("Start game request sent successfully. Waiting for WebSocket confirmation...");
    } catch (error) {
        console.error("Failed to send start game request:", error);
        const errorMsg = error instanceof Error ? error.message : "Could not start the game.";
        toast.error("Start Failed", { description: errorMsg });
        setIsLoading(false);
    }
  };

  // --- Edit Name Logic ---
  const handleEditNameSubmit = async (data: EditNameFormValues) => {
    if (!currentUserId) { toast.error("Error", { description: "Cannot update name. User ID missing." }); return; }
    const newName = data.newName.trim();
    if (!newName || newName === currentUserDisplayName) { setIsEditModalOpen(false); return; }

    setIsUpdatingName(true);
    try {
        await updateUser(currentUserId, { displayname: newName });
        setCurrentUserDisplayName(newName);
        localStorage.setItem('tempUserDisplayName', newName);
        setCrewMembers(prevCrew =>
            prevCrew.map(member =>
                member.user_id === currentUserId ? { ...member, display_name: newName } : member
            )
        );
        toast.success("Name Changed!", { description: `Ye be known as ${newName} now!` });
        setIsEditModalOpen(false);
    } catch (error) {
        console.error("Failed to update name:", error);
        toast.error("Update Failed", { description: error instanceof Error ? error.message : "Could not change your name." });
        setIsEditModalOpen(false);
    } finally {
        setIsUpdatingName(false);
    }
  };


  // --- Helper Functions ---
  const copyGameCodeToClipboard = () => { if (gameCode) { navigator.clipboard.writeText(gameCode).then(() => toast.success('Copied!')).catch(() => toast.error('Copy failed')); } };
  const getBackLink = () => role === 'captain' || role === 'scallywag' ? '/crew' : '/';
  const handleOpenEditModal = () => { if (currentUserDisplayName) { editNameForm.setValue('newName', currentUserDisplayName); } setIsEditModalOpen(true); };


  // --- Derived Data ---
  const hostParticipant = crewMembers.find(p => p.is_host);
  const isCurrentUserHost = currentUserId === hostParticipant?.user_id;
  const hostDisplayName = hostParticipant?.display_name || 'The Captain';
  const displayCategory = packName || 'Unknown Pack';
  const displayQuestions = gameSession?.question_count ?? 'N/A';
  const displayTime = gameSession?.time_limit_seconds ?? 'N/A';
  const settingsAvailable = !!gameSession && !gameSession.id.startsWith('unknown');
  const canStartGame = settingsAvailable && !isLoading && isCurrentUserHost && (role === 'captain' ? crewMembers.length >= 2 : true);


  // --- Render Logic ---
  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <main className="flex-1 container mx-auto px-4 py-8">
        {/* Back Button and Game Code */}
        <div className="flex items-center justify-between mb-6">
          <Link to={getBackLink()} className="flex items-center text-pirate-navy hover:text-pirate-accent"><ArrowLeft className="h-4 w-4 mr-2" /><span>Back</span></Link>
          {gameCode && (
             <div className="flex items-center">
               <Users className="h-4 w-4 mr-2 text-pirate-navy" />
               <span className="text-sm font-mono bg-pirate-navy/10 px-2 py-1 rounded">{gameCode}</span>
               <TooltipProvider><Tooltip><TooltipTrigger asChild><button onClick={copyGameCodeToClipboard} className="ml-2 p-1 text-pirate-navy hover:text-pirate-gold transition-colors rounded-full hover:bg-pirate-navy/10" aria-label="Copy game code"><Copy className="h-4 w-4" /></button></TooltipTrigger><TooltipContent><p>Copy game code</p></TooltipContent></Tooltip></TooltipProvider>
             </div>
          )}
        </div>

        {/* Main Content Area */}
        <div className="map-container p-6 md:p-8 mb-10 relative">
           {(isLoading && !gameSession && role !== 'captain') && (
               <div className="absolute inset-0 bg-pirate-parchment/80 flex items-center justify-center rounded-xl z-20">
                   <Loader2 className="h-8 w-8 animate-spin text-pirate-navy" /><span className="ml-2 font-semibold text-pirate-navy">{role === 'scallywag' ? 'Joining Crew...' : 'Loading...'}</span>
               </div>
           )}

          {/* Player List */}
          <div className="mb-8">
            <div className='flex justify-between items-center mb-6'>
              <h2 className="font-pirate text-3xl md:text-4xl text-pirate-navy">Crew Members ({crewMembers.length})</h2>
            </div>
            {/* Participant Grid */}
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
             {crewMembers.map((member) => {
                const isYou = member.user_id === currentUserId;
                return (
                  <Card key={member.id || member.user_id} className={cn("p-4 flex items-center space-x-3 border-pirate-navy/20 shadow-md relative", isYou && "bg-pirate-navy text-white border-pirate-gold border-2")}>
                    <PlayerAvatar playerId={member.user_id} name={member.display_name} size="md" />
                    <div className="flex-1 overflow-hidden">
                      <p className={cn("font-medium truncate", isYou ? "text-white" : "text-pirate-navy")}>{member.display_name}</p>
                      <p className={cn("text-xs", isYou ? "text-white/80" : "text-pirate-navy/70")}>{member.is_host ? 'Captain' : 'Crew Member'} {isYou ? '(You)' : ''}</p>
                    </div>
                    {isYou && (<Button variant="ghost" size="icon" className="shrink-0 h-6 w-6 text-white/70 hover:text-white hover:bg-white/10 p-0" onClick={handleOpenEditModal} aria-label="Edit name" disabled={isUpdatingName}><Pencil className="h-4 w-4" /></Button>)}
                  </Card>
                );
             })}
             {crewMembers.length === 0 && role === 'scallywag' && (<div className="col-span-full text-center py-4"><p className="text-pirate-navy/60">Waiting for the Captain and crew...</p></div>)}
             {crewMembers.length <= 1 && role === 'captain' && (<div className="col-span-full text-center py-4"><p className="text-pirate-navy/60">Waiting for crew to join...</p></div>)}
            </div>
          </div>

          {/* Start Button / Waiting Message */}
          {role === 'captain' ? (
            <div className="mt-10">
              <PirateButton onClick={handleStartGame} className="w-full py-3 text-lg" variant="accent" disabled={!canStartGame || isLoading}>
                {isLoading ? <Loader2 className="h-5 w-5 animate-spin" /> : <Anchor className="h-5 w-5" />}
                {isLoading ? 'Starting...' : 'All aboard? Set sail!'}
              </PirateButton>
              {!settingsAvailable && <p className="text-xs text-center mt-2 text-pirate-navy/60">Loading game details...</p>}
              {settingsAvailable && crewMembers.length < 2 && !isLoading && <p className="text-xs text-center mt-2 text-pirate-navy/60">Waiting for at least one crew member to join...</p>}
            </div>
          ) : ( // Scallywag's view
            <div className="mt-10 text-center text-pirate-navy/80">
              <p>Waiting for {hostDisplayName} to start the voyage...</p>
              <div className="animate-pulse mt-2 text-2xl"></div>
            </div>
          )}
        </div>

        {/* Collapsible Voyage Details */}
        {settingsAvailable && (
          <Collapsible open={isVoyageDetailsOpen} onOpenChange={setIsVoyageDetailsOpen} className="mb-8">
            <Card className="p-4 flex items-center min-h-[60px] bg-pirate-parchment/50"><CollapsibleTrigger className="flex items-center justify-between w-full"><div className="flex items-center gap-2"> <Settings className="h-5 w-5 text-pirate-black" /> <h3 className="font-pirate text-2xl text-pirate-black">Voyage Details</h3> </div><ChevronDown className={`h-5 w-5 transition-transform duration-200 ${isVoyageDetailsOpen ? 'rotate-180' : ''}`} /></CollapsibleTrigger></Card>
            <CollapsibleContent className="mt-2"><Card className="p-6"><div className="grid grid-cols-1 md:grid-cols-3 gap-4"><div className="border border-pirate-navy/10 rounded p-3"><p className="text-xs text-pirate-navy/50 mb-1">Category</p><p className="font-medium capitalize">{displayCategory}</p></div><div className="border border-pirate-navy/10 rounded p-3"><p className="text-xs text-pirate-navy/50 mb-1">Questions</p><p className="font-medium">{displayQuestions}</p></div><div className="border border-pirate-navy/10 rounded p-3"><p className="text-xs text-pirate-navy/50 mb-1">Time per Question</p><p className="font-medium">{displayTime ? `${displayTime} seconds` : 'N/A'}</p></div></div></Card></CollapsibleContent>
          </Collapsible>
        )}
      </main>

      {/* Edit Name Dialog */}
      <Dialog open={isEditModalOpen} onOpenChange={setIsEditModalOpen}>
        <DialogContent className="sm:max-w-[425px] bg-pirate-parchment border-pirate-wood"><DialogHeader><DialogTitle className="font-pirate text-pirate-navy text-2xl">Change Yer Pirate Name</DialogTitle></DialogHeader>
          <Form {...editNameForm}><form onSubmit={editNameForm.handleSubmit(handleEditNameSubmit)} className="space-y-4 py-4">
            <FormField control={editNameForm.control} name="newName" rules={{ required: "A pirate needs a name!", maxLength: { value: 18, message: "Name be too long! (Max 18 chars)" }, minLength: { value: 1, message: "Name cannot be empty." } }} render={({ field }) => (<FormItem><Label htmlFor="newName" className="text-left text-pirate-navy/90">New Name</Label><FormControl><Input id="newName" {...field} className="border-pirate-navy/30 focus-visible:ring-pirate-gold" maxLength={18} autoComplete="off" /></FormControl><FormMessage /></FormItem>)} />
            <DialogFooter><PirateButton type="submit" variant="primary" disabled={isUpdatingName}>{isUpdatingName ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null} Change Name</PirateButton></DialogFooter>
          </form></Form>
        </DialogContent>
      </Dialog>

      {/* Footer */}
      <footer className="ocean-bg py-8"><div className="container mx-auto text-center text-white relative z-10"><p className="font-pirate text-xl mb-2">Ready the cannons!</p><p className="text-sm opacity-75"> 2023 Trivia Trove - All Rights Reserved</p></div></footer>
    </div>
  );
};

export default WaitingRoom;
// --- END OF FULL MODIFIED FILE ---
</file>

<file path="website/src/services/gameApi.ts">
// website/src/services/gameApi.ts
// --- START OF FULL MODIFIED FILE ---
import { API_BASE_URL } from '@/config';
import {
    ApiGameSessionResponse,
    GameCreationPayload,
    ApiGameJoinRequest,
    ApiParticipantListResponse,
    ApiGameStartResponse,
    ApiGamePlayQuestionListResponse,
    // --- ADDED IMPORTS ---
    ApiGameSubmitAnswerRequest,
    ApiQuestionResultResponse
} from '@/types/apiTypes';

/**
 * Creates a new game session on the backend.
 * @param payload - Data required to create the game (packId, settings).
 * @param userId - The ID of the user creating the game (host).
 * @returns The created game session data from the backend.
 * @throws If the API request fails.
 */
export const createGameSession = async (
  payload: GameCreationPayload,
  userId: string // Passed as query parameter
): Promise<ApiGameSessionResponse> => {
  const url = new URL(`${API_BASE_URL}/games/create`);
  url.searchParams.append('user_id', userId);

  console.log("Attempting to create game with URL:", url.toString());
  console.log("Payload:", payload);

  try {
    const response = await fetch(url.toString(), {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify(payload),
    });

    console.log("API Response Status (Create):", response.status);
    const responseData = await response.json();
    console.log("API Response Data (Create):", responseData);

    if (!response.ok) {
      const errorDetail = responseData?.detail || response.statusText || `HTTP error ${response.status}`;
      console.error("API Error Detail (Create):", errorDetail);
      throw new Error(`Failed to create game: ${errorDetail}`);
    }

    if (!responseData || typeof responseData.id !== 'string' || typeof responseData.code !== 'string') {
        console.error("Invalid response structure received (Create):", responseData);
        throw new Error("Received invalid game session data from server.");
    }

    return responseData as ApiGameSessionResponse;

  } catch (error) {
    console.error("Error creating game session:", error);
    throw error;
  }
};

/**
 * Joins an existing game session.
 * @param payload - Data required to join (game_code, display_name).
 * @param userId - The ID of the user joining the game.
 * @returns The game session data after joining.
 * @throws If the API request fails or the game cannot be joined.
 */
export const joinGameSession = async (
  payload: ApiGameJoinRequest,
  userId: string
): Promise<ApiGameSessionResponse> => {
  const url = new URL(`${API_BASE_URL}/games/join`);
  url.searchParams.append('user_id', userId);

  console.log("Attempting to join game with URL:", url.toString());
  console.log("Join Payload:", payload);

  try {
    const response = await fetch(url.toString(), {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify(payload),
    });

    console.log("API Response Status (Join):", response.status);
    const responseData = await response.json();
    console.log("API Response Data (Join):", responseData);

    if (!response.ok) {
      const errorDetail = responseData?.detail || response.statusText || `HTTP error ${response.status}`;
       console.error("API Error Detail (Join):", errorDetail);
       let userFriendlyError = `Failed to join game: ${errorDetail}`;
        if (response.status === 404 || (typeof errorDetail === 'string' && errorDetail.toLowerCase().includes("not found"))) {
            userFriendlyError = "Game code not found. Please double-check the code.";
        } else if (response.status === 400) {
             if (errorDetail && typeof errorDetail === 'string') {
                 if (errorDetail.toLowerCase().includes("not accepting new players")) {
                    userFriendlyError = "This game has already started or is no longer accepting players.";
                 } else if (errorDetail.toLowerCase().includes("is full")) {
                    userFriendlyError = "This game is full.";
                 } else {
                    userFriendlyError = `Failed to join: ${errorDetail}`;
                 }
             } else {
                 userFriendlyError = "Could not join the game. Please check the code and try again.";
             }
        }
      throw new Error(userFriendlyError);
    }

    if (!responseData || typeof responseData.id !== 'string' || typeof responseData.code !== 'string') {
        console.error("Invalid response structure received (Join):", responseData);
        throw new Error("Received invalid game session data from server after joining.");
    }

    return responseData as ApiGameSessionResponse;

  } catch (error) {
    console.error("Error joining game session:", error);
    throw error;
  }
};

/**
 * Fetches the list of participants for a given game session.
 * @param gameId - The ID of the game session.
 * @returns A promise resolving to the participant list response.
 * @throws If the API request fails.
 */
export const getGameParticipants = async (gameId: string): Promise<ApiParticipantListResponse> => {
  // Validate gameId format slightly before sending
  if (!gameId || typeof gameId !== 'string' || gameId.length < 5) { // Basic check
      console.error("Invalid gameId provided to getGameParticipants:", gameId);
      throw new Error("Invalid game ID provided.");
  }
  const url = `${API_BASE_URL}/games/${gameId}/participants`;
  console.log("Fetching participants for game:", gameId, "URL:", url);

  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
      },
    });

    console.log("API Response Status (Get Participants):", response.status);
    const responseData = await response.json();
    // console.log("API Response Data (Get Participants):", responseData); // Verbose logging

    if (!response.ok) {
      const errorDetail = responseData?.detail || response.statusText || `HTTP error ${response.status}`;
      console.error("API Error Detail (Get Participants):", errorDetail);
      throw new Error(`Failed to fetch participants: ${errorDetail}`);
    }

    if (!responseData || typeof responseData.total !== 'number' || !Array.isArray(responseData.participants)) {
        console.error("Invalid participant list structure received:", responseData);
        throw new Error("Received invalid participant data from server.");
    }

    return responseData as ApiParticipantListResponse;

  } catch (error) {
    console.error("Error fetching participants:", error);
    throw error;
  }
};

/**
 * Starts the game session (called by the host).
 * @param gameId - The ID of the game session to start.
 * @param hostUserId - The ID of the user initiating the start (must be the host).
 * @returns A promise resolving to the game start response, including the first question.
 * @throws If the API request fails (e.g., user not host, game not found, wrong status).
 */
export const startGame = async (gameId: string, hostUserId: string): Promise<ApiGameStartResponse> => {
    if (!gameId || !hostUserId) {
      throw new Error("Game ID and Host User ID are required to start the game.");
    }
    const url = new URL(`${API_BASE_URL}/games/${gameId}/start`);
    url.searchParams.append('user_id', hostUserId);

    console.log("Attempting to start game:", gameId, "by host:", hostUserId, "URL:", url.toString());

    try {
        const response = await fetch(url.toString(), {
            method: 'POST',
            headers: {
                'Accept': 'application/json',
            },
        });

        console.log("API Response Status (Start Game):", response.status);
        const responseData = await response.json();
        // console.log("API Response Data (Start Game):", responseData); // Verbose logging

        if (!response.ok) {
            const errorDetail = responseData?.detail || response.statusText || `HTTP error ${response.status}`;
            console.error("API Error Detail (Start Game):", errorDetail);
            throw new Error(`Failed to start game: ${errorDetail}`);
        }

        if (!responseData || typeof responseData.status !== 'string' || !responseData.current_question || typeof responseData.current_question.index !== 'number') {
            console.error("Invalid game start response structure received:", responseData);
            throw new Error("Received invalid game start data from server.");
        }

        return responseData as ApiGameStartResponse;

    } catch (error) {
        console.error("Error starting game:", error);
        throw error;
    }
};

/**
 * Fetches the actual questions prepared for a specific game session.
 * @param gameId - The ID of the game session.
 * @returns A promise resolving to the list of questions for gameplay.
 * @throws If the API request fails.
 */
export const getGamePlayQuestions = async (gameId: string): Promise<ApiGamePlayQuestionListResponse> => {
    if (!gameId || typeof gameId !== 'string' || gameId.length < 5) {
      console.error("Invalid gameId provided to getGamePlayQuestions:", gameId);
      throw new Error("Invalid game ID provided.");
    }
    const url = `${API_BASE_URL}/games/${gameId}/play-questions`;
    console.log("Fetching gameplay questions for game:", gameId, "URL:", url);

    try {
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
            },
        });

        console.log("API Response Status (Get Play Questions):", response.status);
        const responseData = await response.json();
        // console.log("API Response Data (Get Play Questions):", responseData); // Verbose logging

        if (!response.ok) {
            const errorDetail = responseData?.detail || response.statusText || `HTTP error ${response.status}`;
            console.error("API Error Detail (Get Play Questions):", errorDetail);
            throw new Error(`Failed to fetch gameplay questions: ${errorDetail}`);
        }

        // --- UPDATED VALIDATION ---
        if (!responseData || typeof responseData.game_id !== 'string' || !Array.isArray(responseData.questions) || typeof responseData.total_questions !== 'number') {
            console.error("Invalid gameplay questions response structure:", responseData);
            throw new Error("Received invalid gameplay questions data from server.");
        }
        // Add check for correct_answer_id in the first question if available
        if (responseData.questions.length > 0 && typeof responseData.questions[0].correct_answer_id !== 'string') {
            console.error("Invalid question structure within gameplay questions response (missing correct_answer_id):", responseData.questions[0]);
            throw new Error("Received invalid question data (missing correct ID) from server.");
        }
        // --- END UPDATED VALIDATION ---

        return responseData as ApiGamePlayQuestionListResponse;

    } catch (error) {
        console.error("Error fetching gameplay questions:", error);
        throw error;
    }
};

// --- *** ADDED FUNCTION *** ---
/**
 * Submits a player's answer for a specific question in a game session.
 * @param gameId - The ID of the game session.
 * @param participantId - The ID of the participant submitting the answer.
 * @param payload - The answer data (question index and the answer itself).
 * @returns A promise resolving to the result of the submission (correctness, scores).
 * @throws If the API request fails.
 */
export const submitAnswer = async (
    gameId: string,
    participantId: string,
    payload: ApiGameSubmitAnswerRequest
): Promise<ApiQuestionResultResponse> => {
    if (!gameId || !participantId) {
        throw new Error("Game ID and Participant ID are required to submit an answer.");
    }
    const url = new URL(`${API_BASE_URL}/games/${gameId}/submit`);
    url.searchParams.append('participant_id', participantId);

    console.log("Attempting to submit answer:", payload, "to URL:", url.toString());

    try {
        const response = await fetch(url.toString(), {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            },
            body: JSON.stringify(payload),
        });

        console.log("API Response Status (Submit Answer):", response.status);
        const responseData = await response.json();
        // console.log("API Response Data (Submit Answer):", responseData); // Verbose logging

        if (!response.ok) {
            const errorDetail = responseData?.detail || response.statusText || `HTTP error ${response.status}`;
            console.error("API Error Detail (Submit Answer):", errorDetail);
            throw new Error(`Failed to submit answer: ${errorDetail}`);
        }

        // Validate response structure
        if (responseData === null || typeof responseData !== 'object' || typeof responseData.is_correct !== 'boolean' || typeof responseData.correct_answer !== 'string' || typeof responseData.score !== 'number' || typeof responseData.total_score !== 'number') {
           console.error("Invalid answer result structure received:", responseData);
           throw new Error("Received invalid answer result data from server.");
        }


        return responseData as ApiQuestionResultResponse;

    } catch (error) {
        console.error("Error submitting answer:", error);
        throw error;
    }
};
// --- *** END ADDED FUNCTION *** ---

// --- END OF FILE ---
</file>

<file path="website/src/services/packApi.ts">
// website/src/services/packApi.ts
// --- START OF FILE ---
import { API_BASE_URL } from '@/config';
import { ApiPackListResponse } from '@/types/apiTypes';

/**
 * Fetches the list of available trivia packs from the backend.
 * @returns The response containing the list of packs.
 * @throws If the API request fails.
 */
export const fetchPacks = async (): Promise<ApiPackListResponse> => {
  const url = `${API_BASE_URL}/packs`; // Target the GET /api/packs endpoint
  console.log("Attempting to fetch packs from:", url);

  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
      },
    });

    console.log("Fetch Packs API Response Status:", response.status);

    let responseData: any;
    try {
        responseData = await response.json();
        // console.log("Fetch Packs API Response Data:", responseData); // Log data if needed
    } catch (jsonError) {
        console.error("Failed to parse JSON response from fetchPacks:", jsonError);
        if (!response.ok) {
            throw new Error(`HTTP error ${response.status}: Failed to fetch packs. Invalid response format.`);
        }
        throw new Error(`Failed to parse successful fetchPacks response JSON: ${jsonError}`);
    }


    if (!response.ok) {
      const errorDetail = responseData?.detail || response.statusText || `HTTP error ${response.status}`;
      console.error("API Error Detail (fetchPacks):", errorDetail);
      throw new Error(`Failed to fetch packs: ${errorDetail}`);
    }

    // Basic validation
    if (!responseData || typeof responseData.total !== 'number' || !Array.isArray(responseData.packs)) {
        console.error("Invalid packs list structure received:", responseData);
        throw new Error("Received invalid pack list data from server.");
    }

    console.log(`Successfully fetched ${responseData.packs.length} packs.`);
    return responseData as ApiPackListResponse;

  } catch (error) {
    console.error("Error fetching packs:", error);
    // Re-throw the error to be caught by the calling component
    throw error;
  }
};

// --- END OF FILE ---
</file>

<file path="website/src/services/userApi.ts">
// website/src/services/userApi.ts
// --- Add this file content ---
import { API_BASE_URL } from '@/config';
import { ApiUserCreateRequest, ApiUserResponse } from '@/types/apiTypes';

// --- Keep existing createUser and createTemporaryUser functions ---
export const createUser = async (payload: ApiUserCreateRequest): Promise<ApiUserResponse> => {
  const url = `${API_BASE_URL}/users`; // POST /api/users
  console.log("Attempting to create user:", payload);

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify(payload),
    });

    console.log("API Response Status (Create User):", response.status);

    let responseData: any;
    try {
        responseData = await response.json();
        console.log("API Response Data (Create User):", responseData);
    } catch (jsonError) {
        console.error("Failed to parse JSON response (Create User):", jsonError);
        if (!response.ok) {
            throw new Error(`HTTP error ${response.status}: Failed to create user. Invalid response format.`);
        }
        throw new Error(`Failed to parse successful response JSON (Create User): ${jsonError}`);
    }

    if (!response.ok) {
      const errorDetail = responseData?.detail || response.statusText || `HTTP error ${response.status}`;
       let formattedError = errorDetail;
       if (Array.isArray(errorDetail)) {
         formattedError = errorDetail.map(err => `${err.loc?.join('.')} - ${err.msg}`).join('; ');
       } else if (typeof errorDetail === 'object') {
         formattedError = JSON.stringify(errorDetail);
       }
      console.error("API Error Detail (Create User):", formattedError);
      throw new Error(`Failed to create user: ${formattedError}`);
    }

    if (!responseData || typeof responseData.id !== 'string') {
        console.error("Invalid user response structure received:", responseData);
        throw new Error("Received invalid user data from server.");
    }

    return responseData as ApiUserResponse;

  } catch (error) {
    console.error("Error creating user:", error);
    throw error;
  }
};

export const createTemporaryUser = async (displayName?: string | null): Promise<ApiUserResponse> => {
    // Allow null to be passed
    const payload: ApiUserCreateRequest = {
        is_temporary: true,
        displayname: displayName, // Pass null if provided as null
    };
    return createUser(payload);
};


// --- *** ADD THIS NEW FUNCTION *** ---
/**
 * Updates an existing user on the backend.
 * @param userId - The ID of the user to update.
 * @param payload - Data containing the fields to update.
 * @returns The updated user data from the backend.
 * @throws If the API request fails.
 */
export const updateUser = async (userId: string, payload: Partial<ApiUserCreateRequest>): Promise<ApiUserResponse> => {
    const url = `${API_BASE_URL}/users/${userId}`; // PUT /api/users/{user_id}
    console.log(`Attempting to update user ${userId}:`, payload);

    try {
        const response = await fetch(url, {
            method: 'PUT', // Use PUT for updates
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            },
            body: JSON.stringify(payload),
        });

        console.log(`API Response Status (Update User ${userId}):`, response.status);

        let responseData: any;
         try {
             responseData = await response.json();
             console.log(`API Response Data (Update User ${userId}):`, responseData);
         } catch (jsonError) {
             console.error(`Failed to parse JSON response (Update User ${userId}):`, jsonError);
             if (!response.ok) {
                 throw new Error(`HTTP error ${response.status}: Failed to update user. Invalid response format.`);
             }
             throw new Error(`Failed to parse successful response JSON (Update User ${userId}): ${jsonError}`);
         }


        if (!response.ok) {
            const errorDetail = responseData?.detail || response.statusText || `HTTP error ${response.status}`;
            let formattedError = errorDetail;
            if (Array.isArray(errorDetail)) {
              formattedError = errorDetail.map(err => `${err.loc?.join('.')} - ${err.msg}`).join('; ');
            } else if (typeof errorDetail === 'object') {
              formattedError = JSON.stringify(errorDetail);
            }
            console.error(`API Error Detail (Update User ${userId}):`, formattedError);
            throw new Error(`Failed to update user: ${formattedError}`);
        }

        if (!responseData || typeof responseData.id !== 'string') {
            console.error("Invalid user response structure received after update:", responseData);
            throw new Error("Received invalid user data from server after update.");
        }

        return responseData as ApiUserResponse;

    } catch (error) {
        console.error(`Error updating user ${userId}:`, error);
        throw error; // Re-throw
    }
};
// --- *** END ADDED FUNCTION *** ---
// --- END OF FILE ---
</file>

<file path="website/src/types/apiTypes.ts">
// website/src/types/apiTypes.ts
// --- START OF FULL MODIFIED FILE ---

// --- User API Types ---
// Matches backend UserCreateRequest (body)
export interface ApiUserCreateRequest {
    displayname?: string | null;
    email?: string | null;
    is_temporary: boolean;
    auth_provider?: string | null;
    auth_id?: string | null;
  }
  
  // Matches backend UserResponse
  export interface ApiUserResponse {
    id: string;
    displayname: string | null;
    email: string | null;
    is_temporary: boolean;
    created_at: string; // ISO date string
  }
  // --- END User API Types ---
  
  
  // --- Game API Types ---
  // Matches backend GameSessionCreateRequest (body)
  export interface GameCreationPayload {
    pack_id: string;
    max_participants: number;
    question_count: number;
    time_limit_seconds: number;
  }
  
  // Matches relevant parts of backend GameSessionResponse
  export interface ApiGameSessionResponse {
    id: string;
    code: string;
    status: string; // "pending", "active", etc.
    pack_id: string;
    max_participants: number;
    question_count: number;
    time_limit_seconds: number;
    current_question_index: number;
    participant_count: number;
    is_host: boolean;
    created_at: string; // ISO date string
  }
  
  // Matches backend GameSessionJoinRequest (body)
  export interface ApiGameJoinRequest {
      game_code: string;
      display_name: string;
  }
  
  // Matches backend GameQuestionInfo
  export interface ApiGameQuestionInfo {
      index: number;
      question_text: string;
      options: string[];
      time_limit: number;
  }
  
  // Matches backend GameStartResponse
  export interface ApiGameStartResponse {
      status: string; // e.g., "active"
      current_question: ApiGameQuestionInfo;
  }
  
  // Matches the participant structure returned by the GET /participants endpoint
  export interface ApiParticipant {
      id: string; // This is the participant record ID
      user_id: string; // The actual User ID
      display_name: string;
      score: number;
      is_host: boolean;
  }
  
  // Matches the structure of the GET /participants response
  export interface ApiParticipantListResponse {
      total: number;
      participants: ApiParticipant[];
  }
  
  // Matches backend GameSessionSubmitAnswerRequest (body)
  export interface ApiGameSubmitAnswerRequest {
    question_index: number;
    answer: string; // The selected answer (could be text or ID depending on implementation)
  }
  
  // Matches backend QuestionResultResponse
  export interface ApiQuestionResultResponse {
    is_correct: boolean;
    correct_answer: string;
    score: number;
    total_score: number;
  }
  
  // --- NEW TYPES FOR /play-questions ---
  // Matches backend GamePlayQuestionResponse
  export interface ApiGamePlayQuestion {
      index: number;
      question_id: string;
      question_text: string;
      options: string[]; // Shuffled options from backend
      correct_answer_id: string; // ID of the correct answer option (e.g., "q1-option2")
      time_limit: number; // Time limit per question
  }
  
  // Matches backend GamePlayQuestionListResponse
  export interface ApiGamePlayQuestionListResponse {
      game_id: string;
      questions: ApiGamePlayQuestion[];
      total_questions: number;
  }
  // --- END NEW TYPES ---
  
  // --- Pack API Types ---
  // Matches backend PackResponse schema
  export interface ApiPackResponse {
      id: string;
      name: string;
      description: string | null;
      price: number;
      pack_group_id: string[] | null;
      creator_type: 'system' | 'user';
      correct_answer_rate: number | null;
      created_at: string; // ISO date string
  }
  
  // Matches backend PackListResponse schema
  export interface ApiPackListResponse {
      total: number;
      packs: ApiPackResponse[];
  }
  // --- END Pack API Types ---
  
  // --- END OF FILE ---
</file>

<file path="website/src/types/gameTypes.ts">
export interface Answer {
  id: string;
  text: string;
  letter: string;
}

export interface Question {
  id: string;
  text: string;
  category: string;
  answers: Answer[];
  correctAnswer: string;
  timeLimit: number;
}

export interface Player {
  id: string;
  name: string;
  avatar?: string; // This should hold the emoji, initials, or URL
}

// *** ADDED: PlayerResult interface extending Player ***
export interface PlayerResult extends Player {
  score: number;
}
// *** END ADDED ***

export interface PlayerSelection {
  playerId: string;
  answerId: string;
}
</file>

<file path="website/src/types/websocketTypes.ts">
// website/src/types/websocketTypes.ts

import { ApiParticipant, ApiGameSessionResponse, ApiGamePlayQuestion } from './apiTypes'; // Assuming these are defined

// --------- Message Types Sent FROM Backend TO Frontend ---------

/** Message indicating a user joined or their info updated (e.g., name change) */
export interface WsParticipantUpdatePayload extends ApiParticipant {}
export interface WsParticipantUpdateMessage {
    type: 'participant_update';
    payload: WsParticipantUpdatePayload;
}

/** Message indicating a user left the game */
export interface WsParticipantLeftPayload {
    user_id: string; // ID of the user who left
    participant_id: string; // ID of the participant record
    display_name: string; // Name of the user who left (for potential notification)
}
export interface WsParticipantLeftMessage {
    type: 'participant_left';
    payload: WsParticipantLeftPayload;
}

/** Message indicating a user's display name changed */
export interface WsUserNameUpdatedPayload {
    user_id: string;
    new_display_name: string;
}
export interface WsUserNameUpdatedMessage {
    type: 'user_name_updated';
    payload: WsUserNameUpdatedPayload;
}

/** Message indicating the game has started (sent by host action) */
export interface WsGameStartedPayload {
    game_id: string;
    status: string; // Should be 'active'
    total_questions: number;
    time_limit: number;
    pack_id: string;
    current_question: ApiGamePlayQuestion | null; // Include the first question
}
export interface WsGameStartedMessage {
    type: 'game_started';
    payload: WsGameStartedPayload;
}

/** Message indicating the next question is ready */
export interface WsNextQuestionPayload extends ApiGamePlayQuestion {} // Re-use the existing API type
export interface WsNextQuestionMessage {
    type: 'next_question';
    payload: WsNextQuestionPayload;
}

/** Message indicating the game is over and includes final results */
export interface WsGameOverPayload {
    // Structure should match the response from GET /games/{game_id}/results
    game_id: string;
    game_code: string;
    status: string; // Should be 'completed' or 'cancelled'
    participants: ApiParticipant[]; // Final scores included here
    questions: any[]; // Include question result summaries if needed
    total_questions: number;
    completed_at: string; // ISO date string
}
export interface WsGameOverMessage {
    type: 'game_over';
    payload: WsGameOverPayload;
}

/** Message indicating the game was cancelled by the host */
export interface WsGameCancelledPayload {
    game_id: string;
}
export interface WsGameCancelledMessage {
    type: 'game_cancelled';
    payload: WsGameCancelledPayload;
}

/** Generic error message from the backend via WebSocket */
export interface WsErrorPayload {
    message: string;
    detail?: string;
}
export interface WsErrorMessage {
    type: 'error';
    payload: WsErrorPayload;
}

// --------- Union Type for ALL Incoming Messages ---------
export type IncomingWsMessage =
    | WsParticipantUpdateMessage
    | WsParticipantLeftMessage
    | WsUserNameUpdatedMessage
    | WsGameStartedMessage
    | WsNextQuestionMessage
    | WsGameOverMessage
    | WsGameCancelledMessage
    | WsErrorMessage;


// --------- Message Types Sent FROM Frontend TO Backend ---------
// (Currently, we are not planning to send messages from client to server,
// but you could define them here if needed, e.g., for submitting answers via WS)

// Example:
// export interface WsSubmitAnswerPayload {
//     question_index: number;
//     answer_id: string;
// }
// export interface WsSubmitAnswerMessage {
//     type: 'submit_answer';
//     payload: WsSubmitAnswerPayload;
// }
// export type OutgoingWsMessage = WsSubmitAnswerMessage;
</file>

<file path="website/src/utils/gamePlayUtils.ts">
// src/utils/gamePlayUtils.ts
import { Question, Player } from '@/types/gameTypes';

// Define the list of themed emojis (keep as is)
export const THEMED_AVATAR_EMOJIS = [
  '', '', '', '', '', '', '', '', '', '',
  '', '', '', '', '', '', '', '', '', ''
];

// Simple hash function for string IDs (keep as is)
const simpleHashCode = (str: string): number => {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash |= 0; // Convert to 32bit integer
  }
  return Math.abs(hash); // Ensure positive number
};

// Function to get a consistent emoji based on player ID (keep as is)
export const getEmojiForPlayerId = (playerId: string): string => {
  const hash = simpleHashCode(playerId);
  const index = hash % THEMED_AVATAR_EMOJIS.length;
  return THEMED_AVATAR_EMOJIS[index];
};

// --- NEW: Predefined Pirate Names ---
export const PREDEFINED_PIRATE_NAMES = [
    "One-Eyed Jack", "Calico Anne", "Salty Dog Sam", "Mad Morgan", "Cutlass Kate",
    "Barnacle Bill", "Stormy Sue", "Cannonball Chris", "Pegleg Pete", "Siren Sarah",
    "Ironhook", "Lady Vane", "Sharkbait", "Dead-Eye Dan", "Coral Queen",
    "Buccaneer Bob", "Rum Runner Riley", "Marauder Mike", "Sea Serpent Steve", "Goldtooth Gary"
]; // 20 names

// --- NEW: Function to assign a name based on User ID ---
export const getPirateNameForUserId = (userId: string): string => {
    if (!userId) {
        console.warn("Attempted to get pirate name for empty userId, returning default.");
        return PREDEFINED_PIRATE_NAMES[0]; // Return a default if ID is somehow missing
    }
    const hash = simpleHashCode(userId);
    const index = hash % PREDEFINED_PIRATE_NAMES.length;
    return PREDEFINED_PIRATE_NAMES[index];
};
// --- END NEW ---


// --- Mock Data (Keep for now, but Waiting Room won't use names from here) ---
// Mock questions for development (keep as is)
export const mockQuestions: Question[] = [
    // ... (keep mock questions as they are) ...
    { id: '1', text: "Which famous historical pirate sailed the seas with a terrifying black beard and became notorious for his fierce battles while commanding the powerful ship known as Queen Anne's Revenge?", category: "Pirate History", answers: [ { id: 'a', text: "Blackbeard the fearsome pirate", letter: "A" }, { id: 'b', text: "Captain Kidd treasure hunter", letter: "B" }, { id: 'c', text: "Anne Bonny fierce fighter", letter: "C" }, { id: 'd', text: "Jack Sparrow fictional captain", letter: "D" } ], correctAnswer: 'a', timeLimit: 20 }, { id: '2', text: "What was the name of the pirate code that governed behavior aboard pirate ships in the Golden Age of Piracy?", category: "Pirate Code", answers: [ { id: 'a', text: "The Black Spot", letter: "A" }, { id: 'b', text: "Articles of Agreement", letter: "B" }, { id: 'c', text: "Pirate's Charter", letter: "C" }, { id: 'd', text: "Rules of Engagement", letter: "D" } ], correctAnswer: 'b', timeLimit: 20 }, { id: '3', text: "Which island was a notorious pirate haven in the Caribbean during the Golden Age of Piracy?", category: "Pirate Havens", answers: [ { id: 'a', text: "Bermuda", letter: "A" }, { id: 'b', text: "Jamaica", letter: "B" }, { id: 'c', text: "Nassau (New Providence)", letter: "C" }, { id: 'd', text: "Cuba", letter: "D" } ], correctAnswer: 'c', timeLimit: 20 },
];

// Mock players for development - these IDs will be used for assignment, but names ignored
export const mockPlayers: Player[] = [
  { id: 'p1', name: 'IGNORED' }, // Name will be replaced by assigned name
  { id: 'p2', name: 'IGNORED' },
  { id: 'p3', name: 'IGNORED' },
  { id: 'p4', name: 'IGNORED' },
  { id: 'p5', name: 'IGNORED' },
];

// Helper function to find player by ID (keep as is)
export const getPlayerById = (players: Player[], id: string): Player | undefined => {
  return players.find(p => p.id === id);
};

// Calculate question text size class based on length (keep as is)
export const getQuestionTextClass = (text: string): string => {
  const wordCount = text.split(' ').length;
  if (wordCount > 20) return 'text-lg md:text-xl';
  if (wordCount > 15) return 'text-xl md:text-2xl';
  return 'text-2xl md:text-3xl';
};
</file>

<file path="website/src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="website/src/App.tsx">
// src/App.tsx
// --- START OF FILE ---
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import Index from "./pages/Index";
import GameSelect from "./pages/GameSelect";
import RoleSelect from "./pages/RoleSelect";
import WaitingRoom from "./pages/WaitingRoom";
import NotFound from "./pages/NotFound";
import CountdownScreen from "./pages/CountdownScreen";
import GameplayScreen from "./pages/GameplayScreen";
import ResultsScreen from "./pages/ResultsScreen";
import AuthScreen from "./pages/AuthScreen"; // Import the new screen

const queryClient = new QueryClient();

const App = () => (
  <QueryClientProvider client={queryClient}>
    <TooltipProvider>
      <Toaster />
      <Sonner />
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<Index />} />
          <Route path="/auth" element={<AuthScreen />} /> {/* Add Auth route */}
          <Route path="/solo" element={<GameSelect mode="solo" />} />
          <Route path="/crew" element={<RoleSelect />} />
          <Route path="/crew/:role" element={<GameSelect mode="crew" />} />
          <Route path="/solo/waiting" element={<WaitingRoom />} />
          <Route path="/crew/waiting/:role" element={<WaitingRoom />} />
          <Route path="/countdown" element={<CountdownScreen />} />
          <Route path="/gameplay" element={<GameplayScreen />} />
          <Route path="/results" element={<ResultsScreen />} />
          {/* ADD ALL CUSTOM ROUTES ABOVE THE CATCH-ALL "*" ROUTE */}
          <Route path="*" element={<NotFound />} />
        </Routes>
      </BrowserRouter>
    </TooltipProvider>
  </QueryClientProvider>
);

export default App;
// --- END OF FILE ---
</file>

<file path="website/src/config.ts">
// website/src/config.ts
// --- START OF FILE ---
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api'; // Fallback includes /api

// Add a check to see if the environment variable was loaded
if (!import.meta.env.VITE_API_BASE_URL) {
  console.warn(
    "VITE_API_BASE_URL environment variable not found. " +
    `Using default value: ${API_BASE_URL}. ` +
    "Make sure you have a .env.development file with VITE_API_BASE_URL=http://<your_backend_ip>:<your_backend_port>/api"
  );
} else {
  console.log("Using API Base URL from environment:", API_BASE_URL);
}


export { API_BASE_URL };
// --- END OF FILE ---
</file>

<file path="website/src/index.css">
@import url('https://fonts.googleapis.com/css2?family=Pirata+One&family=Lora:wght@400;600;700&family=Inter:wght@300;400;500;600;700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;

    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;

    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;

    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;

    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;

    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;

    --radius: 0.5rem;

    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;

    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;

    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;

    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;

    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-pirate-parchment text-pirate-black font-serif;
    background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%230A2463' fill-opacity='0.05'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
  }
}

@layer components {
  .pirate-heading {
    @apply font-pirate text-pirate-navy tracking-wide;
  }

  .treasure-button-primary {
    @apply bg-pirate-navy text-white font-semibold py-4 px-6 rounded-full 
           shadow-lg transform transition-all duration-300 hover:scale-105
           hover:shadow-xl border-2 border-pirate-gold;
  }
  
  .treasure-button-secondary {
    @apply bg-white text-pirate-navy font-semibold py-4 px-6 rounded-full
           shadow-md transform transition-all duration-300 hover:scale-105
           hover:shadow-lg border-2 border-pirate-navy;
  }

  .ocean-bg {
    @apply relative overflow-hidden bg-pirate-navy;
  }
  
  .ocean-bg::before {
    content: '';
    @apply absolute inset-0 bg-wave-pattern bg-repeat-x animate-wave opacity-30;
  }

  .map-container {
    @apply border-4 border-pirate-wood rounded-xl bg-pirate-parchment shadow-xl;
    background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%238C5E3C' fill-opacity='0.1' fill-rule='evenodd'/%3E%3C/svg%3E");
  }
}
</file>

<file path="website/src/main.tsx">
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById("root")!).render(<App />);
</file>

<file path="website/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="website/.env.development">
VITE_API_BASE_URL=http://127.0.0.1:8000/api
VITE_WS_BASE_URL=ws://127.0.0.1:8000
</file>

<file path="website/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="website/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="website/eslint.config.js">
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";

export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": [
        "warn",
        { allowConstantExport: true },
      ],
      "@typescript-eslint/no-unused-vars": "off",
    },
  }
);
</file>

<file path="website/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Trivia Trove - Pirate-Themed Trivia Game</title>
    <meta name="description" content="Test your knowledge with Trivia Trove, a pirate-themed trivia game for solo players or groups." />
    <meta name="author" content="Lovable" />

    <meta property="og:title" content="Trivia Trove - Pirate-Themed Trivia Game" />
    <meta property="og:description" content="Test your knowledge with Trivia Trove, a pirate-themed trivia game for solo players or groups." />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Pirata+One&family=Lora:wght@400;600;700&family=Inter:wght@300;400;500;600;700&display=swap">
  </head>

  <body>
    <div id="root"></div>
    <!-- IMPORTANT: DO NOT REMOVE THIS SCRIPT TAG OR THIS VERY COMMENT! -->
    <script src="https://cdn.gpteng.co/gptengineer.js" type="module"></script>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="website/package.json">
{
  "name": "vite_react_shadcn_ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.0",
    "@radix-ui/react-accordion": "^1.2.0",
    "@radix-ui/react-alert-dialog": "^1.1.1",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.0",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-collapsible": "^1.1.0",
    "@radix-ui/react-context-menu": "^2.2.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-hover-card": "^1.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.1",
    "@radix-ui/react-navigation-menu": "^1.2.0",
    "@radix-ui/react-popover": "^1.1.1",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.0",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.1",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@tanstack/react-query": "^5.56.2",
    "@types/canvas-confetti": "^1.9.0",
    "canvas-confetti": "^1.9.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "date-fns": "^3.6.0",
    "embla-carousel-react": "^8.3.0",
    "input-otp": "^1.2.4",
    "lucide-react": "^0.462.0",
    "next-themes": "^0.3.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.53.0",
    "react-resizable-panels": "^2.1.3",
    "react-router-dom": "^6.26.2",
    "recharts": "^2.12.7",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@tailwindcss/typography": "^0.5.15",
    "@types/node": "^22.5.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.9.0",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "globals": "^15.9.0",
    "lovable-tagger": "^1.1.7",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.11",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.0.1",
    "vite": "^5.4.1"
  }
}
</file>

<file path="website/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="website/README.md">
# Welcome to your Lovable project

## Project info

**URL**: https://lovable.dev/projects/0778749c-b999-42cf-948e-8e882536902b

## How can I edit this code?

There are several ways of editing your application.

**Use Lovable**

Simply visit the [Lovable Project](https://lovable.dev/projects/0778749c-b999-42cf-948e-8e882536902b) and start prompting.

Changes made via Lovable will be committed automatically to this repo.

**Use your preferred IDE**

If you want to work locally using your own IDE, you can clone this repo and push changes. Pushed changes will also be reflected in Lovable.

The only requirement is having Node.js & npm installed - [install with nvm](https://github.com/nvm-sh/nvm#installing-and-updating)

Follow these steps:

```sh
# Step 1: Clone the repository using the project's Git URL.
git clone <YOUR_GIT_URL>

# Step 2: Navigate to the project directory.
cd <YOUR_PROJECT_NAME>

# Step 3: Install the necessary dependencies.
npm i

# Step 4: Start the development server with auto-reloading and an instant preview.
npm run dev
```

**Edit a file directly in GitHub**

- Navigate to the desired file(s).
- Click the "Edit" button (pencil icon) at the top right of the file view.
- Make your changes and commit the changes.

**Use GitHub Codespaces**

- Navigate to the main page of your repository.
- Click on the "Code" button (green button) near the top right.
- Select the "Codespaces" tab.
- Click on "New codespace" to launch a new Codespace environment.
- Edit files directly within the Codespace and commit and push your changes once you're done.

## What technologies are used for this project?

This project is built with:

- Vite
- TypeScript
- React
- shadcn-ui
- Tailwind CSS

## How can I deploy this project?

Simply open [Lovable](https://lovable.dev/projects/0778749c-b999-42cf-948e-8e882536902b) and click on Share -> Publish.

## Can I connect a custom domain to my Lovable project?

Yes it is!

To connect a domain, navigate to Project > Settings > Domains and click Connect Domain.

Read more here: [Setting up a custom domain](https://docs.lovable.dev/tips-tricks/custom-domain#step-by-step-guide)
</file>

<file path="website/tailwind.config.ts">
import type { Config } from "tailwindcss";

export default {
	darkMode: ["class"],
	content: [
		"./pages/**/*.{ts,tsx}",
		"./components/**/*.{ts,tsx}",
		"./app/**/*.{ts,tsx}",
		"./src/**/*.{ts,tsx}",
	],
	prefix: "",
	theme: {
		container: {
			center: true,
			padding: '2rem',
			screens: {
				'2xl': '1400px'
			}
		},
		extend: {
			colors: {
				border: 'hsl(var(--border))',
				input: 'hsl(var(--input))',
				ring: 'hsl(var(--ring))',
				background: 'hsl(var(--background))',
				foreground: 'hsl(var(--foreground))',
				primary: {
					DEFAULT: 'hsl(var(--primary))',
					foreground: 'hsl(var(--primary-foreground))'
				},
				secondary: {
					DEFAULT: 'hsl(var(--secondary))',
					foreground: 'hsl(var(--secondary-foreground))'
				},
				destructive: {
					DEFAULT: 'hsl(var(--destructive))',
					foreground: 'hsl(var(--destructive-foreground))'
				},
				muted: {
					DEFAULT: 'hsl(var(--muted))',
					foreground: 'hsl(var(--muted-foreground))'
				},
				accent: {
					DEFAULT: 'hsl(var(--accent))',
					foreground: 'hsl(var(--accent-foreground))'
				},
				popover: {
					DEFAULT: 'hsl(var(--popover))',
					foreground: 'hsl(var(--popover-foreground))'
				},
				card: {
					DEFAULT: 'hsl(var(--card))',
					foreground: 'hsl(var(--card-foreground))'
				},
				sidebar: {
					DEFAULT: 'hsl(var(--sidebar-background))',
					foreground: 'hsl(var(--sidebar-foreground))',
					primary: 'hsl(var(--sidebar-primary))',
					'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
					accent: 'hsl(var(--sidebar-accent))',
					'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
					border: 'hsl(var(--sidebar-border))',
					ring: 'hsl(var(--sidebar-ring))'
				},
				// Pirate theme colors
				pirate: {
					navy: '#0A2463',  // Deep blue sea
					gold: '#F2A71B',  // Treasure gold
					wood: '#8C5E3C',  // Ship's deck
					parchment: '#F2E8DC', // Treasure map
					black: '#0F1A20',  // Pirate black
					accent: '#D95D39',  // Captain's coat
				}
			},
			fontFamily: {
				pirate: ['Pirata One', 'serif'],
				serif: ['Lora', 'serif'],
				sans: ['Inter', 'sans-serif'],
			},
			backgroundImage: {
				'ocean-pattern': "url('/public/lovable-uploads/b813414c-3962-43b6-baca-20f43e2b8c6b.png')",
				'wave-pattern': "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxOHB4IiB2aWV3Qm94PSIwIDAgMTI4MCAxNDAiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzBBMjQ2MyI+PHBhdGggZD0iTTEyODAgMTQwVjBTOTkzLjQ2IDE0MCA2NDAgMTM5IDAgMCAwIDB2MTQweiIvPjwvZz48L3N2Zz4=')",
			},
			borderRadius: {
				lg: 'var(--radius)',
				md: 'calc(var(--radius) - 2px)',
				sm: 'calc(var(--radius) - 4px)'
			},
			keyframes: {
				'accordion-down': {
					from: { height: '0' },
					to: { height: 'var(--radix-accordion-content-height)' },
				},
				'accordion-up': {
					from: { height: 'var(--radix-accordion-content-height)' },
					to: { height: '0' },
				},
				'float': {
					'0%, 100%': { transform: 'translateY(0)' },
					'50%': { transform: 'translateY(-10px)' },
				},
				'wave': {
					'0%': { transform: 'translateX(0)' },
					'50%': { transform: 'translateX(-25%)' },
					'100%': { transform: 'translateX(-50%)' },
				}
			},
			animation: {
				'accordion-down': 'accordion-down 0.2s ease-out',
				'accordion-up': 'accordion-up 0.2s ease-out',
				'float': 'float 3s ease-in-out infinite',
				'wave': 'wave 15s linear infinite',
			}
		}
	},
	plugins: [require("tailwindcss-animate")],
} satisfies Config;
</file>

<file path="website/tsconfig.app.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitAny": false,
    "noFallthroughCasesInSwitch": false,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}
</file>

<file path="website/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}
</file>

<file path="website/tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="website/vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";
import { componentTagger } from "lovable-tagger";

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => ({
  server: {
    host: "::",
    port: 8080,
  },
  plugins: [
    react(),
    mode === 'development' &&
    componentTagger(),
  ].filter(Boolean),
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
}));
</file>

</files>
